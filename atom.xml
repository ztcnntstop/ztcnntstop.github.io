<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZeTiiCannotStop</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-08T07:39:57.333Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZeTii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是一篇图片测试</title>
    <link href="http://example.com/2025/02/07/%E6%B5%8B%E8%AF%95%E4%BA%8C/"/>
    <id>http://example.com/2025/02/07/%E6%B5%8B%E8%AF%95%E4%BA%8C/</id>
    <published>2025-02-07T07:35:04.000Z</published>
    <updated>2025-02-08T07:39:57.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🍺这是一个测试，看看图片在云上是否还能正确保存<br>(这是来自2025年的检查。。。太久没上了看看是否上传内容有任何错误)</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20250208153740.png" alt="20250208153740"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🍺这是一个测试，看看图片在云上是否还能正确保存&lt;br&gt;(这是来自2025年的检查。。。太久没上了看看是否上传内容有任何错误)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ztcnntstop.oss-cn-sha</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UE5和SD_美漫风格的火车场景</title>
    <link href="http://example.com/2023/06/20/ue_TrainSC/"/>
    <id>http://example.com/2023/06/20/ue_TrainSC/</id>
    <published>2023-06-20T03:09:03.000Z</published>
    <updated>2023-06-20T19:45:19.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE整点心潮澎湃的风格！"><a href="#UE整点心潮澎湃的风格！" class="headerlink" title="UE整点心潮澎湃的风格！"></a>UE整点心潮澎湃的风格！</h1><blockquote><p>🍺看完【蜘蛛侠·纵横宇宙】的内心：真的太帅了！！！<br>🍺于是模仿一丢丢他的风格~<br>🍺火车的设计参考a站大佬lorenzo-lanfranconi，由于我改变了风格，与大佬的设计有所出入~</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p01.png" alt="p01"></p><center>【具体展示可以看我b站的视频呦~】</center><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=360096437&bvid=BV1HX4y1s7r4&cid=1170158454&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UE整点心潮澎湃的风格！&quot;&gt;&lt;a href=&quot;#UE整点心潮澎湃的风格！&quot; class=&quot;headerlink&quot; title=&quot;UE整点心潮澎湃的风格！&quot;&gt;&lt;/a&gt;UE整点心潮澎湃的风格！&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🍺看完【蜘蛛侠·纵横宇宙】的内心</summary>
      
    
    
    
    <category term="-ue" scheme="http://example.com/categories/ue/"/>
    
    
    <category term="-ue" scheme="http://example.com/tags/ue/"/>
    
  </entry>
  
  <entry>
    <title>Houdini去年（2022）的程序化生成总结~</title>
    <link href="http://example.com/2023/06/19/houdini_procedural_modeling2022/"/>
    <id>http://example.com/2023/06/19/houdini_procedural_modeling2022/</id>
    <published>2023-06-19T03:09:03.000Z</published>
    <updated>2023-07-02T17:45:40.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="😈总结一下去年（2022）的Houdini"><a href="#😈总结一下去年（2022）的Houdini" class="headerlink" title="😈总结一下去年（2022）的Houdini~"></a>😈总结一下去年（2022）的Houdini~</h1><blockquote><p>🍺最开始做Houdini程序化资产的时候还没有现在这个个人网站，于是现在填补一下发发，总结一下<br>🍺嘛~ 现在有一阵子没碰houdini了，希望最近继续富有激情的学习Houdini~</p></blockquote><ul><li>以下的Breakdown均发在bilibili了，连接也会在下面放出~ 其实都是最开始接触Houdini的时候做的，当时最感兴趣的还得是Sop模块，现在看来我做的不太好，只能说今年还会继续改进。</li><li>当然了~ 目前已经开始着手学习Houdini到UE5这一流程，请期待后续的更新！</li></ul><h2 id="👻BreakDown视频"><a href="#👻BreakDown视频" class="headerlink" title="👻BreakDown视频"></a>👻BreakDown视频</h2><blockquote><p>以下是三个Breakdown,具体放在我的Blibili了，可以点击查看~<br><a href="https://www.bilibili.com/video/BV1VT4y1B7QL/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">1.City In The Sky</a><br><a href="https://www.bilibili.com/video/BV1vW4y1U7Ly/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">2.TrainNight</a><br><a href="https://www.bilibili.com/video/BV1te411u7TE/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">3.Env</a></p></blockquote><h2 id="👻BreakDown图文"><a href="#👻BreakDown图文" class="headerlink" title="👻BreakDown图文"></a>👻BreakDown图文</h2><h3 id="City-In-the-Sky"><a href="#City-In-the-Sky" class="headerlink" title="City In the Sky"></a>City In the Sky</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_01.png" alt="Tech_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_02.png" alt="Tech_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ivyTool.gif" alt="ivyTool"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bricksGenerator.gif" alt="bricksGenerator"></p><hr><h3 id="TrainNight"><a href="#TrainNight" class="headerlink" title="TrainNight"></a>TrainNight</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_03.png" alt="Tech_03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_04.png" alt="Tech_04"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/nt-bdgenerator.gif" alt="nt-bdgenerator"></p><hr><h3 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_05.png" alt="Tech_05"></p><ul><li>详细展示可以查阅我的b站<a href="https://space.bilibili.com/552910222?spm_id_from=333.788.0.0">ZeTiiCannotStop</a>，也欢迎去b站私信我与我讨论~</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;😈总结一下去年（2022）的Houdini&quot;&gt;&lt;a href=&quot;#😈总结一下去年（2022）的Houdini&quot; class=&quot;headerlink&quot; title=&quot;😈总结一下去年（2022）的Houdini~&quot;&gt;&lt;/a&gt;😈总结一下去年（2022）的Houd</summary>
      
    
    
    
    <category term="-Houdini" scheme="http://example.com/categories/Houdini/"/>
    
    
    <category term="-procedural modeling" scheme="http://example.com/tags/procedural-modeling/"/>
    
  </entry>
  
  <entry>
    <title>2023阶段作品集</title>
    <link href="http://example.com/2023/04/28/protfolio_2023/"/>
    <id>http://example.com/2023/04/28/protfolio_2023/</id>
    <published>2023-04-28T03:09:03.000Z</published>
    <updated>2023-06-20T19:30:10.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023阶段作品集"><a href="#2023阶段作品集" class="headerlink" title="2023阶段作品集"></a>2023阶段作品集</h1><blockquote><p>🍺你好，这里是我阶段性作品的更新！今后会不断完善！<br>🍺今后会将重点放在SD，Houdini以及UE的效果上，请期待后续！<br>🍺关于所展示的效果，我大部分均在bilibili放出了分解，请前去：<a href="https://space.bilibili.com/552910222?spm_id_from=333.788.0.0">ZeTiiCannotstop的blibili</a>  来查看</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/00_cover.png" alt="00_cover"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/00_01.png" alt="00_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p01.png" alt="p01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p02.png" alt="p02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p03.png" alt="p03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p04.png" alt="p04"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p05.png" alt="p05"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p06.png" alt="p06"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p07.png" alt="p07"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p08.png" alt="p08"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p09.png" alt="p09"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p10.png" alt="p10"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p11.png" alt="p11"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p12.png" alt="p12"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023阶段作品集&quot;&gt;&lt;a href=&quot;#2023阶段作品集&quot; class=&quot;headerlink&quot; title=&quot;2023阶段作品集&quot;&gt;&lt;/a&gt;2023阶段作品集&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🍺你好，这里是我阶段性作品的更新！今后会不断完善！&lt;br</summary>
      
    
    
    
    <category term="-Protfolio" scheme="http://example.com/categories/Protfolio/"/>
    
    
    <category term="-Protfolio" scheme="http://example.com/tags/Protfolio/"/>
    
  </entry>
  
  <entry>
    <title>SD贴纸翻折效果复现</title>
    <link href="http://example.com/2023/04/23/sd_stickerRoll/"/>
    <id>http://example.com/2023/04/23/sd_stickerRoll/</id>
    <published>2023-04-23T10:32:14.000Z</published>
    <updated>2023-04-23T12:12:39.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SD贴纸翻折效果复现"><a href="#SD贴纸翻折效果复现" class="headerlink" title="SD贴纸翻折效果复现"></a><center>SD贴纸翻折效果复现</center></h1><h3 id="实现贴纸或者叶片一类的效果"><a href="#实现贴纸或者叶片一类的效果" class="headerlink" title="实现贴纸或者叶片一类的效果"></a><center>实现贴纸或者叶片一类的效果</center></h3><ul><li>先看视频链接：<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=994290041&bvid=BV1Bs4y1D7AZ&cid=1075703165&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div></li></ul><h2 id="图片示意"><a href="#图片示意" class="headerlink" title="图片示意"></a>图片示意</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP12_1.png" alt="sdTOP12_1"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_02.png" alt="st_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_03.png" alt="st_03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_04.png" alt="st_04"></p><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2023423-195718.png" alt="2023423-195718"></p><ul><li>参考哔哩哔哩大佬的方案：<strong>程序化螺丝钉</strong></li><li>主要是通过旋转角度配合位移矩阵，再配合value processsor对offset的数值进行同步处理，然后将遮罩的部分反转，将offset变换后再挪回去<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423200345.png" alt="20230423200345"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423200412.png" alt="20230423200412"></li><li>翻折的部分实际上是x到-x的变换，过渡是一个白到黑的gradient mask做出视觉上的凸起。</li><li>总体的过程只是一个视觉上的trick，还是挺奇妙的。</li><li>参数也很简单，就是翻折角度（起始点）；以及剥落的距离（offset）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423201208.png" alt="20230423201208"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423201225.png" alt="20230423201225"></li></ul><h2 id="之后对于此类效果的改进计划："><a href="#之后对于此类效果的改进计划：" class="headerlink" title="之后对于此类效果的改进计划："></a>之后对于此类效果的改进计划：</h2><ul><li>之后会完成对于position的改进，由滑杆的处理方式变为position定位点。</li><li>其次准备实现卷曲效果，像是树叶枯萎后卷起来的样子的程序化处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SD贴纸翻折效果复现&quot;&gt;&lt;a href=&quot;#SD贴纸翻折效果复现&quot; class=&quot;headerlink&quot; title=&quot;SD贴纸翻折效果复现&quot;&gt;&lt;/a&gt;&lt;center&gt;SD贴纸翻折效果复现&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;实现贴纸或者叶片一类的效果&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="-Substance Designer" scheme="http://example.com/categories/Substance-Designer/"/>
    
    
    <category term="-Substance Designer" scheme="http://example.com/tags/Substance-Designer/"/>
    
  </entry>
  
  <entry>
    <title>百人计划笔记01_1.1：图形渲染管线</title>
    <link href="http://example.com/2023/02/11/TA100_1_1_renderPipeline/"/>
    <id>http://example.com/2023/02/11/TA100_1_1_renderPipeline/</id>
    <published>2023-02-11T10:32:14.000Z</published>
    <updated>2023-02-11T14:34:46.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1：图形渲染管线-【renderPipeline】"><a href="#1-1：图形渲染管线-【renderPipeline】" class="headerlink" title="1.1：图形渲染管线 【renderPipeline】"></a>1.1：图形渲染管线 【renderPipeline】</h1><h2 id="百人计划笔记01"><a href="#百人计划笔记01" class="headerlink" title="百人计划笔记01"></a>百人计划笔记01</h2><blockquote><p>霜狼may的技术美术百人计划笔记~<br>增长知识，拓宽视野~<br>可能不是每章都会写笔记，但是会持续学习！<br>不能保证全都理解到位书写正确，有错误请及时指出！感激不尽！</p></blockquote><hr><blockquote><p>渲染管线之所以叫管线，是因为它的工作流程是线性的。<br>我们的场景是3d的，但最终的输出呈现在屏幕上是2d的，那么这就是通过渲染管线的一系列处理，把这些元素转换成屏幕上呈现的2d图像。</p></blockquote><h2 id="🍅整体流程："><a href="#🍅整体流程：" class="headerlink" title="🍅整体流程："></a>🍅整体流程：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230206234708.png" alt="20230206234708"></p><h3 id="1-🍏应用阶段"><a href="#1-🍏应用阶段" class="headerlink" title="1.🍏应用阶段"></a>1.🍏应用阶段</h3><ul><li><strong>粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段</strong></li><li><strong>应用阶段准备的是场景</strong>，对象的基本数据：比如<strong>场景里的物体</strong>，他们的位置朝向，大小，以及物体里对应的模型里面的每一个顶点位置，法线，切线等。</li><li>再比如场景<strong>光源</strong>的位置，朝向，以及基本属性； <strong>摄像机</strong>朝向，位置等</li></ul><h3 id="2-🍏几何阶段"><a href="#2-🍏几何阶段" class="headerlink" title="2.🍏几何阶段"></a>2.🍏几何阶段</h3><ul><li><strong>顶点着色器，曲面细分，几何着色器，顶点裁切，屏幕影射。</strong></li><li><strong>计算顶点光照</strong>，就需要知道光源位置朝向以及摄像机的位置以及朝向，还有当前顶点的世界位置</li><li>又需要知道顶点在模型空间的位置，以及模型本身的位置旋转缩放等。</li><li><strong>曲面细分</strong>着色器通过现有顶点来生成更多顶点，也需要知道现有顶点的在模型信息里的位置</li><li><strong>几何着色器</strong>需要通过现有的图元来做一些几何方面的操作，生成更多的顶点和图元。比如对现有图元所在的平面生成法线，同样需要知道现有图元的顶点位置。</li><li><strong>几何阶段要为光栅化阶段准备数据</strong>，比如干掉屏幕以外的顶点（<strong>顶点裁剪</strong>），还需要把顶点位置从3d坐标空间转换到2d坐标空间，这就是<strong>屏幕映射</strong></li></ul><h3 id="3-🍏光栅化阶段"><a href="#3-🍏光栅化阶段" class="headerlink" title="3.🍏光栅化阶段"></a>3.🍏光栅化阶段</h3><ul><li><strong>三角形（点、线）设置，三角形（点、线）遍历，片段着色器。</strong></li><li>拿到映射到2d空间里的顶点位置，组装成三角形，还要知道这些三角形包含了哪些2d空间的像素点。这就是<strong>三角形遍历</strong></li><li>最后对这些点使用它们包含的数据来着色，并为后面的逐片元着色准备数据</li></ul><h3 id="4-🍏逐片元操作"><a href="#4-🍏逐片元操作" class="headerlink" title="4.🍏逐片元操作"></a>4.🍏逐片元操作</h3><ul><li><strong>裁剪测试，透明度测试，深度测试，模板测试，混合。</strong></li><li>此时操作对象就变成了光栅化操作输出的<strong>片元数据</strong>，片元可以理解成屏幕上的某一个像素点，对于这些片元我们需要进行一系列的测试。</li><li><strong>测试比如</strong>：透明度，深度和模板测试。通过测试的片元就保留起来，否则就丢弃掉。</li><li>在2d屏幕坐标系当中，<strong>同一个位置上的像素点有可能会对应于多个不同的片元。</strong></li><li>那么我们可能还需要把这些通过测试的片元的颜色进行一个混合操作，从而得到像素点最终输出的颜色。</li></ul><h3 id="5-🍏后处理"><a href="#5-🍏后处理" class="headerlink" title="5.🍏后处理"></a>5.🍏后处理</h3><ul><li>逐片元操作完成后，我们就得到了一个类似于贴图的数据保存在内存里，然后可以对这个数据做一个<strong>后处理</strong>，也可以理解成图像处理。</li><li>比如：模糊，景深，高光等等</li></ul><hr><h2 id="🍅CPU与GPU："><a href="#🍅CPU与GPU：" class="headerlink" title="🍅CPU与GPU："></a>🍅CPU与GPU：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207001656.png" alt="20230207001656"></p><h3 id="1-🍏应用阶段-—-cpu"><a href="#1-🍏应用阶段-—-cpu" class="headerlink" title="1.🍏应用阶段 — cpu"></a>1.🍏应用阶段 — cpu</h3><ul><li><strong>一般是在cpu上完成的</strong>，比如说从磁盘或内存上读取模型或贴图数据，然后加载到应用程序里。</li><li>比如游戏会加载模型或者贴图，在游戏场景中，<strong>首先会做一个粗粒度剔除</strong>，被遮挡的物体就不需要显示。</li><li><strong>设置基本渲染参数和状态</strong>，比如渲染ui和渲染场景它们的渲染参数和模式可能不一样。</li><li>最后通过DrawCall将这些渲染所使用的数据传给GPU去处理</li></ul><h3 id="2-🍏几何阶段，光栅化，逐片元操作—GPU"><a href="#2-🍏几何阶段，光栅化，逐片元操作—GPU" class="headerlink" title="2.🍏几何阶段，光栅化，逐片元操作—GPU"></a>2.🍏几何阶段，光栅化，逐片元操作—GPU</h3><ul><li>这三个阶段一般会放在GPU处理，<strong>GPU的特点是并行性比较好</strong></li><li>比如说，有模型可能有很多顶点都需要做光照或者着色计算，<strong>这些顶点它们只是数据不同，但是它们的几何运算方式是相同的，那么就可以把他们分配到GPU的不同工作单元上面去同时执行，这样速度就很快。</strong></li><li>光栅化和逐片元也是同理。</li></ul><h2 id="🍅每个阶段做的事情："><a href="#🍅每个阶段做的事情：" class="headerlink" title="🍅每个阶段做的事情："></a>🍅每个阶段做的事情：</h2><h3 id="1-🍏应用阶段-1"><a href="#1-🍏应用阶段-1" class="headerlink" title="1.🍏应用阶段"></a>1.🍏应用阶段</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207003342.png" alt="20230207003342"></p><ol><li><strong>准备场景数据</strong>，摄像机数据，光源&#x2F;阴影数据，全局数据。</li><li>准备好数据后，<strong>需要做一些优化</strong>，比如算法加速，干掉看不到不需要渲染的物体，做一些剔除</li><li><strong>设置渲染状态</strong>，准备渲染参数。比如由远到进渲染，还是不透明先渲染再渲染半透明，这个就是<strong>绘制顺序</strong>。对于不同的物体使用不同的shader渲染，以及输出渲染结果到什么地方，是renderTexture还是FrameBuffer，这是<strong>渲染目标</strong>。<strong>渲染模式</strong>，比如成像渲染或者延迟渲染等等。</li><li>最后设置好渲染状态和参数后，我们就会调用DrawCall，把大有渲染数据的图元输出到显存去交给GPU处理。</li></ol><h4 id="🍇基本场景数据："><a href="#🍇基本场景数据：" class="headerlink" title="🍇基本场景数据："></a>🍇基本场景数据：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207004145.png" alt="20230207004145"></p><h4 id="🍇光源和阴影："><a href="#🍇光源和阴影：" class="headerlink" title="🍇光源和阴影："></a>🍇光源和阴影：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223110.png" alt="20230207223110"></p><h4 id="🍇加速算法，粗颗粒剔除："><a href="#🍇加速算法，粗颗粒剔除：" class="headerlink" title="🍇加速算法，粗颗粒剔除："></a>🍇加速算法，粗颗粒剔除：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223310.png" alt="20230207223310"></p><ul><li>摄像机视锥之外的物体是可以裁切掉的，比如判断是否在视锥内，或者与视锥是否相交。</li><li>被遮挡的物体也可以剔除掉。</li></ul><h4 id="🍇渲染设置："><a href="#🍇渲染设置：" class="headerlink" title="🍇渲染设置："></a>🍇渲染设置：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223509.png" alt="20230207223509"></p><ul><li>对于不同对象使用一些合批方式，比如GPU instance或者动态批处理等等</li></ul><h4 id="🍇输出到显存："><a href="#🍇输出到显存：" class="headerlink" title="🍇输出到显存："></a>🍇输出到显存：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223855.png" alt="20230207223855"></p><h3 id="2-🍏几何阶段："><a href="#2-🍏几何阶段：" class="headerlink" title="2.🍏几何阶段："></a>2.🍏几何阶段：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207224049.png" alt="20230207224049"></p><h4 id="🍇顶点着色器-视图变换"><a href="#🍇顶点着色器-视图变换" class="headerlink" title="🍇顶点着色器-视图变换"></a>🍇顶点着色器-视图变换</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207225721.png" alt="20230207225721"></p><ul><li><strong>对顶点做坐标系的变换，还会对他进行一定的着色操作</strong></li><li>投影变换：（为了最后做3d到2d的投影操作做准备）<ul><li>1.正交，远近一样大</li><li>2.透视，近大远小</li><li>同时投影还有一个裁剪的作用，确定该顶点是不是在视锥的远近左右上下包围平面之内</li></ul></li></ul><p>-<strong>mvp矩阵：</strong></p><ul><li><strong>Model</strong>：模型变换，施加在模型上的空间变换，包含平移变换（translateM）、旋转变换（rotateM）、对称变换（transposeM）、缩放变换（scaleM</li><li><strong>View</strong>：观测变换，施加在观测点上的变换，用于调整观测点位置、观测朝向、观测正方向；</li><li><strong>Projection</strong>：透视变换，施加在视觉上的变换，用于调整模型的透视效果（如：矩形的透视效果是梯形）。</li></ul><p>-顶点着色器还有一个作用是计算顶点光照</p><h4 id="🍇曲面细分（可选步骤）"><a href="#🍇曲面细分（可选步骤）" class="headerlink" title="🍇曲面细分（可选步骤）"></a>🍇曲面细分（可选步骤）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231217.png" alt="20230207231217"></p><ul><li>按照算法生成更多顶点</li></ul><h4 id="🍇几何着色器（可选步骤，基于图元的操作）"><a href="#🍇几何着色器（可选步骤，基于图元的操作）" class="headerlink" title="🍇几何着色器（可选步骤，基于图元的操作）"></a>🍇几何着色器（可选步骤，基于图元的操作）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231347.png" alt="20230207231347"></p><ul><li><strong>顶点着色器操作的对象是单个顶点，而几何着色器操作对象是一个图元；</strong></li><li>这个图元可能是一个顶点，也可能是一个线段，两个顶点，也有可能是多个顶点构成的连续线段，也有可能是三个顶点构成的三角形，或者其他。</li><li>它的作用是通过给定图元去生成更多图元</li></ul><h4 id="🍇投影"><a href="#🍇投影" class="headerlink" title="🍇投影"></a>🍇投影</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231658.png" alt="20230207231658"></p><ul><li><p>前面的步骤都是3d空间的，那么把3d空间转换到2d屏幕的转换过程，就是<strong>投影的步骤</strong></p></li><li><p>顶点在裁剪空间的位置，xyzw会对它进行一个透视除法，把xyz除以w来完成投影操作。</p></li><li><p>这样就从投影坐标系转换到了标准设备坐标系，也就是NDC(<strong>Normalized Device Coordinates</strong>, NDC)</p><ul><li>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃&#x2F;裁剪，不会显示在你的屏幕上。</li></ul></li><li><p><strong>正交投影上</strong>，w始终为1，所以不管在投影空间中的任意位置，xyz除以w都不会发生变换。</p></li><li><p><strong>透视模式中</strong>，w是近处比较小，远处比较大，所以说对于近处远处的点，它们xyz除以w，投影到2d平面上就会呈现出近大远小的效果</p></li></ul><h4 id="🍇裁剪"><a href="#🍇裁剪" class="headerlink" title="🍇裁剪"></a>🍇裁剪</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207233402.png" alt="20230207233402"></p><ul><li>转换后如果xyz 超过-1~1的范围，则会被剔除（处于裁剪空间外）</li><li>在Open GL中，xyz三个维度都是从-1~1.</li><li>而D3D当中只有xy两个维度是从-1<del>1，z则是从0</del>1</li></ul><h4 id="🍇屏幕映射"><a href="#🍇屏幕映射" class="headerlink" title="🍇屏幕映射"></a>🍇屏幕映射</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207233925.png" alt="20230207233925"></p><ul><li>屏幕是输出设备的长宽，所以这里也有一个映射过程。</li><li>OpenGl和D3D的屏幕坐标系原点也不一样<ul><li>OpenGl的原点在左下方</li><li>D3D原点在左上方</li></ul></li></ul><h3 id="2-🍏光栅化阶段："><a href="#2-🍏光栅化阶段：" class="headerlink" title="2.🍏光栅化阶段："></a>2.🍏光栅化阶段：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234142.png" alt="20230207234142"></p><h4 id="🍇三角形设置"><a href="#🍇三角形设置" class="headerlink" title="🍇三角形设置"></a>🍇三角形设置</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234220.png" alt="20230207234220"></p><ul><li>知道这个图元的边界信息，而计算这个边界信息的过程就是三角形设置。然后就可以知道它覆盖的屏幕像素</li></ul><h4 id="🍇三角形遍历"><a href="#🍇三角形遍历" class="headerlink" title="🍇三角形遍历"></a>🍇三角形遍历</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234856.png" alt="20230207234856"></p><ul><li>检查这些像素是否被三角形覆盖，如果被覆盖就说明这个片元属于这个三角形。</li><li>这种寻找被三角形网格所覆盖的所有像素的过程就叫做三角形遍历</li><li>得到被三角形所覆盖的所有像素后，会使用三角形的三个顶点，对每一个被覆盖的对象进行线性插值，然后得到当前三角形在像素对应片元的数据。</li><li>所以这里得到的片元并不等同于是像素。</li></ul><h4 id="🍇抗锯齿（MSAA）"><a href="#🍇抗锯齿（MSAA）" class="headerlink" title="🍇抗锯齿（MSAA）"></a>🍇抗锯齿（MSAA）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207235306.png" alt="20230207235306"></p><ul><li>MSAA使用子采样点对三角形进行覆盖测试，看这个子采样点深度缓存里面的数值进行比较，看是否通过。</li></ul><h3 id="🍏逐片元操作"><a href="#🍏逐片元操作" class="headerlink" title="🍏逐片元操作"></a>🍏逐片元操作</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208000014.png" alt="20230208000014"></p><ul><li>对通过的片元，我们需要用什么方式混合，最终输出到一个像素；这一步是可以配置的</li><li>然后将他们输出到目标缓冲区</li></ul><h4 id="🍇片元着色"><a href="#🍇片元着色" class="headerlink" title="🍇片元着色"></a>🍇片元着色</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208000549.png" alt="20230208000549"></p><ul><li>对于一个三角形所覆盖的片元，会使用三个顶点数据，对其进行线性插值。</li><li>如p点就是三个顶点进行线性插值的结果。我们还可以得到其他如UV信息，深度信息等数据</li><li>然后再用片元数据和其他全局数据，比如光照阴影时间等等去计算，得到最终的片元颜色</li></ul><h4 id="🍇颜色混合，透明度测试"><a href="#🍇颜色混合，透明度测试" class="headerlink" title="🍇颜色混合，透明度测试"></a>🍇颜色混合，透明度测试</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208001154.png" alt="20230208001154"></p><h4 id="🍇颜色混合-深度测试、模板测试"><a href="#🍇颜色混合-深度测试、模板测试" class="headerlink" title="🍇颜色混合-深度测试、模板测试"></a>🍇颜色混合-深度测试、模板测试</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208001351.png" alt="20230208001351"></p><ul><li><strong>深度测试</strong>的测试对象就是片元的深度值，把片元深度值和对应的深度缓冲当中的深度值去比较，通过比较的会保留下来</li><li><strong>模板测试</strong>比较模板值，我们希望对两个立方体进行描边，不希望任何一个立方体描边挡住其他的立方体，那么我们可以将两个立方体的顶点放大一点，并且将它绘制成描边的颜色。</li><li>然后我们进行真实立方体绘制的时候，我们会把立方体的模板值和之前描边颜色的模板值比较；模板值是描边模板值的，我们把它覆盖掉，这样就可以实现立方体永远在描边之上。</li><li>这个比较方式也可以配置，可以是小于通过也可以是大于通过，也可以是等于通过。</li></ul><h4 id="🍇混合"><a href="#🍇混合" class="headerlink" title="🍇混合"></a>🍇混合</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208002257.png" alt="20230208002257"></p><ul><li>逐片元最后一个操作</li><li></li></ul><h3 id="🍏后处理"><a href="#🍏后处理" class="headerlink" title="🍏后处理"></a>🍏后处理</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208002742.png" alt="20230208002742"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1：图形渲染管线-【renderPipeline】&quot;&gt;&lt;a href=&quot;#1-1：图形渲染管线-【renderPipeline】&quot; class=&quot;headerlink&quot; title=&quot;1.1：图形渲染管线 【renderPipeline】&quot;&gt;&lt;/a&gt;1.1：图</summary>
      
    
    
    
    <category term="-TA100" scheme="http://example.com/categories/TA100/"/>
    
    
    <category term="-技术美术百人计划" scheme="http://example.com/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2022/11月-2023/1月 SD练习</title>
    <link href="http://example.com/2023/01/18/sd_practice001/"/>
    <id>http://example.com/2023/01/18/sd_practice001/</id>
    <published>2023-01-18T10:32:14.000Z</published>
    <updated>2023-01-18T16:08:26.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-x2F-11月-2023-x2F-1月-SD练习"><a href="#2022-x2F-11月-2023-x2F-1月-SD练习" class="headerlink" title="2022&#x2F;11月-2023&#x2F;1月 SD练习"></a>2022&#x2F;11月-2023&#x2F;1月 SD练习</h1><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP3.png" alt="sdTOP3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP3_1.png" alt="sdTOP3_1"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render.png" alt="wood_paint_peeling_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render2.png" alt="wood_paint_peeling_render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render3.png" alt="wood_paint_peeling_render3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/tarmac_worn_roadMark_render.png" alt="tarmac_worn_roadMark_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/tarmac_worn_roadMark_render2.png" alt="tarmac_worn_roadMark_render2"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP5.png" alt="sdTOP5"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches04_render_NObg3.png" alt="patches04_render_NObg3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches05_render.png" alt="patches05_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches01_render.png" alt="patches01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches03_render.png" alt="patches03_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches04_render.png" alt="patches04_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches02_render.png" alt="patches02_render"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP6.png" alt="sdTOP6"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ji.png" alt="ji"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lowlow.png" alt="lowlow"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTop_sand.png" alt="sdTop_sand"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_realistic001_render.png" alt="sand_realistic001_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_realistic001_render2.png" alt="sand_realistic001_render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_stylized001_render.png" alt="sand_stylized001_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_stylized002_render.png" alt="sand_stylized002_render"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP4.png" alt="sdTOP4"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_patterns_stylized01_render.png" alt="wood_patterns_stylized01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_woodPlanks01_render.png" alt="Ground_woodPlanks01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_wall_mix01_render.png" alt="WOOD_wall_mix01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_pattern02_render.png" alt="WOOD_pattern02_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards001_scrachesPeeling_old_Render.png" alt="woodBoards001_scrachesPeeling_old_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards001_scrachesPeeling_old_Render2.png" alt="woodBoards001_scrachesPeeling_old_Render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards002_horizontalBoards_colorMix_Render.png" alt="woodBoards002_horizontalBoards_colorMix_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_board002_hotizontal_render.png" alt="WOOD_board002_hotizontal_render"></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/top.png" alt="top"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile2_render.png" alt="Ground_Tile2_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile0_render.png" alt="Ground_Tile0_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Bricks_Tile01_render.png" alt="Bricks_Tile01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile1_render.png" alt="Ground_Tile1_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metalPlates001_rustPeeling_Render.png" alt="metalPlates001_rustPeeling_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metalPlates001_rustPeeling_Render2.png" alt="metalPlates001_rustPeeling_Render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wall_smooth_render.png" alt="wall_smooth_render"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-x2F-11月-2023-x2F-1月-SD练习&quot;&gt;&lt;a href=&quot;#2022-x2F-11月-2023-x2F-1月-SD练习&quot; class=&quot;headerlink&quot; title=&quot;2022&amp;#x2F;11月-2023&amp;#x2F;1月 SD练习&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="-Substance Designer" scheme="http://example.com/categories/Substance-Designer/"/>
    
    
    <category term="-Substance Designer" scheme="http://example.com/tags/Substance-Designer/"/>
    
  </entry>
  
  <entry>
    <title>【Select Tool 使用文档】 （测试在线文档）</title>
    <link href="http://example.com/2023/01/06/TAcourse_week06_selectTool_helpDoc/"/>
    <id>http://example.com/2023/01/06/TAcourse_week06_selectTool_helpDoc/</id>
    <published>2023-01-06T07:32:14.000Z</published>
    <updated>2023-01-06T08:33:14.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Select-Tool-使用文档】-（测试在线文档）"><a href="#【Select-Tool-使用文档】-（测试在线文档）" class="headerlink" title="【Select Tool 使用文档】 （测试在线文档）"></a><center>【Select Tool 使用文档】 （测试在线文档）</center></h1><h2 id="🐢工具介绍"><a href="#🐢工具介绍" class="headerlink" title="🐢工具介绍"></a>🐢工具介绍</h2><blockquote><p>✨此工具用于选择不同类型的模型<br>✨按键之间都是独立的，不会混合选择的类型<br>✨被选中的模型会在工具中显示出来</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155106.png" alt="20230106155106"></p><hr><hr><h2 id="🐢使用指南"><a href="#🐢使用指南" class="headerlink" title="🐢使用指南"></a>🐢使用指南</h2><blockquote><p>🌻选择polymeshes如下图：  </p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155132.png" alt="20230106155132"></p><hr><blockquote><p>🌻选择Nurbs Meshes如下图： </p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155358.png" alt="20230106155358"></p><hr><blockquote><p>🌻选择Curves如下图：</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155500.png" alt="20230106155500"></p><hr><blockquote><p>☃️若场景中没有此类选择的物体，会提示：Zero object of this type!</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155847.png" alt="20230106155847"></p><hr><blockquote><p>☃️将鼠标悬停在按钮上会有功能的相应提示</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106161621.png" alt="20230106161621"></p><hr><blockquote><p>☃️下拉help菜单可以阅读此工具的帮助文档（也就是这篇）</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106161816.png" alt="20230106161816"></p><blockquote><p>🐨以上就是select tool的介绍！<br>🐨此文档目前只用于托管在线文档测试！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Select-Tool-使用文档】-（测试在线文档）&quot;&gt;&lt;a href=&quot;#【Select-Tool-使用文档】-（测试在线文档）&quot; class=&quot;headerlink&quot; title=&quot;【Select Tool 使用文档】 （测试在线文档）&quot;&gt;&lt;/a&gt;&lt;cent</summary>
      
    
    
    
    <category term="-Help Doc" scheme="http://example.com/categories/Help-Doc/"/>
    
    
    <category term="-Help Doc" scheme="http://example.com/tags/Help-Doc/"/>
    
  </entry>
  
  <entry>
    <title>Substance Designer这一阵子的练习汇总（一）</title>
    <link href="http://example.com/2022/12/10/sd_sdPractice_woodPeeling/"/>
    <id>http://example.com/2022/12/10/sd_sdPractice_woodPeeling/</id>
    <published>2022-12-10T10:32:14.000Z</published>
    <updated>2023-04-23T12:21:40.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这里是关于SD生成器的"><a href="#这里是关于SD生成器的" class="headerlink" title="这里是关于SD生成器的"></a><center>这里是关于SD生成器的</center></h1><h3 id="木漆剥落生成器以及水彩笔触生成器"><a href="#木漆剥落生成器以及水彩笔触生成器" class="headerlink" title="木漆剥落生成器以及水彩笔触生成器"></a><center>木漆剥落生成器以及水彩笔触生成器</center></h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=390513592&bvid=BV1vd4y1t7Ca&cid=902733440&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这里是关于SD生成器的&quot;&gt;&lt;a href=&quot;#这里是关于SD生成器的&quot; class=&quot;headerlink&quot; title=&quot;这里是关于SD生成器的&quot;&gt;&lt;/a&gt;&lt;center&gt;这里是关于SD生成器的&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;木漆剥落生成器以及水彩笔</summary>
      
    
    
    
    <category term="-Substance Designer" scheme="http://example.com/categories/Substance-Designer/"/>
    
    
    <category term="-Substance Designer" scheme="http://example.com/tags/Substance-Designer/"/>
    
  </entry>
  
  <entry>
    <title>UE_Lighting Type</title>
    <link href="http://example.com/2022/11/03/ue_LightingType/"/>
    <id>http://example.com/2022/11/03/ue_LightingType/</id>
    <published>2022-11-03T02:33:33.000Z</published>
    <updated>2022-11-03T07:56:51.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4-虚幻引擎基础照明-灯光类型"><a href="#UE4-虚幻引擎基础照明-灯光类型" class="headerlink" title="UE4_虚幻引擎基础照明_灯光类型"></a>UE4_虚幻引擎基础照明_灯光类型</h1><blockquote><p>🍉本学习笔记是对UE灯光基础类型的理解，特此做记录，大佬自行跳过哈！</p></blockquote><hr><h2 id="✏️场景照明基础设置："><a href="#✏️场景照明基础设置：" class="headerlink" title="✏️场景照明基础设置："></a>✏️场景照明基础设置：</h2><ol><li><strong>Sky Light</strong>（提供间接照明）</li><li><strong>Directional Light</strong>（提供直接照明和光源方向）</li><li><strong>Point Lights</strong>（点光源）</li><li><strong>Spot Light</strong> （聚光灯）</li><li><strong>Rect Light</strong> （面光源）</li></ol><ul><li>以上提到的就是最常见的灯光，下面会介绍以上灯光几个常用属性便于打光时进行一个较为基础的设置。</li></ul><hr><h3 id="✍️使用【Directional-Light】需要注意的设置有如下几点："><a href="#✍️使用【Directional-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Directional Light】需要注意的设置有如下几点："></a>✍️使用【Directional Light】需要注意的设置有如下几点：</h3><ol><li><p><strong>【Mobility】</strong></p><ul><li><strong>static</strong>（静止），灯光全部会被烘培，纯静态光源，非实时，消耗最低，游戏中无法改变光源。</li><li><strong>stationary</strong>（静态），只烘培静态几何体的投影和反射光找，其他则为动态光源，此设置还允许光源在游戏中改变颜色和强度，但其并不会移动，且允许部分烘焙光照。</li><li><strong>movable</strong>（可移动），纯动态光源，可实时移动并动态投射阴影，消耗最多，拥有最高灵活性。</li></ul></li><li><p><strong>【Light】</strong></p></li></ol><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/directionalLight_Light.png" alt="directionalLight_Light"></p><ul><li><strong>Intensity</strong>，光照强度，场景光照量的多少</li><li><strong>Light color&#x2F; temperature</strong>，光照颜色，最好使用Temperature（开尔文）以取得真实的照明效果</li><li><strong>source angle&#x2F;source soft angle</strong>，针对柔化阴影</li><li><strong>affects world</strong>，开启或关闭灯光的影响</li><li><strong>cast shadows</strong>，是否投射阴影</li><li><strong>indirect lighting Intensity</strong>，如果将此提高，则此灯光再其中贡献更多的照明效果，可用于在阴影区域获得更多的反射光。</li></ul><hr><h3 id="✍️使用【Sky-Light】需要注意的设置有如下几点："><a href="#✍️使用【Sky-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Sky Light】需要注意的设置有如下几点："></a>✍️使用【Sky Light】需要注意的设置有如下几点：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SkyLight_Light.png" alt="SkyLight_Light"></p><ol><li><strong>【Cube Map】</strong><ul><li>帮助投射颜色</li><li>通常我们不会在这种类似HDR的照明下更改过多的灯光设置，所以尽量保持默认就可以。</li></ul></li></ol><hr><h3 id="✍️使用【Point-Light】需要注意的设置有如下几点："><a href="#✍️使用【Point-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Point Light】需要注意的设置有如下几点："></a>✍️使用【Point Light】需要注意的设置有如下几点：</h3><ul><li>是最常使用的灯光，点光源，大部分命名相同的属性与directional Light相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/spotLight_Light.png" alt="pointLight_Light"><ul><li><strong>Attenuation Radius</strong>，衰减半径，可以理解是光照的距离或光照影响的半径，越大越远。</li><li><strong>source Radius</strong>，灯光半径，可以场景光中得到一些更柔和的灯光阴影，也有助于灯光获取更多信息，默认0的时候是一个很小的光源点。</li><li><strong>source Length</strong>，灯光长度，通常与source radius一起使用，在不想增加衰减半径的情况下，可以通过source Length来调整灯光影响的范围，看起来更加自然。</li><li><strong>use Inverse Squared Falloff</strong>，是否使用反比平方比。这是灯光的一种算法，是一种不同类型的光源衰减，主要是用来复制真实世界中的光源行为。它会让光照在靠近其源时非常亮，而在远离源时很快就变暗。</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Lighting_4_2.jpg" alt="反比平方比"></p><h4 id="反比平方比的理解："><a href="#反比平方比的理解：" class="headerlink" title="反比平方比的理解："></a>反比平方比的理解：</h4><ul><li><p>使用平方反比衰减同时会改变光源的根本行为。首先，亮度从任意值变更为在 流明 中进行计算。这表示使用指数衰减（默认）的亮度为3的光源看起来是亮的，但如果您将其切换到平方反比衰减，光源仅有3流明，这时光源基本上看不见。</p></li><li><p>光源半径在使用平方反比衰减时也会改变。在使用默认的指数衰减时，半径可视为光源运动的范围，同时越接近半径范围，光照越会衰减。在使用平方反比衰减时，半径更像是一个限定值，对于衰减发生的实际范围不会产生影响。这表示您 可以 为获得最为真实的光源衰减而把半径值设置得非常高。但是，考虑到重叠的固定光源问题，一般情况下不要这样操作。</p></li></ul><hr><h3 id="✍️使用【Spot-Light】需要注意的设置有如下几点："><a href="#✍️使用【Spot-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Spot Light】需要注意的设置有如下几点："></a>✍️使用【Spot Light】需要注意的设置有如下几点：</h3><ul><li>实际上设置与点光源很相似，也是常用照明形式，是锥形的聚光灯投射形式。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/spotLights_Light.png" alt="spotLights_Light"></li><li><strong>inner cone angle&#x2F;outter cone angle</strong>，内外半径</li><li>其余大致设置与point light相似</li></ul><hr><h3 id="✍️使用【Rect-Light】需要注意的设置有如下几点："><a href="#✍️使用【Rect-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Rect Light】需要注意的设置有如下几点："></a>✍️使用【Rect Light】需要注意的设置有如下几点：</h3><ul><li>有点像从一个实际的矩形散发出来的光，起着光源作用。</li><li>它在性能方面消耗较多，需要谨慎使用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RectLight_Light.png" alt="RectLight_Light"></li><li><strong>source Width&#x2F;source Height</strong>, 光源的长宽，注意如果直接缩放灯光其实是不会对灯光大小范围产生变化的，此时就需要设置灯光属性中的长宽。</li><li>其他设置与其他光源没有不同。</li></ul><hr><h2 id="✏️灯光优化："><a href="#✏️灯光优化：" class="headerlink" title="✏️灯光优化："></a>✏️灯光优化：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/UEviewMode.png" alt="UEviewMode"></p><ul><li>可以去带viewport中<strong>Detail Lighting</strong>的模式下进行灯光的调试，此模式不带材质的颜色信息，材质均会显示50%的灰度，但是依旧能看见法线以及粗糙度。这一模式可以帮助准确的查看灯光的颜色和强度。</li><li><strong>Light complexity</strong> 可以看见灯光的复合程度，从蓝到绿到红到白的这样一种变化，这是性能的可视化表现，其中消耗最高的是白色，以此类推。</li><li><strong>stationary Light overLap</strong>，此模式可以看清场景内使用stationary light投射出的动态阴影，但是它对于重叠的灯光范围（灯光半径相交的部分）有限制，最多使用四盏overlapping stationary lights。太多的灯光重叠，引擎会只计算那些有效的部分并且踢掉其中的一些多的。</li><li>使用starter content中的<strong>color calibrator</strong>来检查场景内光源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UE4-虚幻引擎基础照明-灯光类型&quot;&gt;&lt;a href=&quot;#UE4-虚幻引擎基础照明-灯光类型&quot; class=&quot;headerlink&quot; title=&quot;UE4_虚幻引擎基础照明_灯光类型&quot;&gt;&lt;/a&gt;UE4_虚幻引擎基础照明_灯光类型&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="-UE4" scheme="http://example.com/categories/UE4/"/>
    
    
    <category term="-灯光" scheme="http://example.com/tags/%E7%81%AF%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>UE4_虚幻引擎材质节点以及蓝图的学习</title>
    <link href="http://example.com/2022/10/14/ue_WTF_is_Material_all/"/>
    <id>http://example.com/2022/10/14/ue_WTF_is_Material_all/</id>
    <published>2022-10-14T10:32:14.000Z</published>
    <updated>2022-10-20T08:16:58.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4-虚幻引擎材质节点以及蓝图的学习"><a href="#UE4-虚幻引擎材质节点以及蓝图的学习" class="headerlink" title="UE4_虚幻引擎材质节点以及蓝图的学习"></a>UE4_虚幻引擎材质节点以及蓝图的学习</h1><blockquote><p>🍉本笔记是我的UE材质节点学习笔记，随手写一下，我是菜鸡的水平，如果很厉害的大佬就可以跳过了哈！如有错误请及时指正！<br>🤩学习主要来自WTF is Material的章节，也就是来自Mathew Wadstein的tutorials~~~ 请有兴趣就去关注原作者！<br>🍅还有一些杂七杂八的从各种地方学的我应该会一同写在一起了，大部分也去ue的document查了一圈，拿了一些示例。我正在学习ue的路上，这个系列应该会持续更，有兴趣的想要一起学习的也可以关注我的更新！</p></blockquote><hr><h2 id="✏️材质节点键盘快捷键不全的大全："><a href="#✏️材质节点键盘快捷键不全的大全：" class="headerlink" title="✏️材质节点键盘快捷键不全的大全："></a>✏️材质节点键盘快捷键不全的大全：</h2><table><thead><tr><th>快捷键</th><th>Node Name</th><th>中文</th></tr></thead><tbody><tr><td>1</td><td>constant</td><td>一维向量</td></tr><tr><td>2</td><td>constant2Vector</td><td>二维向量</td></tr><tr><td>3</td><td>constant3Vector</td><td>三维向量</td></tr><tr><td>4</td><td>constant4Vector</td><td>四维向量</td></tr><tr><td>A</td><td>Add</td><td>加法</td></tr><tr><td>M</td><td>multiply</td><td>混合，乘法</td></tr><tr><td>D</td><td>divide</td><td>除法</td></tr><tr><td>T</td><td>TextureSample</td><td>纹理贴图</td></tr><tr><td>P</td><td>Panner</td><td>坐标平移</td></tr><tr><td>U</td><td>TextureCoordinate</td><td>纹理坐标</td></tr><tr><td>L</td><td>Lerp</td><td>插值函数</td></tr><tr><td>I</td><td>if</td><td>参数判断</td></tr><tr><td>C</td><td>comment</td><td>备注说明</td></tr><tr><td>B</td><td>BumpOffset</td><td>视差贴图</td></tr><tr><td>N</td><td>Normalize</td><td>归一化函数</td></tr><tr><td>E</td><td>power</td><td>幂</td></tr><tr><td>O</td><td>one-minus</td><td>反向，反向颜色</td></tr></tbody></table><hr><h2 id="✏️官方操作快捷键："><a href="#✏️官方操作快捷键：" class="headerlink" title="✏️官方操作快捷键："></a>✏️官方操作快捷键：</h2><ul><li>图来自网络<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/hotKey_ue.png" alt="hotKey_ue"></li></ul><hr><h2 id="✏️Actor-Position-WS（vectors）"><a href="#✏️Actor-Position-WS（vectors）" class="headerlink" title="✏️Actor Position WS（vectors）"></a>✏️Actor Position WS（vectors）</h2><h3 id="🍏【ActorPosition】："><a href="#🍏【ActorPosition】：" class="headerlink" title="🍏【ActorPosition】："></a>🍏【ActorPosition】：</h3><blockquote><p>对象坐标值，输出的是vector3，指这个actor在世界空间中的位置（已经赋予此材质的对象）。它的整体变化是以actor的坐标为基准。</p></blockquote><ul><li>下图是<strong>actorPosition</strong>的示例，图来自于YakSue的CSDN博客，<a href="https://yaksue.blog.csdn.net/article/details/110431700?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110431700-blog-104868601.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110431700-blog-104868601.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1">链接在此</a>。（如侵权请联系删除）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/actorPosition.gif" alt="actorPosition"></li></ul><h3 id="🍏【Object-Position】："><a href="#🍏【Object-Position】：" class="headerlink" title="🍏【Object Position】："></a>🍏【Object Position】：</h3><blockquote><p>与他比较相似的是 Object Position，输出对象bound的世界场景空间<strong>中心</strong>位置。它的变化则是以整体中心为基准。</p></blockquote><ul><li>下图是<strong>Object Position</strong>的示例，图来自于YakSue的CSDN博客。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/objectPosition.gif" alt="objectPosition"></li></ul><h3 id="🍏【Absolute-World-Position】："><a href="#🍏【Absolute-World-Position】：" class="headerlink" title="🍏【Absolute World Position】："></a>🍏【Absolute World Position】：</h3><blockquote><p>Absolute World Position，表示在全局空间中的位置。</p></blockquote><ul><li>下图是<strong>Absolute World Position</strong>的示例，图来自于YakSue的CSDN博客。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/AbsoluteWorldPosition.gif" alt="AbsoluteWorldPosition"></li></ul><hr><h2 id="✏️Add（math）"><a href="#✏️Add（math）" class="headerlink" title="✏️Add（math）"></a>✏️Add（math）</h2><blockquote><p>加法，常用于颜色亮暗的调节，或者使用于offset。 </p></blockquote><ul><li>他所做的事情和数学一样，就是获取两个input并把他们values相加。如果使用多个通道传递，则每个通道分别相加。- 两个input的如果是多通道，那么通道必须数量相同；但是如给其中一个是单值常量则例外，单值浮点会与多通道每个通道相加并输出。</li></ul><hr><h2 id="✏️AppendVector（math）"><a href="#✏️AppendVector（math）" class="headerlink" title="✏️AppendVector（math）"></a>✏️AppendVector（math）</h2><blockquote><p>二维加法，将一个值加入（插入）到另一个值后端。允许你组合通道，比如你有一个二维向量，你可以通过append加入第三个向量。</p></blockquote><ul><li>要注意它和add是完全不同的，它并不是数值上的相加。</li></ul><hr><h2 id="✏️Abs（math）"><a href="#✏️Abs（math）" class="headerlink" title="✏️Abs（math）"></a>✏️Abs（math）</h2><blockquote><p>absolute value，绝对值；它没有参数，但是涵盖一个很简单的函数。这个函数是取input的绝对值。这意味着它通过去掉负号把负数变成正数，而正数和零保持不变</p></blockquote><ul><li>这个函数意味着它的output是没有负数的，大多数情况下使用于不想取到负值的情况下，将output的区间钳制在正数区间。</li><li>一般配合点积使用，确定两个向量之间的角度关系，计算它是平行，垂直，还是介于两者之间。通常，当您得到两个向量的点积时，该值在1.0（对于两个平行向量）与-1.0（对于两个完全相反的向量）之间进行插值，中间点0表示这两个向量是垂直的。当您取这个点积的绝对值时，正值保持不变，而负值通过去掉负号变成正数。因此，结果在0（对于垂直向量）和1.0（对于平行向量，无论向量指向相同还是相反的方向）之间进行插值。这只是告诉您这两个向量距离正交有多远。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/abs.jpg" alt="abs"></li></ul><hr><h2 id="✏️BlackBody（utility）"><a href="#✏️BlackBody（utility）" class="headerlink" title="✏️BlackBody（utility）"></a>✏️BlackBody（utility）</h2><blockquote><p>黑体，用来在材质中模拟黑体辐射，运用开尔文温度，产生颜色和轻度来驱动basecolor和emissive，获得物理上准确的结果</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/BlackBody.jpg" alt="BlackBody"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%BC%80%E5%B0%94%E6%96%87%E9%A2%9C%E8%89%B2.png" alt="开尔文颜色"></p><hr><h2 id="✏️BumpOffset（function）"><a href="#✏️BumpOffset（function）" class="headerlink" title="✏️BumpOffset（function）"></a>✏️BumpOffset（function）</h2><blockquote><p>高度视差，就是所谓的视差贴图。凹凸贴图偏移表达式可以使材质产生深度错觉，而不需要额外的几何体。凹凸贴图偏移材质使用灰阶高度贴图来提供深度信息。</p></blockquote><ul><li>它有三个input：<ul><li>coordinate</li><li>height（一般情况下这个通道是必须的，需要一张灰度图，越黑代表距离越远，越白距离越近。）</li><li>heightRatioInput（这个建议较小的数值，否则扭曲和拉伸会较为严重）</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/BumpOffset.png" alt="BumpOffset"></p><hr><h2 id="✏️Camera-Position-WS（vectors）"><a href="#✏️Camera-Position-WS（vectors）" class="headerlink" title="✏️Camera Position WS（vectors）"></a>✏️Camera Position WS（vectors）</h2><blockquote><p>相机坐标值，会输出一个三通道向量值，该值表示摄像机在世界场景空间中的位置.</p></blockquote><ul><li>看如下案例，相机位置如果高于物体位置，呈现白色；如果低于物体位置，呈现黑色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cameraPosition.png" alt="cameraPosition"></li></ul><hr><h2 id="✏️Clamp（math）"><a href="#✏️Clamp（math）" class="headerlink" title="✏️Clamp（math）"></a>✏️Clamp（math）</h2><blockquote><p>范围限定；接受一个或多个值，并将它们约束到由最小值和最大值定义的指定范围内。如果最小值为0.0，最大值为0.5，则意味着结果值永远不会小于0.0，且永远不会大于0.5。</p></blockquote><ul><li>有三个input<ul><li>clamp mode（可以设定只有 max或只有 min）</li><li>Min Default</li><li>Max Default</li></ul></li><li>它保证数值不会大于你自定义的max，也不会小于你自定义的min。</li></ul><hr><h2 id="✏️Component-Mask（math）"><a href="#✏️Component-Mask（math）" class="headerlink" title="✏️Component Mask（math）"></a>✏️Component Mask（math）</h2><blockquote><p>相当于参数提取，它允许你从输入中挑选某个通道子集（R、G、B和&#x2F;或A）并输出。</p></blockquote><ul><li>下图示例： 如果ComponentMask的输入是(0.2,0.4,1.0)和G通道，输出将是(0.4)。如果是颜色向量，最终效果就是一个40%的明亮灰度值。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ComponentMaskExample.jpg" alt="ComponentMaskExample"></li></ul><hr><h2 id="✏️Constant-Bias-Scale（math）"><a href="#✏️Constant-Bias-Scale（math）" class="headerlink" title="✏️Constant Bias Scale（math）"></a>✏️Constant Bias Scale（math）</h2><blockquote><p>允许你按比例调整参数，它有两个参数，运算规则是：先加bias的数值，后与scale数值相乘。</p></blockquote><hr><h2 id="✏️Constant类型（constant）"><a href="#✏️Constant类型（constant）" class="headerlink" title="✏️Constant类型（constant）"></a>✏️Constant类型（constant）</h2><blockquote><p>constant实际上有一堆，分别是constant，constant2vector，constant3vector，constant4vector，他们都输出常量，只是通道数量不一样。他们按通道的个数分别是输出RGBA或者XYZW。</p></blockquote><hr><h2 id="✏️Cross-Product（math）"><a href="#✏️Cross-Product（math）" class="headerlink" title="✏️Cross Product（math）"></a>✏️Cross Product（math）</h2><blockquote><p>叉积，计算两个三通道向量值输入的交叉乘积，并输出产生的三通道向量值。假定空间中有两个向量，则交叉乘积是一个同时垂直于两个输入的向量。计算方式与数学上面的叉积没有区别。</p></blockquote><ul><li>CrossProduct常用于计算垂直于另外两个方向的方向。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cross-product.jpg" alt="cross-product"></li></ul><hr><h2 id="✏️Custom-Rotator（texturing）"><a href="#✏️Custom-Rotator（texturing）" class="headerlink" title="✏️Custom Rotator（texturing）"></a>✏️Custom Rotator（texturing）</h2><blockquote><p>自定义旋转，它会提供一个center，然后你可以实际运用这个center去定义不同的点，来进行旋转。</p></blockquote><ul><li>它有三个input<ul><li>UVs </li><li>Rotation Center（这实际就是设置中心的地方）</li><li>Roataton Angle（0-1的区间，360度）</li></ul></li></ul><hr><h2 id="✏️Depth-Fade（texturing）"><a href="#✏️Depth-Fade（texturing）" class="headerlink" title="✏️Depth Fade（texturing）"></a>✏️Depth Fade（texturing）</h2><blockquote><p>深度消退，用来隐藏半透明对象与不透明对象相交时出现的不美观接缝，起到柔化边缘相交处的接缝的作用。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/depthFade.png" alt="depthFade"></p><ul><li>注意选择合适的fade distance。</li><li>depth fade在制作地形，植被时候可以用来改善相交处的接缝。</li></ul><hr><h2 id="✏️Depth-of-Field-Funtion（Utility）"><a href="#✏️Depth-of-Field-Funtion（Utility）" class="headerlink" title="✏️Depth of Field Funtion（Utility）"></a>✏️Depth of Field Funtion（Utility）</h2><blockquote><p>景深运算，根据景深设置你所要取的区间。</p></blockquote><ul><li>0代表in focus；1代表out of focus</li><li>可以使用它作为on 和 off；比如距离近的时候使用高分辨率的贴图之类的，使用dof function来判断是不是in focus。</li></ul><hr><h2 id="✏️Desaturation（color）"><a href="#✏️Desaturation（color）" class="headerlink" title="✏️Desaturation（color）"></a>✏️Desaturation（color）</h2><blockquote><p>去饱和度，对input进行饱和度去除，即根据特定百分比将其输入的颜色转换为灰色阴影</p></blockquote><ul><li>它有两个input<ul><li>Luminance Factors（指定每个通道对去饱和度颜色的影响量。此属性确保在去饱和度之后，绿色比红色亮，而红色比蓝色亮。）</li><li>Fraction （指定要应用于输入的去饱和度数量。此百分比的范围是0.0（完全原始颜色，不去饱和度）到1.0（完全去饱和度）。）</li></ul></li></ul><hr><h2 id="✏️Diamond-Gradient（miscellaneous）"><a href="#✏️Diamond-Gradient（miscellaneous）" class="headerlink" title="✏️Diamond Gradient（miscellaneous）"></a>✏️Diamond Gradient（miscellaneous）</h2><blockquote><p>钻石型渐变图案。可以通过调整fall off 得到不同程度的衰减效果。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/diamondGradient.png" alt="diamondGradient"></p><hr><h2 id="✏️Distance（math）"><a href="#✏️Distance（math）" class="headerlink" title="✏️Distance（math）"></a>✏️Distance（math）</h2><blockquote><p>距离计算，计算两个点&#x2F;颜色&#x2F;位置&#x2F;矢量之间的欧氏距离，并输出结果值。此表达式可作用于单分量、双分量、三分量和四分量矢量，但此表达式的两个输入必须具有相同数目的通道。</p></blockquote><ul><li>可以理解为：Result &#x3D; length (A - B)<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/DistanceExample.jpg" alt="DistanceExample"></li></ul><hr><h2 id="✏️Divide（math）"><a href="#✏️Divide（math）" class="headerlink" title="✏️Divide（math）"></a>✏️Divide（math）</h2><blockquote><p>除法，取两个输入，将第一个输入除以第二个输入，并输出值。</p></blockquote><ul><li>两个输入必须有相同数量的值，但其中一个值是单个浮点值时例外。在这种情况下，将多通道输入的每个通道除以单个浮点值，并将结果存储在输出值的单独通道中。</li><li>如果使用多个通道传递值，每个通道将单独相除。</li><li>如果除数在任何通道内都介于0和0.00001之间，则将其提升至0.00001。如果除数在任何通道内都介于0和-0.00001之间，则将其降低至-0.00001。这避免了出现除以零的错误可能性。但是，这也意味着通道的输出值可能非常大。</li></ul><hr><h2 id="✏️Dot-Product（math）"><a href="#✏️Dot-Product（math）" class="headerlink" title="✏️Dot Product（math）"></a>✏️Dot Product（math）</h2><blockquote><p>点积，点积可以描述为一个向量投影到另一个向量上的长度，也可以描述为两个向量之间的余弦乘以它们的幅值。许多技术使用这种算法来计算衰减。DotProduct要求两个向量输入具有相同数量的通道。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/dot-product.jpg" alt="dot-product"></p><hr><h2 id="✏️Feature-Level-Switch（math）"><a href="#✏️Feature-Level-Switch（math）" class="headerlink" title="✏️Feature Level Switch（math）"></a>✏️Feature Level Switch（math）</h2><blockquote><p>特征等级切换，此节点允许你你使用相同的材质，但是可以基于不同的shader level去显示不同的东西，多用于设置材质用于不同设备时。</p></blockquote><ul><li>举个例子来看，如下图，我们的preview Rendering Level是不同的；这个材质节点的作用就是当你有这样一些feature level的时候，它的inputs提供的选项允许你去自行设置先要输出的内容，如果它没有特殊被设置，那就会自行使用default。</li><li>他必须使用一个default，否则无法工作。</li><li>你可以通过此设置更轻量的东西去到移动端设备。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FeatureLevelSwitch.png" alt="FeatureLevelSwitch"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FeatureLevelSwitch_02.png" alt="FeatureLevelSwitch_02"></li></ul><hr><h2 id="✏️Floor-and-Ceil（math）"><a href="#✏️Floor-and-Ceil（math）" class="headerlink" title="✏️Floor and Ceil（math）"></a>✏️Floor and Ceil（math）</h2><blockquote><p><strong>Floor</strong>，舍去小数部分，<strong>向下取整</strong>。比如0.2向下舍入取整就是0.0；(0.2,1.6)向下舍入到(0.0, 1.0)。 </p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/floor.jpg" alt="floor"></p><blockquote><p><strong>Ceil</strong>，舍去小数部分，<strong>向上取整</strong>。比如0.2向上舍入取整就是1.0；(0.2,1.6)向上舍入到(1.0,2.0)。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ceil.jpg" alt="ceil"></p><ul><li>这两个节点可以理解为做相同的事情，但是结果相反，就像min和max一样。</li><li>他们的名字也可以看出floor是向下，ceil则是向上。</li></ul><hr><h2 id="✏️FMod（math）"><a href="#✏️FMod（math）" class="headerlink" title="✏️FMod（math）"></a>✏️FMod（math）</h2><blockquote><p>除不尽的取取余数。也就是返回两个input的除法运算的浮点余数，第一个input可以是任何数，第二个input通常不为0（被除数不为0）</p></blockquote><ul><li>它的常见的用例是制作一种材质，使其亮度上升到最大值，然后在下一帧中立即下降到最小值，然后再次开始向最大值攀升。</li><li>如下图示例，FMod采用0到1的UV级数，并将其转换为绿色通道中X轴上每0.2个UV单元一次的重复循环。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FmodExample.jpg" alt="FmodExample"></li></ul><hr><h2 id="✏️Frac（math）"><a href="#✏️Frac（math）" class="headerlink" title="✏️Frac（math）"></a>✏️Frac（math）</h2><blockquote><p>fractional，取小数；输入input，此节点返回input的小数部分。输出值将从0到1不等。</p></blockquote><ul><li>举例来说：(0.2)的小数部分是(0.2)。(-0.2)的小数部分是(0.8)。(0.0,1.6,1.0)的小数部分是(0.0,0.6,0.0)。</li><li>如下图示例，Frac节点将时间转换为一系列重复的0 - 1级数序列，导致颜色（通过Lerp）从绿色变为红色，然后返回绿色，无限重复。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/frac.jpg" alt="frac"></li></ul><hr><h2 id="✏️Fresnel（utility）"><a href="#✏️Fresnel（utility）" class="headerlink" title="✏️Fresnel（utility）"></a>✏️Fresnel（utility）</h2><blockquote><p>菲涅尔，根据表面法线与摄像机方向的标量积来计算衰减。当表面法线正对着摄像机时，输出值为0。当表面法线垂直于摄像机时，输出值为1。结果限制在[0,1]范围内，以确保不会在中央产生任何负颜色。</p></blockquote><ul><li>它有两个属性：<ul><li><strong>Exponent</strong>（指定输出值的衰减速度。值越大，意味着衰减越紧或越快。）</li><li><strong>Base Reflect Fraction</strong>（指定从正对表面的方向查看表面时，镜面反射的小数。值为1将有效地禁用菲涅耳效果。）</li></ul></li><li>它有三个inputs：<ul><li><strong>ExponentIn</strong> （指定输出值的衰减速度。如果使用此输入，那么值将始终取代”指数”（Exponent）属性值。）</li><li><strong>Base Reflect Fraction</strong>（如果使用此输入，那么值将始终取代”指数”（Exponent）属性值。）</li><li><strong>Normal</strong>（该值代表表面在全局空间中的法线。要查看应用于菲涅耳对象表面的法线贴图的结果，请将该法线贴图连接到材质的”法线”（Normal）输入，然后连接一个PixelNormalWS 表达式到Fresnel上的此输入。如果未指定任何法线，那么将使用网格的切线法线。）</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FresnelExample.jpg" alt="FresnelExample"></p><hr><h2 id="✏️Generated-Band（miscellaneous）"><a href="#✏️Generated-Band（miscellaneous）" class="headerlink" title="✏️Generated Band（miscellaneous）"></a>✏️Generated Band（miscellaneous）</h2><blockquote><p> 条形图案；允许我们生成一个条状的图案，可以调整宽度，锐度（可以为负），偏移，方向（横向纵向）等等。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedBand.png" alt="GeneratedBand"></p><hr><h2 id="✏️Generated-Offest-Bands（miscellaneous）"><a href="#✏️Generated-Offest-Bands（miscellaneous）" class="headerlink" title="✏️Generated Offest Bands（miscellaneous）"></a>✏️Generated Offest Bands（miscellaneous）</h2><blockquote><p>局部重复条形图案，参数使用与Generated Band几乎无差别，但有一个叫做band的额外参数；这使我们得到一对band（实际上在band这个参数为1,其他参数保持默认的时候，我们得到的是两对白色的band），而不是单个band。</p></blockquote><ul><li>此时compare参数可以调整band之间的间距，为0时两两之间互相成对的band的间距最远，为1时最近。</li><li>详细看图对比。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedOffsetBand.png" alt="GeneratedOffsetBand"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedOffsetBand%E5%AF%B9%E6%AF%94GeneratedBand.png" alt="GeneratedOffsetBand对比GeneratedBand"></li></ul><hr><h2 id="✏️GIReplace（utility）"><a href="#✏️GIReplace（utility）" class="headerlink" title="✏️GIReplace（utility）"></a>✏️GIReplace（utility）</h2><blockquote><p>全局光照替换；这个节点可以为材质提供在全局照明下产生不同间接反射效果的方式。它允许指定一个定值来取代间接反射颜色。</p></blockquote><ul><li>它有三个inputs：<ul><li>Default</li><li>StaticIndirect</li><li>DynamicIndirect</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GIreplace.png" alt="GIreplace"></p><hr><h2 id="✏️If（math）"><a href="#✏️If（math）" class="headerlink" title="✏️If（math）"></a>✏️If（math）</h2><blockquote><p>判断；比较两个输入，然后根据比较的结果传递其他三个输入值中的一个。两个比较的输入都必须是单一浮点值。</p></blockquote><ul><li>如下图示例，if接受一个高度图，并根据高度是低于还是高于0.2的值来输出红色或绿色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/IfExample.jpg" alt="IfExample"></li></ul><hr><h2 id="✏️Interface-Previewing-Property（材质details）"><a href="#✏️Interface-Previewing-Property（材质details）" class="headerlink" title="✏️Interface Previewing Property（材质details）"></a>✏️Interface Previewing Property（材质details）</h2><blockquote><p>修改预览网络，可以自定义材质节点编辑器中的预览mesh。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/InterfacePreviewingProperty_01.png" alt="InterfacePreviewingProperty_01"></p><hr><h2 id="✏️Lightmess-Property（材质details）"><a href="#✏️Lightmess-Property（材质details）" class="headerlink" title="✏️Lightmess Property（材质details）"></a>✏️Lightmess Property（材质details）</h2><blockquote><p>Lightmess，你可以理解为它是static light system。它创建具有复杂光交互作用的光照图，例如区域阴影和漫反射。它用于预计算<strong>具有固定和静态运动性的光源的照明贡献部分。</strong></p></blockquote><ul><li>你可以使用 cast shadow as masked或不使用它；它们的效果不同。</li><li>如下图所示，左边是不勾选cast shadow as masked，阴影为绿色；右边是勾选此属性，半透明物体会使用遮罩，阴影为黑色，使它得到清晰的阴影以及轮廓；<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessProperty.png" alt="LightmessProperty"></li><li><strong>diffuse boost</strong>，材质漫反射<strong>对静态光照影响量</strong>的增加和提升，更高的数值会更清晰明亮。（<strong>记住是static lighting的情况</strong>，而不是realtime，所有的光照都经过bake。）</li><li><strong>Export Resolution Scale</strong>，导出该材质属性时的分辨率乘数。<strong>在需要详细信息时应增大此数值</strong>（计算时间也会增加）。</li></ul><hr><h2 id="✏️Lightmess-Replace（utility）"><a href="#✏️Lightmess-Replace（utility）" class="headerlink" title="✏️Lightmess Replace（utility）"></a>✏️Lightmess Replace（utility）</h2><blockquote><p>光照系统替换, 有两个inputs，来确定使用realtime（接收要传递以用于正常渲染的值）和使用lightmass（接收在导出材质到光照系统时要传递的值）时的输出效果。它可以避免使用导出版本无法正确处理的材质表达式，例如WorldPosition。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessReplace.png" alt="LightmessReplace"></p><ul><li>下图示例设置lightmass的情况<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessReplace_lightmass.png" alt="LightmessReplace_lightmass"></li></ul><hr><h2 id="✏️Linear-Gradient（Gradient）"><a href="#✏️Linear-Gradient（Gradient）" class="headerlink" title="✏️Linear Gradient（Gradient）"></a>✏️Linear Gradient（Gradient）</h2><blockquote><p>线性渐变；函数使用 UV 通道 0 在 U 或 V 方向上产生线性渐变，其中，方向取决于所使用的输出。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LinearGradient.png" alt="LinearGradient"></p><hr><h2 id="✏️Linear-Interpolate（utility）"><a href="#✏️Linear-Interpolate（utility）" class="headerlink" title="✏️Linear Interpolate（utility）"></a>✏️Linear Interpolate（utility）</h2><blockquote><p><strong>就是Lerp</strong>，线性插值；用作蒙版的第三个输入值，在两个输入值之间进行混合；蒙版Alpha（相当于a与b之间的mask）的强度确定从两个输入值获取颜色的比例。</p></blockquote><ul><li>如果Alpha为0.0色，那么将使用第一个输入。如果Alpha为1.0，那么将使用第二个输入。如果Alpha介于0.0与1.0之间，那么输出是两个输入之间的混合。</li><li>请记住，混合按通道进行。因此，如果Alpha为RGB颜色，那么Alpha的红色通道值定义A与B的红色通道之间的混合，而与Alpha的绿色通道 无关，该通道定义A与B的绿色通道之间的混合。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LerpExample.jpg" alt="LerpExample"></li></ul><hr><h2 id="✏️Min-and-Max（math）"><a href="#✏️Min-and-Max（math）" class="headerlink" title="✏️Min and Max（math）"></a>✏️Min and Max（math）</h2><blockquote><p>Max ，最大值；有两个输入，输出其中较大的一个。结果类似于Photoshop中的 变亮 图层混合模式。<br>Min ， 最小值；有两个输入，输出其中较小的一个。结果类似于Photoshop中的 变暗 图层混合模式。</p></blockquote><hr><h2 id="✏️Mobile-Property（材质属性界面，details）"><a href="#✏️Mobile-Property（材质属性界面，details）" class="headerlink" title="✏️Mobile Property（材质属性界面，details）"></a>✏️Mobile Property（材质属性界面，details）</h2><blockquote><p>移动平台；多用于节约性能以便于移动端使用</p></blockquote><ul><li><strong>Use Full Precision</strong> ，强制此材质在像素着色器中使用全（highp）精度。它的处理速度比默认设置（mediump）慢，但可用于解决与精度相关的渲染错误。此设置对不支持高精度的旧版移动设备无效。</li><li><strong>Use Lightmap Directionality</strong>，此属性将使用光照图方向性和逐像素法线。如果禁用此属性，光照图中的光照将是平面的，但开销更低。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/MobileProperty.png" alt="MobileProperty"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/MobileProperty_02.png" alt="MobileProperty_02"></li><li>（左侧Fully Rough off，Use Lightmap Directionality on。右侧效果Fully Rough on，Use Lightmap Directionality off）</li></ul><hr><h2 id="✏️Multiply（math）"><a href="#✏️Multiply（math）" class="headerlink" title="✏️Multiply（math）"></a>✏️Multiply（math）</h2><blockquote><p>乘法；数学计算的相乘。作为叠加来使用结果类似于Photoshop中的 正片叠底 图层混合模式的结果。</p></blockquote><ul><li>两个输入必须有相同数量的值，但其中一个值是单个浮点值时例外。在这种情况下，将多通道输入的每个通道乘以单个浮点值，并将结果存储在输出值的单独通道中。</li><li>E4中的材质不限于[0,1]。如果颜色&#x2F;值大于1，Multiply会使颜色变亮。</li><li>Multiply常用于使颜色&#x2F;纹理变亮或变暗，或用于操作纹理UV。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mult-01.jpg" alt="mult-01"></li></ul><hr><h2 id="✏️Noise（math）"><a href="#✏️Noise（math）" class="headerlink" title="✏️Noise（math）"></a>✏️Noise（math）</h2><blockquote><p>噪点，噪波； 它有很多可以设置的参数。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/NoiseExample.jpg" alt="NoiseExample"></p><ul><li>【<strong>它的参数</strong>】：<ul><li><strong>Scale</strong>（更改噪点单元的整体大小。数字越小，噪点越大。）</li><li><strong>Quality</strong>（外观&#x2F;性能设置。值越小，速度越快，但效果越差；值越大，速度越慢，但效果更好。）</li><li><strong>function</strong>（噪波类型）<ul><li>Simplex</li><li>Gradient</li><li>Fast Gradient</li><li>Value</li><li>Voronoi</li></ul></li><li><strong>Turbulence</strong>（启用”干扰”（Turbulence）后，每个噪点倍频只会在结果中增加绝对值。改变视觉特征，并且会塑造出类似于清晰的山脊形状）</li><li><strong>Levels</strong>（不同范围要合并的不同噪点级数量乘以级别数量的计算成本。）</li><li><strong>Output Min</strong></li><li><strong>Output Max</strong></li><li><strong>Level Scale</strong></li><li><strong>Tiling</strong></li><li><strong>Repeat Size</strong></li></ul></li><li>【<strong>它的input</strong>】：<ul><li><strong>Position</strong>（允许通过 3D 矢量来调整纹理大小）</li><li><strong>FilterWidth</strong>（实际上，控制应用于噪点纹理的模糊量）</li></ul></li></ul><hr><h2 id="✏️Normalize（math）"><a href="#✏️Normalize（math）" class="headerlink" title="✏️Normalize（math）"></a>✏️Normalize（math）</h2><blockquote><p>归一化；归一化向量（也称”单位向量”）的整体长度为1.0。这意味着输入的每个分量都除以向量的总大小（长度）。</p></blockquote><ul><li>通过Normalize传递(0,2,0)或(0,0.2,0)都将输出(0,1,0)。通过Normalize传递(0,1,-1)将输出(0, 0.707, -0.707)。全零向量是唯一的例外，它不会改变。</li><li>计算如下：先计算出长度d，再用每一个分量与长度d相除（x&#x2F;d,y&#x2F;d,z&#x2F;d），得到相应的归一化向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/normalize.png" alt="normalize"></li></ul><hr><h2 id="✏️Object-Orientation（coordinates）"><a href="#✏️Object-Orientation（coordinates）" class="headerlink" title="✏️Object Orientation（coordinates）"></a>✏️Object Orientation（coordinates）</h2><blockquote><p>输出object的世界场景向上向量(up)。换言之，对象的局部正z轴正指向此方向。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/object-orientation.jpg" alt="object-orientation"></p><hr><h2 id="✏️Object-Position-WS（coordinates）"><a href="#✏️Object-Position-WS（coordinates）" class="headerlink" title="✏️Object Position WS（coordinates）"></a>✏️Object Position WS（coordinates）</h2><blockquote><p>输出对象边界的世界场景空间中心位置。它的变化则是以整体中心为基准。</p></blockquote><ul><li>这对于为植物创建球形照明很有用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/object-position-ws.jpg" alt="object-position-ws"></li></ul><hr><h2 id="✏️Object-Radius（coordinates）"><a href="#✏️Object-Radius（coordinates）" class="headerlink" title="✏️Object Radius（coordinates）"></a>✏️Object Radius（coordinates）</h2><blockquote><p>输出给定对象以 Unreal 单位计的半径值。系统会对比例缩放加以考虑，并且对于每个对象，结果可能是唯一的。</p></blockquote><ul><li>比如可以根据radius调整贴图的tile来适配场景，而不会因为它等比增加或减少而导致贴图错误。</li></ul><hr><h2 id="✏️One-Minus（math）"><a href="#✏️One-Minus（math）" class="headerlink" title="✏️One-Minus（math）"></a>✏️One-Minus（math）</h2><blockquote><p>反向，反色；接受输入值”X”并输出”1 - X”。</p></blockquote><p>-当输入的颜色在[0,1]范围内时，OneMinus的效果与我们通常所说的”反色”是一样的，也就是说，OneMinus返回的是添加到输入时会产生白色的互补色。</p><hr><h2 id="✏️Packed-Textures"><a href="#✏️Packed-Textures" class="headerlink" title="✏️Packed Textures"></a>✏️Packed Textures</h2><blockquote><p>打包，合并贴图；可以将metallic和roughness等灰度图合并到一起，分别放在rgb的相应通道中使用，以得到更好的性能（相比于多张分开的贴图）。</p></blockquote><hr><h2 id="✏️Panner（coordinates）"><a href="#✏️Panner（coordinates）" class="headerlink" title="✏️Panner（coordinates）"></a>✏️Panner（coordinates）</h2><blockquote><p>平移，输出可用于创建平移（或移动）纹理的 UV 纹理坐标。</p></blockquote><ul><li>示例：调整speed使其变化<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/PannerExample.jpg" alt="PannerExample"></li></ul><hr><h2 id="✏️Parameter-Collection（材质参数集合）"><a href="#✏️Parameter-Collection（材质参数集合）" class="headerlink" title="✏️Parameter Collection（材质参数集合）"></a>✏️Parameter Collection（材质参数集合）</h2><blockquote><p>材质参数集合，是虚幻内部的一个item，属于一种资产。<br>它允许你在里面放置参数，并且可以跨越多种材质来使用它，可以一次性将这个全局性数据导入多个材质，并且允许你同时控制调整这个参数。</p></blockquote><ul><li>它还有助于设置关卡中的效果，例如雪量、破坏程度、湿度等。如果不使用材质参数集合，你需要在关卡的不同材质实例中单独设置许多材质参数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/create-mpc.jpg" alt="create-mpc"></li><li>设置好后，可以去材质节点版面调用它。</li><li>它的使用方法官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/using-material-parameter-collections-in-unreal-engine/">链接在此</a></li></ul><hr><h2 id="✏️Parameters（convert-to-Parameters）"><a href="#✏️Parameters（convert-to-Parameters）" class="headerlink" title="✏️Parameters（convert to Parameters）"></a>✏️Parameters（convert to Parameters）</h2><blockquote><p>转为参数；它更多是指特定节点上的切换，允许他们在实例（instance）材质被使用。<br>基本上通俗的理解就是：转化原材质的参数，在复制后的代理材质也会拥有原材质一样的功能，可以被修改和实时调整，而不需要取重新打开材质版面修改再重新编译材质。</p></blockquote><ul><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/convertParameters.png" alt="convertParameters"></li></ul><hr><h2 id="✏️Physical-Material（物理材质）"><a href="#✏️Physical-Material（物理材质）" class="headerlink" title="✏️Physical Material（物理材质）"></a>✏️Physical Material（物理材质）</h2><blockquote><p>物理材质，用于定义物理对象在与世界场景动态交互时的响应。<br>物理材质非常容易使用。创建一个物理材质将提供一组默认值，这与应用于所有物理对象的默认物理材质相同。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/create_PhysicalMaterial.png" alt="create_PhysicalMaterial"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/parameters_PhysicalMaterial.png" alt="parameters_PhysicalMaterial"></p><ul><li>以上示例是创建物理材质以及双击编辑材质。使用物理材质的教学官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/physical-materials-user-guide-for-unreal-engine/">链接在此</a></li><li>它的物理材质属性在官方可以找到，<a href="https://docs.unrealengine.com/5.0/zh-CN/physical-materials-reference-for-unreal-engine/">链接在此</a></li></ul><hr><h2 id="✏️Pixel-Depth（Depth）"><a href="#✏️Pixel-Depth（Depth）" class="headerlink" title="✏️Pixel Depth（Depth）"></a>✏️Pixel Depth（Depth）</h2><blockquote><p>像素深度，输出当前所渲染像素的深度，即该像素与摄像机之间的距离。</p></blockquote><ul><li>此表达式支持正数，不支持负数。这是因为在现代硬件上，渲染器依赖于保守深度优化来维持良好的性能。这就带来了额外的一点好处：如果深度可以 远离 摄像机，硬件深度抑制（hardware depth rejection）可以通过顶点着色器输出重复使用。否则，如果允许像素深度偏移 移向 摄像机，就可能导致对象戳穿一切，这样无论像素是否使用像素深度偏移进行遮挡，像素着色器都会处理这些像素。</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/PixelDepth.png" alt="PixelDepth"></p><ul><li>在此示例中，已将材质网络应用于地板。请注意当地板后退 2048 个以上单位时，线性插值在两种颜色之间是如何进行混合的。使用了 Power（幂）表达式来加强这两种颜色之间的对比，并产生更有意义的视觉效果。</li></ul><hr><h2 id="✏️Pixel-Normal-WS（Coordinates）"><a href="#✏️Pixel-Normal-WS（Coordinates）" class="headerlink" title="✏️Pixel Normal WS（Coordinates）"></a>✏️Pixel Normal WS（Coordinates）</h2><blockquote><p>根据当前法线输出向量数据，该数据表示像素所面对的方向。它在世界空间中，逐像素给出对应结果。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/pixel-normal-ws.jpg" alt="pixel-normal-ws"></p><ul><li>在此示例中，PixelNormalWS被输入到底色（Base Color）中。请注意，法线贴图用于给出逐像素结果。</li></ul><hr><h2 id="✏️Post-Processing-Material-Property（后期材质）"><a href="#✏️Post-Processing-Material-Property（后期材质）" class="headerlink" title="✏️Post Processing Material Property（后期材质）"></a>✏️Post Processing Material Property（后期材质）</h2><blockquote><p>后期材质，后期处理材质使你能够设置与后期处理一起使用的材质，以创建破坏的视觉屏幕效果、区域类型效果或 只能通过后置处理材质才能实现的游戏整体外观。</p></blockquote><ul><li>在ue document中有详细介绍，<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/PostProcessMaterials/">链接在此</a></li><li>以及一些效果示例，<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview/">链接在此</a></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/postProcess.png" alt="postProcess"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/postProcess_02.png" alt="postProcess_02"></p><ul><li>将材质设置为post process时，它的属性栏就会被激活。材质只能使用 自发光颜色（Emissive Color） 输出新颜色。此外，你还可以定义在后期处理过程中应在何处应用此通道， 如果有多个通道，则应按什么顺序处理（优先级）</li></ul><hr><h2 id="✏️Power（math）"><a href="#✏️Power（math）" class="headerlink" title="✏️Power（math）"></a>✏️Power（math）</h2><blockquote><p>幂，N次方；它接收两个输入：基值(Base)和指数(Exp)。它将基值提高到指数的幂，并输出结果。换句话说，它返回 Base 乘以自身 Exp 次。</p></blockquote><ul><li>示例：当底数为0.5且指数为2.0时，幂为0.25。</li></ul><hr><h2 id="✏️Property"><a href="#✏️Property" class="headerlink" title="✏️Property"></a>✏️Property</h2><blockquote><p>材质属性；材质版面details可以具体调整材质的各种属性。</p></blockquote><ul><li>它有很详细的官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a></li><li>官方文档中，它的每一个属性以及下拉菜单都有详细介绍。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/material-properties-all.jpg" alt="material-properties-all"></li></ul><hr><h2 id="✏️quality-switch（utility）"><a href="#✏️quality-switch（utility）" class="headerlink" title="✏️quality switch（utility）"></a>✏️quality switch（utility）</h2><blockquote><p>质量开关；通过调整质量设置，来切换引擎质量的显示，来配合硬件的性能，适配对应相应的画质表现。允许设置low，mid，high。<br>允许根据引擎在不同质量级别之间的切换使用不同的网络，例如在较低端的设备上使用较低的质量。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/qualitySwitch.png" alt="qualitySwitch"></p><hr><h2 id="✏️Radial-Gradient-Exponential（Gradient）"><a href="#✏️Radial-Gradient-Exponential（Gradient）" class="headerlink" title="✏️Radial Gradient Exponential（Gradient）"></a>✏️Radial Gradient Exponential（Gradient）</h2><blockquote><p>指数径向渐变；函数使用 UV 通道 0 来产生径向渐变，同时允许用户调整半径和中心点偏移。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RadialGradientExponential_02.png" alt="RadialGradientExponential_02"></p><hr><h2 id="✏️Rotate-About-Axis（utility）"><a href="#✏️Rotate-About-Axis（utility）" class="headerlink" title="✏️Rotate About Axis（utility）"></a>✏️Rotate About Axis（utility）</h2><blockquote><p>绕轴旋转，给定旋转轴、该轴上的某个点以及旋转角度的情况下，旋转三通道矢量输入。此表达式适合于使用”全局位置偏移”（WorldPositionOffset）产生简单剪切的动画。</p></blockquote><ul><li>示例：预览平面将显示为绕着它的垂直轴旋转。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RotateAboutAxisExample.jpg" alt="RotateAboutAxisExample"></li></ul><hr><h2 id="✏️Rotator（coordinate）"><a href="#✏️Rotator（coordinate）" class="headerlink" title="✏️Rotator（coordinate）"></a>✏️Rotator（coordinate）</h2><blockquote><p>旋转，以双通道向量值形式输出 UV 纹理坐标，该向量值可用来创建旋转纹理。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/rotatorExample.png" alt="rotatorExample"></p><hr><h2 id="✏️screen-Position（coordinate）"><a href="#✏️screen-Position（coordinate）" class="headerlink" title="✏️screen Position（coordinate）"></a>✏️screen Position（coordinate）</h2><blockquote><p>屏幕位置，输出当前所渲染像素的屏幕空间位置。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/screen-position.jpg" alt="screen-position"></p><hr><h2 id="✏️sin和cosine（math）"><a href="#✏️sin和cosine（math）" class="headerlink" title="✏️sin和cosine（math）"></a>✏️sin和cosine（math）</h2><blockquote><p>常见使用用途是输出某种有规律的waves。<br><strong>sine，正弦</strong>。表示输入范围和[-1, 1]的输出范围上反复输出正弦波的值。它与Cosine表达式的输出之间的区别是输出波形被四分之一的周期所抵消，这意味着”Cos(X)”等于”Sin(X + 0.25)”。<br>sine最常用于通过将一个 时间（Time） 表达式与其输入连接来输出连续的振荡波形，但它也可以用于在世界场景空间或屏幕空间或任何其他需要连续、平滑循环的应用中创建波纹。波形的可视化表示如下图所示，缩放到[0, 1]输出范围：</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SineWave.jpg" alt="SineWave">、<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SineExample.jpg" alt="SineExample"></p><blockquote><p><strong>cosine, 余弦</strong>；表示在[0, 1]的输入范围和[-1, 1]的输出范围上反复输出余弦波的值。<br>cosine最常用于通过将一个 时间 表达式与其输入连接来输出连续的振荡波形，但它也可以用于在世界场景空间或屏幕空间或任何其他需要连续、平滑循环的应用中创建波纹。波形的可视化表示如下图所示，缩放到[0, 1]输出范围：</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/CosineWave.jpg" alt="CosineWave"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/CosineExample.jpg" alt="CosineExample"></p><hr><h2 id="✏️sphere-mask（utility）"><a href="#✏️sphere-mask（utility）" class="headerlink" title="✏️sphere mask（utility）"></a>✏️sphere mask（utility）</h2><blockquote><p>球体蒙版；根据距离计算来输出蒙版值。<br>如果某一个输出是某个点的位置，而另一输入是具有某半径的球体的中心，那么蒙版值将是0（位于球体外部）和1（位于球体内部），并存在一定的过渡区域。此表达式可作用于单分量、双分量、三分量和四分量矢量。</p></blockquote><ul><li>示例：当摄像机距离预览对象超过256个单位时，该对象将平滑地渐变为黑色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SphereMaskExample.jpg" alt="SphereMaskExample"></li></ul><hr><h2 id="✏️square-Root（math）"><a href="#✏️square-Root（math）" class="headerlink" title="✏️square Root（math）"></a>✏️square Root（math）</h2><blockquote><p>平方根；。如果应用于向量，则每个分量将分别处理。输出的也是一个数学结果。</p></blockquote><ul><li>对于0到1范围内的纹理，这会降低图像的对比度。例如，在下面的校准纹理中，深色值会变得更亮，白色值会向灰色转变。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/square-root.jpg" alt="square-root"></li></ul><hr><h2 id="✏️substract（math）"><a href="#✏️substract（math）" class="headerlink" title="✏️substract（math）"></a>✏️substract（math）</h2><blockquote><p>减法；接受两个输入，将第一个输入减去第二个输入，然后输出差值。</p></blockquote><ul><li>两个输入必须有相同数量的值，但其中一个值是单个常量值时例外。在这种情况下，将多通道输入的每个通道减去常量值，并将结果存储在输出值的单独通道中。</li><li><strong>示例</strong>：0.5与0.2相减得0.3；(0.2,-0.4,0.6)与(0.1,0.1,1.0)相减得(0.1,-0.5,-0.4)；(0.2,0.4,1.0)与0.2相减得(0.0,0.2,0.8)。</li><li>Subtract可以用来加深颜色和偏移UV。</li></ul><hr><h2 id="✏️swizzle（miscellaneous）"><a href="#✏️swizzle（miscellaneous）" class="headerlink" title="✏️swizzle（miscellaneous）"></a>✏️swizzle（miscellaneous）</h2><blockquote><p>通道扰乱，主要作用是flip原来的x和y，比如xyz会变成yxz。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/swizzle.png" alt="swizzle"></p><hr><h2 id="✏️Time（constant）"><a href="#✏️Time（constant）" class="headerlink" title="✏️Time（constant）"></a>✏️Time（constant）</h2><blockquote><p>时间；用来向材质（例如，Panner（平移）、Cosine（余弦） 或其他时间相关操作）添加经历时间。代表时间流逝，但是会不断更新。</p></blockquote><ul><li>它有两个参数：<ul><li>Ignore Pause（如果为 true，那么时间将一直推进，即使游戏暂停也是这样。）</li><li>Period （如果为 true，那么这将是时间回绕前经过的时间量。针对移动材质，这将以全精度在 CPU 上执行周期计算，而在 GPU 上，将以半精度运行（处理长度超过一分钟的周期时，可能会产生问题））</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/TimeExample.jpg" alt="TimeExample"></p><ul><li>上图中说明的网络将创建一个随时间推移而变化的材质，从而连贯地展现白色与黑色之间的正弦曲线过渡。如果启用了时间段，那么将时间段设置为 0 会有效地停止过渡，而设置为 1 相当于时间段为 false。设置接近于 0 的数值将使材质更迅速地变化。</li></ul><hr><h2 id="✏️Translucency-Property"><a href="#✏️Translucency-Property" class="headerlink" title="✏️Translucency Property"></a>✏️Translucency Property</h2><blockquote><p>半透明属性；<br>最终颜色 &#x3D; 源颜色 不透明度 + 目标颜色 (1 - 不透明度)。此混合模式与动态光照 不 兼容。</p></blockquote><ul><li>需要确保 screnn space reflcetions 为true，开启后支持半透明材质的屏幕空间反射。</li><li>并且根据场景需求选择Translucency lighting mode，这可以控制半透明（Translucency）在该材质中使用的光照模式。下拉菜单越往下开销越大。</li><li>材质属性详细查看document，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a></li></ul><hr><h2 id="✏️Translucency-self-shadowing-Property"><a href="#✏️Translucency-self-shadowing-Property" class="headerlink" title="✏️Translucency self shadowing Property"></a>✏️Translucency self shadowing Property</h2><blockquote><p>半透明自投影；<strong>半透明自身阴影是一种获得体积光照半透明对象（例如烟柱或蒸汽柱）的好方法</strong>。自投影分为两个主要部分：自身阴影密度（Self Shadow Density）和第二自身阴影密度（Second Self Shadow Density）。这两个部分的存在为变化提供了可能。你可以单独定义各个部分的密度，并使用它们之间的差异在整个自身阴影中获得你需要的模式。</p></blockquote><ul><li>在translucent mode下使用，需要有一个base color</li><li>材质属性详细查看document，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/translucency-self-shadowing.jpg" alt="translucency-self-shadowing"></li></ul><hr><h2 id="✏️Tesselation-Property"><a href="#✏️Tesselation-Property" class="headerlink" title="✏️Tesselation Property"></a>✏️Tesselation Property</h2><blockquote><p>曲面细分；增加了额外的几何，用于添加更多物理细节。</p></blockquote><ul><li>Flat Tessellation，曲面细分的简单形式。此模式会在不平滑网格体的前提下添加更多三角形。</li><li>PN Triangles，使用基于样条的简单曲面细分，这种曲面细分虽然开销更高，但细节表现效果更佳。</li><li>官方文档<a href="https://docs.unrealengine.com/4.26/zh-CN/RenderingAndGraphics/Materials/MaterialProperties/">链接在此</a></li></ul><hr><h2 id="✏️Texture-Coordinate（coordinate）"><a href="#✏️Texture-Coordinate（coordinate）" class="headerlink" title="✏️Texture Coordinate（coordinate）"></a>✏️Texture Coordinate（coordinate）</h2><blockquote><p>纹理坐标；双通道，输出uv纹理坐标，改变uv平铺。</p></blockquote><ul><li>如需访问网格体的第二个 UV 通道，请创建一个 TextureCoordinate（纹理坐标）节点，将其”坐标索引”（CoordinateIndex）设置为 1（0 表示第一个通道，1 表示第二个通道，等等），并将其连接到 TextureSample（纹理取样）节点的 UV 输入。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/texture-coordinates.jpg" alt="texture-coordinates"></li></ul><hr><h2 id="✏️Texture-sample（texture）"><a href="#✏️Texture-sample（texture）" class="headerlink" title="✏️Texture sample（texture）"></a>✏️Texture sample（texture）</h2><blockquote><p>纹理贴图，输出input的纹理颜色，一般就是2d贴图为主</p></blockquote><ul><li><strong>UVs</strong>，接收UV纹理坐标，以用于纹理。如果没有任何值输入到UV，那么将使用材质所应用到的网格体的纹理坐标</li><li>**DDX(UVs)**，接收UV输入的DDX以用于各向异性过滤。默认情况下，硬件自动执行此过滤，并且速度更快。但是在某些情况下，可能需要使用DDX材质表达式显式地设置此项目，以避免延迟贴花的2x2像素块瑕疵之类的瑕疵。仅当 Mip值模式（MipValueMode） &#x3D; 导数（Derivative） 时才可用。</li><li>**DDY(UVs)**，接收UV输入的DDY以用于各向异性过滤，这与DDX（UV）接收UV输入的DDX相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/TextureSampleExample.jpg" alt="TextureSampleExample"></li></ul><hr><h2 id="✏️value-step（gradient）"><a href="#✏️value-step（gradient）" class="headerlink" title="✏️value step（gradient）"></a>✏️value step（gradient）</h2><blockquote><p>值阶；接收现有的纹理通道或渐变，并根据用户的输入来输出纯黑白色图像。结果是一个蒙版，它代表与输入值相等的渐变部分。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/valueStep.png" alt="valueStep"></p><hr><h2 id="✏️vector-to-radial-value（miscellaneous）"><a href="#✏️vector-to-radial-value（miscellaneous）" class="headerlink" title="✏️vector to radial value（miscellaneous）"></a>✏️vector to radial value（miscellaneous）</h2><blockquote><p>矢量到径向值；将”矢量 2”矢量转换为角度，或者将 UV 坐标数据转换为径向坐标。对于矢量，角度将在一个通道中输出，而矢量长度在另一通道中输出。</p></blockquote><ul><li>Radial Coordinates（返回输入的径向坐标，对于矢量，角度将在一个通道中输出，而距离在另一通道中输出。）</li><li>Vector Converted to Angle（返回输入矢量的角度，返回径向梯度）</li><li>Linear Distance（返回输入矢量的线性长度，对于 UV，输出距离的径向梯度。）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vectorToRadialValue.png" alt="vectorToRadialValue"></li></ul><hr><h2 id="✏️vertex-Normal-WS（coordinate）"><a href="#✏️vertex-Normal-WS（coordinate）" class="headerlink" title="✏️vertex Normal WS（coordinate）"></a>✏️vertex Normal WS（coordinate）</h2><blockquote><p>世界场景空间顶点法线；它只能用于在顶点着色器中执行的材质输入，例如WorldPositionOffset。<br>该表达式对于设置网格体增大或缩小很有用</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vertexNormalWS.png" alt="vertexNormalWS"></p><ul><li>如上示例，小球每个顶点的法线会在各自法线方向上移动，会随着正弦运动按比例放大和缩小。</li></ul><hr><h2 id="✏️view-size（coordinate）"><a href="#✏️view-size（coordinate）" class="headerlink" title="✏️view size（coordinate）"></a>✏️view size（coordinate）</h2><blockquote><p>视图大小；表达式输出一个 2D 向量，以给出当前视图的大小（以像素为单位）。<strong>这对于使材质根据当前屏幕分辨率产生各种变化来说非常有用。</strong></p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/viewsize.png" alt="viewsize"></p><ul><li>如示例，按照视图比例，来变换颜色。</li></ul><hr><h2 id="✏️world-position（coordinate）"><a href="#✏️world-position（coordinate）" class="headerlink" title="✏️world position（coordinate）"></a>✏️world position（coordinate）</h2><blockquote><p>全局位置，输出当前像素在全局空间中的位置。</p></blockquote><ul><li>常见用法是确定从摄像机到像素的径向距离，而不是像 PixelDepth（像素深度）那样确定正交距离。WorldPosition（全局位置）也可用作纹理坐标，并让不相关的网格在它们彼此邻近时进行纹理坐标匹配。以下是使用 WorldPosition.xy 对纹理进行二维贴图的基本示例：</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/world-position-planar.jpg" alt="world-position-planar"></li></ul><hr><p>wtf is material 全篇到这里就结束了，这一遍看的很粗略，不过收益很多！还会持续学习！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UE4-虚幻引擎材质节点以及蓝图的学习&quot;&gt;&lt;a href=&quot;#UE4-虚幻引擎材质节点以及蓝图的学习&quot; class=&quot;headerlink&quot; title=&quot;UE4_虚幻引擎材质节点以及蓝图的学习&quot;&gt;&lt;/a&gt;UE4_虚幻引擎材质节点以及蓝图的学习&lt;/h1&gt;&lt;bloc</summary>
      
    
    
    
    <category term="-UE4" scheme="http://example.com/categories/UE4/"/>
    
    
    <category term="-材质" scheme="http://example.com/tags/%E6%9D%90%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释</title>
    <link href="http://example.com/2022/10/08/math_Essense_of_Linear_Algebra_P12/"/>
    <id>http://example.com/2022/10/08/math_Essense_of_Linear_Algebra_P12/</id>
    <published>2022-10-08T09:15:35.000Z</published>
    <updated>2022-10-09T13:01:00.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释"><a href="#3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释" class="headerlink" title="3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释"></a>3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十二章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>《<strong>线代本质》的内容在我的第十一章的笔记就是完结篇，这篇第十二章《克莱姆法则，几何解释》由于官方账号发在一起了，所以我也当作这个系列一起写了</strong></li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️克莱姆法则，几何解释："><a href="#✏️克莱姆法则，几何解释：" class="headerlink" title="✏️克莱姆法则，几何解释："></a>✏️克莱姆法则，几何解释：</h2><h3 id="✍️克莱姆法则以及背后的几何原理："><a href="#✍️克莱姆法则以及背后的几何原理：" class="headerlink" title="✍️克莱姆法则以及背后的几何原理："></a>✍️克莱姆法则以及背后的几何原理：</h3><ul><li><strong>克莱姆法则是线性代数中一个关于求解线性方程组的定理。它适用于变量和方程数目相等的线性方程组。</strong></li><li>克莱姆法则并不是计算线性方程组最好的方法，比如高斯消元法（Gaussian Elimination）会算的更快。这一部分内容就可以当作是扩展视野，它会帮你加深对线性方程组的理解。</li><li>在知道了这方面的知识后，你就会发现行列式或者线性方程组，这些知识都非常相关。</li><li><strong>举例来说：这里有x和y两个未知数和两个方程，原则上来说，只要未知数和方程个数一样，我们所说的都适用。</strong></li><li><strong>目前，我们将只讨论非零行列式的情况。这意味着线性变换后不改变维数。每个输入向量有且仅有一个输出向量；且每一个输出向量也仅对应一个输入向量。</strong></li></ul><hr><h3 id="✍️正交变换（Orthonormal）："><a href="#✍️正交变换（Orthonormal）：" class="headerlink" title="✍️正交变换（Orthonormal）："></a>✍️正交变换（Orthonormal）：</h3><ul><li>那些不改变点积的矩阵变换有一个特殊的名字：“正交变换”（Orthonormal）。它们使基向量在变化后依然保持单位长度且互相垂直。</li><li>可以想象成是旋转矩阵，相当于刚体运动，没有拉伸，压缩或者变形。</li><li>用正交矩阵来求解线性系统非常简单，因为点积保持不变，所以已知的输出向量和矩阵的列向量的点积，分别等同于未知输入向量和各个基向量的点积。也就是输入向量的每一个坐标。</li><li>因此，在特殊情况下，x等于第一列向量已知向量的点积，y等于第二列向量与已知向量的点积。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%AD%A3%E4%BA%A4%E5%8F%98%E6%8D%A2.png" alt="正交变换"></li><li>注意：这个思路对于大多数线性方程组都不成立，但是他给了我们一个方向去思考：有没有另一种对输入向量坐标值的几何解释，能在矩阵变换后保持不变呢？</li></ul><hr><h4 id="在二维空间中："><a href="#在二维空间中：" class="headerlink" title="在二维空间中："></a>在二维空间中：</h4><ul><li>如果逆非常熟悉行列式，你可能会想到一个很棒的想法：这个由第一个基向量i和位置的输入向量[x；y]组成的平行四边形；面积是长度为1的底，乘上与底边垂直的高（也就是输入向量y的坐标值）。</li><li>因此，我们拐了一个弯，用这个平行四边形的面积来表示y值。</li><li>更准确的说，你应该考虑这个平行四边形的有向面积。如下图所示。</li><li>正如行列式的那样，如果向量y的坐标为负，那么四边形的面积也为负。前提是你把基向量i放在第一位来定义平行四边形。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF.png" alt="平行四边形的有向面积"></li><li>同样，观察由未知的输入向量和第二基向量j组成的平行四边形；它的面积等于向量的x坐标。</li><li>用这种方式表示x的值也有点奇怪。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%BB%A5j%E4%B8%BA%E5%BA%95%EF%BC%89.png" alt="平行四边形的有向面积（以j为底）"></li></ul><hr><h4 id="在三维空间中："><a href="#在三维空间中：" class="headerlink" title="在三维空间中："></a>在三维空间中：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%85%AD%E9%9D%A2%E4%BD%93%E9%9D%A2%E7%A7%AF.png" alt="平行六面体面积"></p><ul><li>考虑向量与另外两个基向量i和j所组成的平行六面体，底面是由基向量i和j组成的正方形，面积是1；所以他的体积等于它的高，也就是我们这个向量的z坐标。</li><li>同样的，用这个奇怪的方法来描述向量在某一个轴上的坐标值，可以先考虑向量，和除了这个轴紫外的两个基向量组成的平行六面体。然后其体积就是对应的坐标值。</li><li>另外，我们可以讨论平行六面体的有向体积，就是之前在行列式中提到过的右手法则。这时，你列出的这三个向量的顺序就很重要了。这样就表明坐标的正负性也是有意义的。</li></ul><hr><h3 id="✍️将坐标值和面积或体积联系起来的意义："><a href="#✍️将坐标值和面积或体积联系起来的意义：" class="headerlink" title="✍️将坐标值和面积或体积联系起来的意义："></a>✍️将坐标值和面积或体积联系起来的意义：</h3><ul><li>因为当你做矩阵变换后，平行四边形的面积不一定保持不变，可能成比例的增大或减小。但是，所有面积伸缩的比例都是一样的，都等于给定变换矩阵的行列式。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%89%80%E6%9C%89%E9%9D%A2%E7%A7%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E6%AF%94%E4%BE%8B%E9%83%BD%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%88%97%E5%BC%8F.png" alt="所有面积伸缩的比例都等于给定行列式"></li><li>考虑一个新的平行四边形；第一条边是变换后的第一基向量（也就是矩阵的第一列）；第二条边是变换后的[x,y]，那它的面积是多大呢？</li><li>其实这就是我们之前提及的平行四边形的变换。变换前，面积是未知输入向量的y坐标值，所以变换后的面积等于矩阵的行列式乘以y值。</li><li>所以可以用输出的平行四边形面积除以矩阵的行列式计算出y。既然我们已知最终变换后的向量，那么可以构造一个新矩阵，第一列和我们原先的矩阵相同，而第二列是输出向量，然后取新矩阵的行列式。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B0%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt="新平行四边形面积"></li><li>我们只需使用到变换后的两个向量，也就是矩阵的列向量和已知输出向量，就能计算出位置输入向量的y值，此时方程已经解好一半了。</li><li>我们可以用相同的方法得出x值。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B0%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF_x.png" alt="新平行四边形面积_x"></li><li><strong>这个线性方程组的解法，被称为克莱姆法则。</strong></li><li>三维或者多维的计算结果也基本如此。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第十二章：克莱姆法则，几何解</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第十一章：抽象向量空间</title>
    <link href="http://example.com/2022/10/07/math_Essense_of_Linear_Algebra_P11/"/>
    <id>http://example.com/2022/10/07/math_Essense_of_Linear_Algebra_P11/</id>
    <published>2022-10-07T09:15:35.000Z</published>
    <updated>2022-10-08T09:25:44.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第十一章：抽象向量空间"><a href="#3Blue1Brown-线代本质第十一章：抽象向量空间" class="headerlink" title="3Blue1Brown_线代本质第十一章：抽象向量空间"></a>3Blue1Brown_线代本质第十一章：抽象向量空间</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十一章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>《<strong>线代本质》的内容这一章其实就是完结啦！！！下一章是《克莱姆法则，几何解释》，由于官方账号发在一起了，所以我会把下一章一起当作这个系列的笔记写在一起，所以下一章是第十二章！</strong></li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️抽象向量空间："><a href="#✏️抽象向量空间：" class="headerlink" title="✏️抽象向量空间："></a>✏️抽象向量空间：</h2><h3 id="✍️再来想想什么是向量："><a href="#✍️再来想想什么是向量：" class="headerlink" title="✍️再来想想什么是向量："></a>✍️再来想想什么是向量：</h3><ul><li><strong>坐标的描述是相对随意的，因为这完全依赖于我们所选定的坐标系</strong>。</li><li>行列式告诉你的是一个变换对面积的缩放比例；特征向量则是在变换中留在它所张成的空间中的向量。这二者都是暗含于空间中的性质，可以自由选取坐标系，这并不会改变它们最根本的值。所以：<strong>行列式和特征向量与所选坐标系无关</strong>。</li><li>但是，<strong>如果向量根本并不是由一组实数构成，它们的本质更具空间性；那么此时，数学中所说的“空间”（space）或“空间性”（spatial）究竟表示什么？</strong></li><li>所以，我们应当考虑一种：<ul><li><strong>既不是一个箭头，也不是一组数字，但是同样具有向量特征的东西</strong>。</li></ul></li></ul><hr><h2 id="✏️函数（function）："><a href="#✏️函数（function）：" class="headerlink" title="✏️函数（function）："></a>✏️函数（function）：</h2><h3 id="✍️函数与向量"><a href="#✍️函数与向量" class="headerlink" title="✍️函数与向量"></a>✍️函数与向量</h3><ul><li><strong>从某种意义上说，函数实际上只是另一种向量</strong>；<ul><li>类比两个向量相加的方法，我们也可以将两个函数f和g相加，从而获得一个新的函数（f+g），这种方式是合理的。如下图所示。</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%8A%A0.png" alt="函数相加"></p><ul><li>这个新函数在任意一点处的值，比如在-4的值，就是f和g在这一点处的值的和。</li><li>具体一点说，这个和函数在任意一点x处的值（f+g）（x）等于f（x）加上g（x）。</li><li>这和向量对应坐标相加十分相似；只不过某种程度上来说，它有无穷多个坐标要相加。如下图所示。</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F.png" alt="函数与向量"></p><hr><h3 id="✍️函数与实数："><a href="#✍️函数与实数：" class="headerlink" title="✍️函数与实数："></a>✍️函数与实数：</h3><ul><li>类似的，<strong>函数与一个实属相乘也有着合理的解释</strong>：<ul><li>我们只是把输出的值与那个数相乘。如下图所示</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E6%95%B0%E7%9B%B8%E4%B9%98.png" alt="函数与实数相乘"></p><ul><li>这再次和向量对应坐标数乘类似。如下图所示</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E6%95%B0%E4%B9%98.png" alt="函数与向量数乘"></p><hr><h3 id="✍️应用向量的特征到函数："><a href="#✍️应用向量的特征到函数：" class="headerlink" title="✍️应用向量的特征到函数："></a>✍️应用向量的特征到函数：</h3><ul><li><strong>因为对向量所能进行的操作不过向量相加和数乘两种，所以，最初以空间中的箭头为背景考虑的线性代数的合理概念和解决问题的手段，应该能原封不动地被我们取出来，然后应用于函数。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E7%89%B9%E5%BE%81%E5%BA%94%E7%94%A8%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%AD.png" alt="向量特征应用到函数中"></li><li>举个例子， 函数到线性变换有一个完全合理的解释，这个变换接受一个函数，并把它变成另一个函数；从微积分中可以找到一个常见的例子————导数。他将一个函数变换到另一个函数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E5%8F%98%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0.png" alt="函数变为另一个函数"></li><li>有时你听到的是“算子”（线性算子，“Linear operator”）而不是“变换”，它们是一样的。</li></ul><hr><h3 id="✍️“一个函数变换是线性的”是什么意思？"><a href="#✍️“一个函数变换是线性的”是什么意思？" class="headerlink" title="✍️“一个函数变换是线性的”是什么意思？"></a>✍️“一个函数变换是线性的”是什么意思？</h3><ul><li>线性的严格定义是相对抽象而且符号繁重的；但是，抽象性带来的好处是我们能得到一般性的结论，它不仅适用于箭头，也适用于函数。</li><li>满足以下两条性质的变换是线性的：<ol><li><strong>可加性（Additivity）</strong><ul><li>可加性意味着如果你把两个向量v和w相加，然后对它们的和应用变换，得到的结果和将变换后的v与变换后的w相加一致。</li></ul></li><li><strong>成比例（一阶齐次）（Scaling）</strong><ul><li>成比例是说，你讲一个向量v与某个数相乘，然后应用变换，得到的结果和变化后的v与这个数相乘一致。</li></ul></li></ol></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89.png" alt="线性的严格定义"></p><ul><li>你经常会听到一种描述方法是：<strong>“线性变换保持向量加法运算和数乘运算”</strong></li><li>这两条性质的一个最重要的推论就是：<strong>一个线性变换可以通过它对基向量的作用来完全描述，这使得矩阵向量乘法成为可能</strong>。因为任一向量都能表达为基向量以某种方式进行的线性组合，所以求一个向量变换后的结果，实际上就是求出变换后的基向量以相同方式进行线性组合的结果。</li><li>这就跟箭头一样，这一点对函数来说同样正确。</li></ul><h4 id="求导（Derivative）是线性运算："><a href="#求导（Derivative）是线性运算：" class="headerlink" title="求导（Derivative）是线性运算："></a>求导（Derivative）是线性运算：</h4><ul><li>举个例子：<ul><li><strong>求导（Derivative）是线性运算。</strong></li><li>如果你把两个函数相加，然后求导数；等同于先求两个函数的导数，然后把结果相加。</li><li>类似的，如果你将函数与数相乘，然后求导数；等同先求导数，然后把结果相乘。</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%B1%82%E5%AF%BC%E6%98%AF%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97.png" alt="求导是线性运算"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%B1%82%E5%AF%BC%E6%98%AF%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_02.png" alt="求导是线性运算_02"></p><hr><h2 id="✏️用矩阵来描述求导："><a href="#✏️用矩阵来描述求导：" class="headerlink" title="✏️用矩阵来描述求导："></a>✏️用矩阵来描述求导：</h2><blockquote><p>这可能有些棘手，因为函数空间倾向于有无穷维。</p></blockquote><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F.png" alt="空间内的多项式"></p><ul><li>我们现在把目光限制在多项式空间上，如上图，有几个多项式。虽然这个空间中每一个多项式都只有有限项，但整个空间应该包含任意高次的多项式。</li><li>首先我们要做的是给这个空间赋予坐标的含义，这需要选取一个基。</li><li>因为多项式已经是数乘x的不同次幂再做加和的形式，所以我们很自然就可以去x的不同次幂作为<strong>基函数（basis function）</strong>。换句话说，第一个基函数就是一个常函数，即b0（x）&#x3D;1；第二个基函数是b1（x）&#x3D;x；第三个基函数是b2（x）&#x3D;x^2；依此类推。</li><li>基函数在这里起到的作用，和i帽，j帽，k帽在向量的世界中起到的作用类似。</li><li>因为多项式的次数可以任意高，所以这个基函数集也是无穷大的。</li></ul><hr><ul><li><strong>如下图</strong>，取出多项式的坐标，然后把它放在矩阵的右侧。对结果的第一个坐标有贡献的只有1乘以4这一项，也就是说结果的常数项是4。这对应用于4x的导数是常数4.</li><li>对矩阵向量乘积的第二个坐标有贡献的只有2乘以5这一项，也就是说结果中x前的系数是10。</li><li>与之相似的，矩阵向量乘积的第三个坐标就是3乘以1，这对应于x^3 的导数是 3x^2。</li><li>在此之后的坐标都是0。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5.png" alt="空间内的多项式对应矩阵"></li><li>求导满足线性性质是这一过程成为可能。</li></ul><hr><h3 id="✍️线代和函数中概念之间的关联"><a href="#✍️线代和函数中概念之间的关联" class="headerlink" title="✍️线代和函数中概念之间的关联"></a>✍️线代和函数中概念之间的关联</h3><ul><li>矩阵向量乘法看起来好像跟求导毫不相干，但是它们其实是一家人。我们提到的许多线性代数的概念，在函数中都能找到对应的别名。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E4%BB%A3%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E8%81%94.png" alt="线代和函数的关联"></li></ul><hr><h2 id="✏️公理（Axioms）："><a href="#✏️公理（Axioms）：" class="headerlink" title="✏️公理（Axioms）："></a>✏️公理（Axioms）：</h2><h3 id="✍️上述提到的与向量有什么关系？："><a href="#✍️上述提到的与向量有什么关系？：" class="headerlink" title="✍️上述提到的与向量有什么关系？："></a>✍️上述提到的与向量有什么关系？：</h3><ul><li><strong>数学中有很多类似向量的事物，只要你处理的对象集具有合理的数乘和相加的概念，不管是空间中的箭头，一组数，函数的集合，还是自定义的其他奇怪东西的集合；线性代数中所有关于向量，线性变换和其他概念都应该适用于它。</strong></li><li>这些类似向量的事物，它们构成的集合被称为“向量空间”。</li><li>为了这些构想出来的向量空间合理，<strong>我们需要做的是建立一系列向量加法和数乘必须遵守的规则</strong>，如下：<blockquote><ol><li>向量加法满足结合律</li><li>向量加法满足交换律</li><li>向量加法的单位元存在</li><li>每个向量的加法逆元均存在</li><li>标量乘法与标量的域乘法相容</li><li>标量乘法的单位元纯真</li><li>标量乘法对向量加法满足分配律</li><li>标量乘法对域加法满足分配律</li></ol></blockquote></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E4%B9%98%E7%9A%84%E8%A7%84%E5%88%99.png" alt="向量加法和数乘的规则"></p><ul><li><strong>如上所述，这些规则被称为“公理”（Axioms）。</strong></li><li>在线性代数的现代理论中，如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足上述的八条公理。</li><li>不过这些实际上就是一个清单，用来保证向量加法和数乘的概念确实是你所希望的那样。</li></ul><h3 id="✍️公理的作用："><a href="#✍️公理的作用：" class="headerlink" title="✍️公理的作用："></a>✍️公理的作用：</h3><ul><li><strong>这些公理并非基础的自然法则，它们是一个媒介（interface）</strong>；也就是发现这些结论的数学家一边连接着你，一边也连接着其他的人，也就是想要把这些结论应用于新的向量空间的人。</li><li>有了这些公理，我们只需要根据这些公理去证明你的结论就可以了。只要其他人的定义满足这些公理，他们就能顺利的应用你的结论。</li><li>因此，你往往会把你所有的结论抽象的表述出来；也就是说仅仅根据这些公理表述，而不是集中于某一种特定的向量上，像是空间中的箭头或者函数等。</li><li>简而言之，这就是每一本教科书都会根据可加性和成比例性来定义线性变换，而不是用我们之前看到的“网格线保持平行且等距分布来”来定义。</li><li>所以，只要遵守上述“公理”的东西，都可以被定义为向量。</li></ul><hr><h2 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h2><p><strong>《线代本质》的内容这一章其实就是完结啦！！！下一章是《克莱姆法则，几何解释》，由于官方账号发在一起了，所以我会把下一章一起当作这个系列的笔记写在一起，所以下一章是第十二章！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第十一章：抽象向量空间&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第十一章：抽象向量空间&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第十一章：抽象向量空间&quot;&gt;&lt;/a&gt;3Blue</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第十章：特征向量与特征值</title>
    <link href="http://example.com/2022/10/06/math_Essense_of_Linear_Algebra_P10/"/>
    <id>http://example.com/2022/10/06/math_Essense_of_Linear_Algebra_P10/</id>
    <published>2022-10-06T09:15:35.000Z</published>
    <updated>2022-10-07T12:28:45.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第十章：特征向量与特征值"><a href="#3Blue1Brown-线代本质第十章：特征向量与特征值" class="headerlink" title="3Blue1Brown_线代本质第十章：特征向量与特征值"></a>3Blue1Brown_线代本质第十章：特征向量与特征值</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️特征向量与特征值（Eigenvectors-and-Eigenvalues）："><a href="#✏️特征向量与特征值（Eigenvectors-and-Eigenvalues）：" class="headerlink" title="✏️特征向量与特征值（Eigenvectors and Eigenvalues）："></a>✏️特征向量与特征值（Eigenvectors and Eigenvalues）：</h2><h3 id="✍️举例描述："><a href="#✍️举例描述：" class="headerlink" title="✍️举例描述："></a>✍️举例描述：</h3><ul><li>首先，考虑二维空间中的某个线性变换，它将基向量i帽变换到坐标（3，0），j帽变换到坐标（1，2）。 我们关注它对一个特定向量的作用，并且考虑这个向量张成的空间，也就是通过原点和向量尖端的直线。大部分向量在变换中都离开了其张成的空间，意思是如果向量正好落在这条直线上，感觉更像是巧合。不过，某些特殊向量的确留在它们张成的空间里，与i围着矩阵对他的作用仅仅是拉伸或者压缩而已，如同一个标量。</li><li>在上文提到的变换中，基向量i帽就是这样一个特殊向量；i帽张成的空间是x轴，从矩阵的第一列看出，i帽变成了原来的三倍，但任然留在x轴上。</li><li>此外因为线性变换的性质，x轴上的任何其他向量都只是被拉伸为原来的三倍，因此也就留在它们张成的空间里。</li><li>有一个略显隐蔽的向量（-1，1），它在变换中也留在自己张成的空间里；它最终被拉伸为原来的两倍。同上，线性性质暗示着一点，处在他所张成的对角线上的其他任何一个向量也仅仅被拉伸为原来的两倍。</li><li>对这个变换而言，以上就是所拥有这一特殊性质（留在它们张成的空间里）的向量。x轴上的向量被拉伸为原来的三倍，而对角线上的向量被拉伸为原来的两倍。任何其他向量在变换中都有或多或少的旋转，从而离开它张成的直线。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_01.png" alt="特征向量_01"></li><li><strong>这些特殊的向量就被称为变换的“特征向量”；每个特征向量都有一个所属的值，被称为“特征值”，即衡量特征向量在变换中拉伸或压缩比例的因子。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_02.png" alt="特征向量_02"></li></ul><hr><h3 id="✍️特征值可以为负吗？："><a href="#✍️特征值可以为负吗？：" class="headerlink" title="✍️特征值可以为负吗？："></a>✍️特征值可以为负吗？：</h3><ul><li>可以，并且与特征值为正的情况下并无差别。</li><li>举个例子，你有一个特征值-1&#x2F;2的特征向量，意味着这给个向量被反向，并且被压缩成原来的一半。但是重点在于，它停留在它张成的直线上，并未发生旋转。</li><li>考虑一个三维空间中的旋转，如果你能找到这个旋转的特征向量，也就是留在他张成空间里的向量，那么你找到的就是旋转轴（axis of rotation）。而且把一个三维旋转看成绕某个轴旋转一定角度，要比考虑相应的3x3矩阵直观的多。顺带一提，在这种情况下，相应的特征值必须为1，因为旋转并不缩放任何一个向量，所以向量的长度保持不变。</li><li>对于任意矩阵描述的线性变换，你可以通过将矩阵的列看作变换后的基向量来理解它。但是理解线性变换作用的关键往往是较少依赖于你的特定坐标系；更好的方法是求出它的特征向量和特征值。</li></ul><hr><h3 id="✍️计算思想："><a href="#✍️计算思想：" class="headerlink" title="✍️计算思想："></a>✍️计算思想：</h3><ul><li>用符号表示的话，下图所示就是特征向量的概念。A是代表某个变换的矩阵，v是特征向量；λ（lambda）是一个数，也就是对应的特征值。</li><li>这个等式也就是说：矩阵向量乘积，也就是A乘以v，等于特征向量v乘以某个数λ。</li><li>因此求解矩阵A的特征向量和特征值，实际上就是求解使得这个等式成立的向量v和数λ。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_01.png" alt="特征向量_计算_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_02.png" alt="特征向量_计算_02"></li><li>等号左侧代表的是矩阵向量乘积，但是等号右侧代表的是向量数乘。所以我们首先将等号右侧重写为某个矩阵向量乘积，其中，矩阵的作用效果是将任一向量乘以λ；这个矩阵的列代表着变换后的基向量，而每个基向量仅仅与λ相乘。所以这个矩阵的对角元素均为λ，而其余位置都是0。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_03.png" alt="特征向量_计算_03"></li><li>通常的书写方式是提出因子λ，写作λ乘以I，这里的I就是单位矩阵，对角元均为1；现在两侧就都是矩阵向量乘积的形式。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_04.png" alt="特征向量_计算_04"></li></ul><hr><ul><li>如下图所示，此时，我们就能将等号右侧的东西移到左侧，然后提出因子v。现在我们得到的是一个新的矩阵：A减去λ乘以单位矩阵。我们就寻找一个向量v，使得这个新矩阵与v相乘结果为零向量。如果v本身就是零向量的话，这个等式恒成立，但这没什么意思，因为我们希望的是一个非零特征向量；所以我们寻找的是一个det（A-λI）&#x3D; 0 的情况。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_05.png" alt="特征向量_计算_05"></li><li>所以，<strong>空间压缩，对应的就是矩阵的行列式为零的情况</strong>。举个例子，假设你有一个矩阵，列为（2，1）和（2，3），考虑每个对角元都减去某个变量λ；然后逐渐调整λ的值，当λ的值改变时，矩阵本身发生改变，因此行列式也在改变。目标在于找到一个λ使得这个行列式为零。也就是说调整后的变换将空间压缩到一个更低的维度上。在这个列子中，λ等于1时恰到好处。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_06.png" alt="特征向量_计算_06"></li><li>当然，如果选择其他矩阵，那特征值不一定是1，λ就需要取其他的值来使行列式为零。</li><li>当λ等于1时，A减去λ乘以单位矩阵将空间压缩到一条直线上，这意味着存在一个非零向量v，使得A减去λ乘以单位矩阵的结果乘以v等于零向量。记住一点就是：我们关注它是因为它意味着A乘以v等于λ乘以v。也就是说向量v是A的一个特征向量，在变换中停留在它张成的空间里。</li><li>在上述的例子中，v对应的特征值是1，所以它实际上保持不变。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_07.png" alt="特征向量_计算_07"></li></ul><hr><h4 id="二维线性变换不一定有特征向量："><a href="#二维线性变换不一定有特征向量：" class="headerlink" title="二维线性变换不一定有特征向量："></a>二维线性变换不一定有特征向量：</h4><ul><li>举例来说，想象一个90度旋转，它并没有特征向量，因为每一个向量都发生了旋转并离开了其张成的空间。</li></ul><h4 id="只有一个特征值，但是特征向量不止在一条直线上："><a href="#只有一个特征值，但是特征向量不止在一条直线上：" class="headerlink" title="只有一个特征值，但是特征向量不止在一条直线上："></a>只有一个特征值，但是特征向量不止在一条直线上：</h4><ul><li>一个简单的例子：将所有向量变为两倍的矩阵，唯一的特征值是2，但是平面内每一个向量都是属于这个特征值的特征向量。</li></ul><hr><h2 id="✏️特征基（Eigenbasis）："><a href="#✏️特征基（Eigenbasis）：" class="headerlink" title="✏️特征基（Eigenbasis）："></a>✏️特征基（Eigenbasis）：</h2><h4 id="如果基向量恰好是特征向量，会发生什么？"><a href="#如果基向量恰好是特征向量，会发生什么？" class="headerlink" title="如果基向量恰好是特征向量，会发生什么？"></a>如果基向量恰好是特征向量，会发生什么？</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%9F%BA_01.png" alt="特征基_01"></p><ul><li>如上图所示，比如说，可能i帽变为原来的（-1）倍，j帽变为原来的2倍；将它们的新坐标作为矩阵的列，注意它们的倍数-1和2，也就是i帽和j帽所属的特征值，位于矩阵的对角线上，而其他的元素均为0。</li><li>除了对角元素以外其他元素均为0的矩阵被称为<strong>对角矩阵</strong>（Diagonal Matrix）。解读它的方法是，所有的基向量都是特征向量。矩阵的对角元是它们所属的特征值。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5.png" alt="对角矩阵"></li><li>对角矩阵在很多方面都更容易处理，其中一个重要方面是，矩阵与自己多次相乘的结果更容易计算；因为对角矩阵仅仅让基向量与某个特征值相乘，所以多次应用矩阵乘法，比如一百次，也只是将每个基向量与对应特征值的一百次幂相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="对角矩阵乘法"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95_02.png" alt="对角矩阵乘法_02"></li><li>相比之下，尝试计算一个非对角矩阵的一百次幂，就很不容易。</li></ul><hr><ul><li>我们知道了特征向量的计算更为简便，所以可以通过变换坐标系，使得特征向量就是基向量，并用特征向量作为基。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5_01.png" alt="基变换矩阵_01"></li><li>取出你想用做新基的向量的坐标，在这里指的是两个特征向量，然后将坐标作为一个矩阵的列，这个矩阵就是<strong>基变换矩阵</strong>，在右侧写下基变换矩阵，在左侧写下基变换矩阵的逆，当你将原始的变换夹在两个矩阵中间时，所得的矩阵代表队是同一个变换，不过是从新基向量所构成的坐标系的角度来看的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5_02.png" alt="基变换矩阵_02"></li><li>用特征向量来完成这件事的意义在于，这个新矩必然是对角的，并且对角元为对应的特征值。这是因为，他所处的坐标系的基向量在变换中只进行了缩放。</li><li><strong>一组基向量（同样是特征向量）构成的集合被称为一组“特征基”</strong>，这也非常合理。</li><li>所以说，如果你要计算这个矩阵的一百次幂，一种更容易的做法是先变换到特征基，在那个坐标系中计算一百次幂之后，再转换回标准坐标系。</li></ul><h3 id="✍️并非所有矩阵都可以对角化"><a href="#✍️并非所有矩阵都可以对角化" class="headerlink" title="✍️并非所有矩阵都可以对角化"></a>✍️并非所有矩阵都可以对角化</h3><ul><li>切记，并不是所有变换都能进行这一过程，并非所有矩阵都可以对角化。</li><li>比如剪切变换，它的特征向量不够多，并不能张成全空间。</li><li>如果你能找到一组特征基（能张成全空间的特征向量），矩阵运算就会变得非常轻松。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第十章：特征向量与特征值&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第十章：特征向量与特征值&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第十章：特征向量与特征值&quot;&gt;&lt;/a&gt;3B</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第八章：叉积的标准介绍</title>
    <link href="http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P08/"/>
    <id>http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P08/</id>
    <published>2022-10-03T09:15:35.000Z</published>
    <updated>2022-10-04T10:07:16.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第八章：叉积的标准介绍"><a href="#3Blue1Brown-线代本质第八章：叉积的标准介绍" class="headerlink" title="3Blue1Brown_线代本质第八章：叉积的标准介绍"></a>3Blue1Brown_线代本质第八章：叉积的标准介绍</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第八章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><blockquote><p>【注：此篇为第八章第一部分《叉积的标准介绍》和第二部分《以线性变换的眼光看叉积》的集合】</p></blockquote><hr><h2 id="✏️叉积（cross-product）："><a href="#✏️叉积（cross-product）：" class="headerlink" title="✏️叉积（cross product）："></a>✏️叉积（cross product）：</h2><h3 id="✍️基本理解（非严格意义上的叉乘）："><a href="#✍️基本理解（非严格意义上的叉乘）：" class="headerlink" title="✍️基本理解（非严格意义上的叉乘）："></a>✍️基本理解（非严格意义上的叉乘）：</h3><ul><li>从平面空间说起，加入有两个向量v和w，考虑他们所张成的平行四边形，v和w的叉积v X w 其实就是这个平行四边形的面积。</li><li>当然我们还要考虑定向问题；如果v在w的右侧，那么v叉乘w为正；并且值等于平行四边形的面积。如果v在w的左侧，那么v叉乘w为负。这就是说顺序会对叉积有影响。</li><li>如果你不计算w叉乘v，而是交换二者位置计算，那么叉积就是之前计算结果的相反数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="叉积平面空间"></li><li>记住顺序的方法是：当你按顺序求两个基向量的叉积，即i帽叉乘j帽，结果应该是正的。基向量的顺序就是定向的基础，因为i帽在j帽的右侧。同理运用到v和w上一样如此，v在w右侧，结果为正；反之为负。</li><li>举例如下图，如果v的坐标为（-3，1），w的坐标为（2，1），以他们的坐标为列构成的行列式为（（-3）*1—） - （2 * 1），也就是-5。很显然，他们构成的平行四边形的面积为5；但v在w左侧，所以行列式结果为-5。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%A4%BA%E4%BE%8B%E4%B8%80.png" alt="第八章示例一"></li><li>如果两个向量垂直，或接近垂直，和他们指向接近时相比，此时的叉积更大。所以当两个向量接近通向时，他们的叉积更小。因为两条边接近垂直的时候，平行四边形的面积会更大。</li><li>如果放大其中的一个向量，比如将v放大为3倍，那么平行四边形的面积也放大三倍。这也就是说，3v叉乘w正好是v叉乘w的三倍。</li></ul><hr><h3 id="✍️严格意义上的叉乘："><a href="#✍️严格意义上的叉乘：" class="headerlink" title="✍️严格意义上的叉乘："></a>✍️严格意义上的叉乘：</h3><ul><li>通过两个三维向量，生成一个新的三维向量。</li><li>我们还是要考虑这两个向量围成的平行四边形，而这个平行四边形的面积依然会发挥着重要的作用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E7%9A%84%E5%9F%BA%E7%A1%80.png" alt="叉积的基础"></li><li>但是此时，叉积的结果应当是一个向量，所以就不能单纯用它的面积这个数来理解。<strong>这个向量的长度是这个平行四边形的面积，而这个向量的方向与平行四边形所在的面垂直</strong>。</li></ul><h4 id="叉积的方向："><a href="#叉积的方向：" class="headerlink" title="叉积的方向："></a>叉积的方向：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%88%99.png" alt="右手定则"></p><ul><li>因为长度为这个平行四边形面积并垂直于给定面的向量一共有两个，且方向相反，这里就需要用<strong>右手定则</strong>：<strong>右手食指指向v的方向，中指指向w的方向，当你把大拇指竖起来的方向，他所指的方向就是叉积的方向。</strong></li></ul><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E4%B9%98%E7%9A%84%E4%B8%89%E9%98%B6%E8%BF%90%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="叉乘的三阶运算公式"></p><ul><li>这样计算并非巧合。</li></ul><hr><h2 id="✏️以线性变换的眼光看叉积："><a href="#✏️以线性变换的眼光看叉积：" class="headerlink" title="✏️以线性变换的眼光看叉积："></a>✏️以线性变换的眼光看叉积：</h2><h3 id="✍️推理过程："><a href="#✍️推理过程：" class="headerlink" title="✍️推理过程："></a>✍️推理过程：</h3><ul><li>对偶性的思想在于：每当你看见一个多维空间到数轴的线性变换时，它都与那个空间中唯一一个向量对应，也就是说应用线性变换和与这个向量点乘等价。数值上说，这是因为这类线性变换可以用一个只有一行的矩阵描述，而它的每一列给出了变换后基向量的位置。将这个矩阵与某个向量v相乘，在计算上与将矩阵转置得到的向量和v点乘相同。</li><li>这里的收获在于，每当你看到一个从空间到数轴的线性变换，你都能找到一个向量，被称为这个变换的对偶向量。使得应用线性变换和对偶向量点乘等价。</li><li>叉积的运算给出了此过程一个鲜活的实例。</li></ul><h3 id="✍️关于叉积的证明计划："><a href="#✍️关于叉积的证明计划：" class="headerlink" title="✍️关于叉积的证明计划："></a>✍️关于叉积的证明计划：</h3><ol><li>根据v和w定义一个三维到一维的线性变换。</li><li>找到它的对偶向量。</li><li>这个对偶向量就会是v和w的叉积。</li></ol><ul><li>理解线性变换能够解释清楚叉积的计算过程和几何含义之间的关系。</li><li><strong>真正的三维向量的叉积接受两个向量并输出一个向量</strong>，它并不是接收三个向量并输出一个数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF.png" alt="以线性变换看待叉积"></li><li>如上图所示，将第一个向量u看作可变向量，比如（x，y，z），而v和w保持不变；那么我们就有一个从三维空间到数轴的函数了。你输入一个向量（x，y，z），然后通过矩阵的行列式得到一个数。这个向量的第一列是（x，y，z），其余的两列是常向量v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_02.png" alt="以线性变换看待叉积_02"></li><li>这个函数的几何意义是，对于任一输入的向量（x，y，z），你都考虑由它和v与w确定的平行六面体得到它的体积，然后根据定向确定符号。</li></ul><h3 id="但是这个函数从哪里来，为什么会这么计算？"><a href="#但是这个函数从哪里来，为什么会这么计算？" class="headerlink" title="但是这个函数从哪里来，为什么会这么计算？"></a><strong>但是这个函数从哪里来，为什么会这么计算？</strong></h3><ul><li>这个函数一个至关重要的性质就是它是线性的，因此可以引入对偶性的特性。</li><li>因为它是线性的，我们就知道可以通过矩阵乘法来描述这个函数；具体的说，因为这个函数从三维空间到一维空间，就会存在一个1x3矩阵来代表这个变换。而对偶性的整体思路是从多维空间到一维空间的变换的特别之处在于你可以把这个矩阵立起来并且将整个变换看作与这个特定向量的点积。</li><li>如下图所示，我们要找的就是这个特殊的三维向量，现在称之为P，使得P与其他任一向量（x，y，z）的点积等于一个3x3矩阵的行列式，这个3x3矩阵的第一列为（x，y，z），其余两列分别为v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_03.png" alt="以线性变换看待叉积_03"></li><li>P与向量（x，y，z）点乘给出的结果以及右侧行列式的计算结果如下图所示：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_04.png" alt="以线性变换看待叉积_04"></li><li>这里某些常数涉及了v和w的坐标的特定组合。因此这些常数，也就是v和w的坐标的特定组合，就是我们寻找到向量P的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_05.png" alt="以线性变换看待叉积_05"></li><li>等号右侧的过程，对于哪些进行过叉积计算的人来说是很熟悉的。</li><li>像这样合并x，y和z前面的常数项，和把i帽，j帽和k帽放进矩阵第一列进行计算，然后合并个项前面的系数没有区别。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_06.png" alt="以线性变换看待叉积_06"></li><li>在矩阵中插入i帽，j帽和k帽在传递一个信号，告诉我们应该把这些系数理解成一个向量坐标。</li><li>因此，这一切都在说明，这个奇怪的运算过程可以看作是以下问题的答案：<ul><li>当你将向量p和某个向量（x，y，z）点乘时，所得的结果等于一个3x3矩阵的行列式，这个矩阵第一列为（x，y，z），其余两列为v和w的坐标。考虑什么样的向量p可以完成这一特殊性质。</li><li>也可以这样说：当年将向量p和某个向量（x，y，z）点乘时，所得结果等于一个由（x，y，z）个v与w确定的平行六面体的邮箱体积，什么样的向量p可以完成这一特殊性质？</li></ul></li><li>记住一点，向量p与其他向量的点积的几何解释是将其他向量投影到p上，然后将投影长度与p的长度相乘。</li><li>根据这点，平行六面体的体积可以这样考虑：首先获得由v和w确定的平行四边形的面积，乘以向量（x，y，z）在垂直于平行四边形方向上的分量。</li><li>换句话说，我们找到线性函数对于给定向量的作用，是将这个向量投影到垂直于v和w的直线上，然后将投影长度于v和w张成的平行四边形的面积相乘。这和垂直于v和w且长度为平行四边形面积的向量与（x，y，z）点乘是同一回事。</li><li>更重要的是，如果你选择了合适的向量方向，点积为正的情况就会与（x，y，z），v和w满足右手定则的情况相吻合。</li><li>这意味着我们找到了一个向量p，使得p与和某个向量（x，y，z）点乘时所得结果等于一个3x3矩阵的行列式；这个矩阵的三列分别为（x，y，z），v的坐标和w的坐标。</li><li>因此我们之前通过特殊符号技巧进行计算所得到的向量必然在几何上与这个向量对应。这激素叉积的计算过程与几何解释有关的根本原因。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_07.png" alt="以线性变换看待叉积_07"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第八章：叉积的标准介绍&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第八章：叉积的标准介绍&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第八章：叉积的标准介绍&quot;&gt;&lt;/a&gt;3Blue</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第九章：基变换</title>
    <link href="http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P09/"/>
    <id>http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P09/</id>
    <published>2022-10-03T09:15:35.000Z</published>
    <updated>2022-10-06T09:46:18.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第九章：基变换"><a href="#3Blue1Brown-线代本质第九章：基变换" class="headerlink" title="3Blue1Brown_线代本质第九章：基变换"></a>3Blue1Brown_线代本质第九章：基变换</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第九章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️基变换："><a href="#✏️基变换：" class="headerlink" title="✏️基变换："></a>✏️基变换：</h2><h3 id="✍️基的选择："><a href="#✍️基的选择：" class="headerlink" title="✍️基的选择："></a>✍️基的选择：</h3><ul><li>发生在向量与一组数之间的任意一种转化，都被称为一个坐标系（coordinate system），而其中两个特殊的向量i帽和j帽，被我们称为这个标准坐标的基向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_01.png" alt="基变换_01"></li><li>如上图所示，如果使用另一组不同的基向量，分别称之为b1和b2，它的第一个基向量b1指向右上方，第二个基向量b2指向左上方。如果在这个变换中，用坐标（5&#x2F;3.1&#x2F;3）来描述它，这意味着，根据他的两个基向量，获得那个向量的方法是b1乘以5&#x2F;3,b2乘以1&#x2F;3,再将两个结果相加。</li><li>总之，无论何时，我们用坐标来描述一个向量，将第一个坐标乘以b1，第二个坐标乘以b2，然后将两者相加，他最终得到的向量 ，会和我们认为的相同坐标的向量完全不同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_02.png" alt="基变换_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_03.png" alt="基变换_03"></li><li>如上图两个向量的表示方法看出，虽然我们都在关注空间中同一个向量，但可以用不同的语言（空间）和数字来描述它，使得结果大不相同。</li><li>如果我们使用普通的坐标系，并用方形网格表示单位，那么<strong>这些网格只是提供了一个可视化坐标系的途径，因此，它依赖我们对基的选择。因为在空间中，本身是没有网格的</strong>。</li><li><strong>如果用不同的方式绘制这个网格，它同样是一个框架，也只不过是有助于用另一种方式理解坐标含义的可视化工具。</strong></li><li>但是无论如何绘制这个网格，<strong>大家的原点总会是在（0，0），因此大家的原点是重合的。</strong> 它就是任何向量乘以0时你所得到的坐标。</li><li>但是，其他方式绘制的坐标轴的方向与网格间距有所不同，这依赖于它对基的选择。</li></ul><hr><h3 id="✍️如何在不同的坐标系之间进行转化？："><a href="#✍️如何在不同的坐标系之间进行转化？：" class="headerlink" title="✍️如何在不同的坐标系之间进行转化？："></a>✍️如何在不同的坐标系之间进行转化？：</h3><ul><li>一旦你将矩阵向量乘法理解为应用一个特定的线性变换，就会有一种非常直观的方法来考虑这里发生的事。</li><li>一个矩阵列为某个特殊的基向量时，这个矩阵可以看作一个线性变换，它将我们的基向量i帽和j帽，也就是我们眼中的（1，0）和（0，1），变换为那个特殊的基向量，也就是特殊被重新定义的（1，0）和（0，1）.</li><li>变换后的向量仍旧时相同的线性组合，不过使用的时新的基向量。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_04.png" alt="基变换_04"></li></ul><hr><h3 id="✍️逆（Inverse）："><a href="#✍️逆（Inverse）：" class="headerlink" title="✍️逆（Inverse）："></a>✍️逆（Inverse）：</h3><ul><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_05.png" alt="基变换_05"></li><li>一个变换的逆是一个新的变换，它将所选的变换逆向进行。实践当中，尤其是在超过二维空间中研究时，你可以用计算机来计算矩阵的逆。</li><li>如果想知道一个矩阵变换的逆，那我们用这个基变换矩阵的逆乘以我们所使用的向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86_01.png" alt="基变换矩阵的逆_01"></li><li>以上就是如何在坐标系之间对单个向量的描述进行相互转化。</li><li>一个矩阵代表的是一个特殊的基向量，却用我们的坐标来描述；对于一个向量，这个矩阵将它的语言描述转化为我们的语言描述。</li><li>逆矩阵则与之相反。</li><li>向量并不是唯一用坐标表示的东西</li></ul><hr><ul><li>考虑某个线性变换，譬如逆时针旋转90度；用矩阵代表它的时候，我们是在跟踪i帽和j帽的去向；i帽变换后坐标是（0，1），j帽变换后坐标是（-1，0）；这些坐标也就成为了矩阵的列。</li><li>但是这种表示与我们对基向量的选择密切相关，因为我们跟踪的是i帽和j帽，并且是在我们自己的坐标系中记录着他们的去向。</li></ul><h3 id="✍️如何转化一个矩阵？："><a href="#✍️如何转化一个矩阵？：" class="headerlink" title="✍️如何转化一个矩阵？："></a>✍️如何转化一个矩阵？：</h3><blockquote><p>注：以下描述的我们的语言是我们使用的语言，代表我们使用的基向量和坐标系；另一种语言表述的变换暂用詹妮弗的语言代替，詹妮弗跟我们使用不同的坐标系和基向量。</p></blockquote><ol><li>我们从詹妮弗的语言描述的任意向量出发。</li><li>首先，我们不用它的语言描述这一过程，而是用基变换矩阵，转化为用我们的语言描述。这个矩阵的列代表是用我们的语言描述她的基向量。此时给出的是同一个向量，只不过是用我们的语言描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_01.png" alt="如何转化一个矩阵_01"></li><li>然后，将所得结果左乘线性变换矩阵；此时给出的是变换后的向量，但仍然是我们的语言来描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_02.png" alt="如何转化一个矩阵_02"></li><li>最后一步，像之前一样将所的结果左乘基变换矩阵的逆，从而得到变换后的向量，然而使用詹妮弗的语言来描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_03.png" alt="如何转化一个矩阵_03"></li></ol><ul><li>因为我们能够对詹妮弗语言描述的任一向量做同样的事情，首先应用基变换，然后应用线性变换，最后应用基变换的逆。这三个矩阵的复合给出的就是用詹妮弗语言买哦书店线性变换矩阵。它接收由詹妮弗语言描述的向量。，并输出用詹妮弗语言描述的变换后的向量。</li><li>所以如果詹妮弗用这个计算结果的矩阵与她坐标系中的一个向量相乘，结果就是在她坐标系中描述该向量旋转90度的结果。</li></ul><hr><h3 id="✍️总结："><a href="#✍️总结：" class="headerlink" title="✍️总结："></a>✍️总结：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E5%AD%A6%E4%B8%8A%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%BD%9C%E7%94%A8.png" alt="数学上的转移作用"></p><ul><li>每当你看到这样一个表达式：A逆乘以M乘以A，这就暗示着一种数学上的转移作用。中间的矩阵代表一种你所见的变换，而外侧两个矩阵代表着转移作用，也就是视角上的转化。矩阵乘积任然代表着同一个变换，只不过是从其他人的角度来看的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第九章：基变换&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第九章：基变换&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第九章：基变换&quot;&gt;&lt;/a&gt;3Blue1Brown_线代本质第</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第七章：点积与对偶性</title>
    <link href="http://example.com/2022/09/29/math_Essense_of_Linear_Algebra_P07/"/>
    <id>http://example.com/2022/09/29/math_Essense_of_Linear_Algebra_P07/</id>
    <published>2022-09-29T09:15:35.000Z</published>
    <updated>2022-09-30T12:48:37.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第七章：点积与对偶性"><a href="#3Blue1Brown-线代本质第七章：点积与对偶性" class="headerlink" title="3Blue1Brown_线代本质第七章：点积与对偶性"></a>3Blue1Brown_线代本质第七章：点积与对偶性</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第七章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️点积（dot-product）："><a href="#✏️点积（dot-product）：" class="headerlink" title="✏️点积（dot product）："></a>✏️点积（dot product）：</h2><h3 id="✍️点积的标准观点："><a href="#✍️点积的标准观点：" class="headerlink" title="✍️点积的标准观点："></a>✍️点积的标准观点：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E7%9A%84%E6%A0%87%E5%87%86%E8%A7%82%E7%82%B9.png" alt="点积的标准观点"></p><ul><li><strong>如果有两个维数相同的向量，或是两个长度相同的数组，求它的点积，就是将相应的坐标配对，求出每一对坐标的乘积，然后结果相加。</strong></li></ul><hr><h3 id="✍️几何计算："><a href="#✍️几何计算：" class="headerlink" title="✍️几何计算："></a>✍️几何计算：</h3><ul><li>这个计算有一个优美的几何解释：<ul><li><strong>如果要求两个向量v和w的点积，想象向量w朝着过原点和向量v终点的直线上投影（这里指正交投影），将投影的长度与向量v的长度相乘，就得到了他们的点积，v点乘w。</strong> 所以当两个向量的指向大致相同时，他们的点积为正。（方向为正）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="点乘几何计算"></li><li><strong>除非w的投影与v的方向相反，这种情况下点积为负。</strong> （指向方向相反）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%B4%9F%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="负数情况下点乘几何计算"></li><li><strong>当他们互相垂直的时候，意味着一个向量在另一个向量上的投影为零向量。</strong></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E9%9B%B6%E5%90%91%E9%87%8F%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="零向量情况下点乘几何计算"></li></ul></li></ul><hr><h3 id="✍️点积与顺序无关："><a href="#✍️点积与顺序无关：" class="headerlink" title="✍️点积与顺序无关："></a>✍️点积与顺序无关：</h3><ul><li><strong>你可以将v投影到w上，将v投影长度与w长度相乘；或者将w投影到v上，与将w投影长度与v相乘；他们的结果是一样的。</strong> </li><li>上面的话可以这么理解：<ul><li>可以先想想v与w长度相等，我们可以利用对称性，来知道他们的结果是相等的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E9%A1%BA%E5%BA%8F.png" alt="点积顺序"></li><li>如果我们此时将v放大两倍（现在成为2v），使得他们长度不同，那么现在对称性就被破坏了；但是我们可以这样理解2v和w的点积：<ul><li>如果认为w向v上投影，那么2v点乘w就应该恰好是v点乘w的两倍，现在就是（2v）·w&#x3D;2（v·w）；这是因为，将v放大为原来的两倍并不改变w的投影长度，但是被投影的向量长度变为原来的两倍。</li><li>另一方面，如果将v投影到w上，将v变为原来的两倍（2v），那么这次的是投影长度就变为原来的两倍（2v），但是被投影的向量w长度保持不变；所以总体效果任然是点积变为两倍。</li></ul></li><li>在两种理解方式下，缩放向量对点积结果的影响是相同的。</li></ul></li></ul><hr><h3 id="✍️对偶性（duality）："><a href="#✍️对偶性（duality）：" class="headerlink" title="✍️对偶性（duality）："></a>✍️对偶性（duality）：</h3><ul><li>有不少函数能够接收二维向量并输出一个数，同样是二维输入与一维输出，和一般函数相比，线性变换的要求更加严格。</li><li>如果你有一些列等距分布于一条直线上的点，然后应用变换，线性变换会保持这些点等距分布在输出空间中（也就是数轴上）；否则，如果这些点没有等距分布，那么这个变换就不是线性的。</li><li>这些线性变换完全由他对i帽和j帽的变换决定，但是这一次，这些基向量只落在一个数上。所以当我们将他们变换后的位置记录为矩阵的列时，矩阵的每列只是一个单独的数。</li><li>假设有一个线性变换，它将i帽和j帽分别变换到1和-2，要跟踪一个向量，比如向量（4，3），在变换后的去向；将这个向量分解为4乘以i帽加上3乘以j帽。由于线性性质，在变换后，这个向量的位置是4乘以变换后的i帽也就是1（4 * 1），加上3乘以变换后的j帽也就是-2（3 * -2）；那么他最终结果落在-2上。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E5%81%B6%E6%80%A7%E7%A4%BA%E4%BE%8B.png" alt="变换示例"></li><li>上图展示的就是1x2矩阵于向量相乘这一数值运算过程，感觉上就和两个向量的点积是一样的。那这个1x2矩阵正像是一个倾倒的向量。</li><li>1x2矩阵与二维向量之间有着微妙的联系；这种关系在于：将向量放倒从而得到与之相关的矩阵，获奖矩阵直立，从而得到与之相关向量。</li><li>因为我们现在只是从数值表达上来看待这个联系，所以向量和1x2矩阵来回之间转换看起来毫无意义。</li><li>几何上，将向量转换为数的线性变换和这个向量本身有着某种关系。</li></ul><hr><h4 id="【假设我们还不知道点积与投影有关：】"><a href="#【假设我们还不知道点积与投影有关：】" class="headerlink" title="【假设我们还不知道点积与投影有关：】"></a>【<strong>假设我们还不知道点积与投影有关：</strong>】</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD.png" alt="u帽"></p><ul><li>现在将数轴复制一份，然后保持0在原点；考虑一个二维向量，它的终点落在这条数轴上，我们现在管他叫“u帽”。</li><li>如果将二维向量直接投影到这条数轴上，实际上我们这样定义了一个从二维向量到数的函数；这个函数是线性的，它在直线上等距分布的点在投影到数轴上后依然等距分布。它输出的结果是数，而不是二维向量。</li><li>我们应该把它看作一个接收两个坐标并输出一个坐标的函数。</li><li>不过，u帽是二维空间中的一个向量，而它碰巧又落在这条数轴上，根据这个投影，我们定义了一个从二维向量到数的线性变换。所以我们就能找到描述这个变换的1x2矩阵。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1.png" alt="u帽与i帽的投影"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1%E7%A4%BA%E6%84%8F.png" alt="u帽与i帽的投影示意"></p><ul><li>上图我们可以来看u帽和i帽之间的投影，因为u帽和i帽都是向量单位，那么将i帽向u帽所在的直线投影与u帽向x轴投影看上去完全对称。根据对称性，u帽向x轴的投影得到的数就是u帽的横坐标（ux）。</li><li>j帽的推理与x帽的一致，那么u帽的纵坐标就是（uy）。</li><li>所以描述投影变换的1x2矩阵的两列，就分别是u帽的两个坐标。</li><li>而空间中任意向量经过投影的变换结果，也就是投影矩阵与这个向量相乘；和这个向量与u帽的点积在计算上完全相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98%E4%B8%8E%E7%82%B9%E7%A7%AF.png" alt="矩阵向量相乘与点积"></li><li>这就是为什么单位向量的点积可以解读为将向量投影到单位向量所在的直线上所得到的投影长度。</li></ul><hr><h4 id="非单位向量"><a href="#非单位向量" class="headerlink" title="非单位向量"></a>非单位向量</h4><ul><li>只要变换是线性的，那么新矩阵就可以看作基向量向着数轴投影并乘以新矩阵的变换倍数。这就素为什么向量与给定非向量的点积可以解读为：首先给向量投影，然后将投影的值于给定向量长度相乘。</li></ul><hr><h3 id="总结对偶性："><a href="#总结对偶性：" class="headerlink" title="总结对偶性："></a>总结对偶性：</h3><ul><li>你在任何时候看见一个线性变换，它的输出空间是一维数轴；无论它是如何定义的，空间中会存在唯一的向量v与之相关。就这一意义而言，应用变换和于向量v做点积是一样的。</li><li>它是数学中“<strong>对偶性</strong>”的一个实例。</li><li><strong>对偶性</strong>贯穿数学始终，在多个方面均有体现。粗略地说，它是指：<strong>两种数学事物之间自然而又出乎意料的对应关系</strong></li><li>犹如刚刚的实例，我们可以说一个向量的对偶是由它定义的线性变换。</li><li>一个多维空间到一个一维空间的线性变换的对偶是多维空间中的某个特定向量。</li><li>表面上看，点积是理解投影的有利几何工具，并且方便检验两个向量的指向是否相同（指向相同为正，指向相反为负，垂直为0）</li><li>两个向量点乘，就是将其中一个向量转化为线性变换。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第七章：点积与对偶性&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第七章：点积与对偶性&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第七章：点积与对偶性&quot;&gt;&lt;/a&gt;3Blue1Br</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</title>
    <link href="http://example.com/2022/09/27/math_Essense_of_Linear_Algebra_P06/"/>
    <id>http://example.com/2022/09/27/math_Essense_of_Linear_Algebra_P06/</id>
    <published>2022-09-27T14:15:35.000Z</published>
    <updated>2022-09-27T15:51:29.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【<strong>注：本章笔记是第六章加附注二的笔记，也就是《逆矩阵，列空间与零空间》加《非方阵》。</strong>】</p></blockquote><h1 id="3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间"><a href="#3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间" class="headerlink" title="3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间"></a>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第六章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️逆矩阵（Inverse-Matrices）："><a href="#✏️逆矩阵（Inverse-Matrices）：" class="headerlink" title="✏️逆矩阵（Inverse Matrices）："></a>✏️逆矩阵（Inverse Matrices）：</h2><h3 id="✍️矩阵的用途："><a href="#✍️矩阵的用途：" class="headerlink" title="✍️矩阵的用途："></a>✍️矩阵的用途：</h3><ul><li>操纵空间，并且线性代数几乎在所有技术领域都有体现。</li><li>它能帮助我们求解特定的方程组。</li><li>如果一个特定的方程里面它只存在常数和未知变量（没有幂，没有奇怪的函数，没有未知量间的乘积等等），我们整理这个方程组，将未知量放在左边，常数项放在右边；如果能对其未知变量就更好（必要情况下添加系数0）；此时，就被称为“<strong>线性方程组</strong>”（Linear system of equations）</li><li>此时我们可以将此整合成一个含有常数系数和未知变量的矩阵，以及他们乘积所得到的一个常数向量。</li><li><strong>（注意：此时先将范围限制在方程数目与未知量数目相等的情况内）</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B9%E7%A8%8B%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5.png" alt="方程组和矩阵"></li><li>如上图，<strong>我们称系数矩阵为A，包含未知数的向量为粗体x，右侧的常数向量为v</strong>。这不仅仅是将方程组写进一行的书写技巧，它还阐明了这个问题中优美的几何直观部分。</li><li><strong>矩阵A代表一种线性变换，所以求解Ax&#x3D;v意味着我们去寻找一个向量x，使得它在变换后与v重合。</strong></li><li>所以求解此方程组，我们完全可以只考虑对空间的变换，以及变换后向量的重叠。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E9%87%8F%E6%9E%84%E6%88%90%E7%9A%84%E6%96%B9%E7%A8%8B%E7%BB%84.png" alt="两个未知量构成的方程组"></p><ul><li>现在上图这个含有两个未知量构成的方程组，它的解依赖于矩阵A所代表的变换。</li><li>将空间挤压到一条线或一个点等低维空间，A保持空间为2维。</li><li>我们将它们分为两种情况：<ol><li>A的行列式为0。</li><li>A的行列式不为0。</li></ol></li></ul><h4 id="A的行列式不为0的情况："><a href="#A的行列式不为0的情况：" class="headerlink" title="A的行列式不为0的情况："></a>A的行列式不为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8D%E4%B8%BA0.png" alt="A的行列式不为0"></p><ul><li>这种情况下，有且只有一个向量在变换后与v重合，并且可以通过逆向进行变换来找到这个向量。如同倒带一样，通过跟踪v的动向，就能找到满足Ax&#x3D;v的向量x。</li><li>当你逆向进行变换时，它实际上对应了另一个线性变换，通常被称为“A的逆”，记为A^(-1)。</li><li>这个过程在几何上就对应与逆向进行变换并跟踪v的动向。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E9%80%86.png" alt="A的逆"></li><li>随机选一个矩阵，有很大的可能会遇到这一非零行列式的情况。也就是说，对于两个未知量和两个方程所构成的方程组存在它唯一的解。</li><li>当方程树木与未知量数目相同时，这一思想在高维情况下也有意义。同样也可以给方程组赋予几何意义。</li><li>只要保证A不将空间挤压到一个更低的维度，那么就是A的行列式不为零的情况，那他就存在逆变换（A逆）。这使得应用A变换在应用A逆变换之后，结果恒等。</li></ul><hr><h4 id="A的行列式为0的情况："><a href="#A的行列式为0的情况：" class="headerlink" title="A的行列式为0的情况："></a>A的行列式为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA0.png" alt="A的行列式为0"></p><ul><li>这个方程组相关的变换会压缩到更低的维度。</li><li>此时不存在逆变换，函数无法将一条线变换回一个平面。</li><li>此时的解依旧存在，向量v很可能恰好处于这条线上。三维空间时，解的存在难度就会更高。</li></ul><hr><h2 id="✏️秩（rank）："><a href="#✏️秩（rank）：" class="headerlink" title="✏️秩（rank）："></a>✏️秩（rank）：</h2><ul><li>当变换结果为一条直线时，也就是说结果是一维的，我们称这个变换的秩为1（Rank1）。</li><li>如果变换后的向量落在某个二维平面上，我们称这个变换的秩为2（Rank2）。</li><li><strong>所以说“秩”代表着变换后空间的维数。</strong></li><li>所以说对于2x2的矩阵，它的秩最大为2，意味着基向量仍旧能张成整个二维空间，并且矩阵的行列式不为0。</li><li>如果对于3x3矩阵来说，秩为2的时候意味着空间被压缩了，和秩为1的情况下相比较，压缩的并不是那么严重。</li><li>如果一个三维变换的行列式不为0，变换结果仍旧充满整个三维空间，那么它的秩为3。</li></ul><hr><h2 id="✏️列空间（Column-Space）："><a href="#✏️列空间（Column-Space）：" class="headerlink" title="✏️列空间（Column Space）："></a>✏️列空间（Column Space）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%97%E7%A9%BA%E9%97%B4.png" alt="矩阵的列空间"></p><ul><li>无论是一条直线，一个平面还是三维空间，所有可能变换结果的集合被称为矩阵的“<strong>列空间</strong>”（Column Space）。</li><li>这个来源很简单，<strong>矩阵的列告诉你基向量变换后的位置。这些变换后的基向量张成的空间就是所有可能的变换结果</strong>。换句话说，<strong>列空间就是矩阵的列所张成的空间</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%88%97%E5%BC%A0%E6%88%90%E7%9A%84%E7%A9%BA%E9%97%B4.png" alt="列张成的空间"></li><li><strong>所以更精确的说，秩的定义是列空间的维数。</strong></li><li><strong>当秩达到最大值时，意味着秩与列数相等，我们称之为“满秩”（Full Rank）</strong></li></ul><hr><h3 id="✍️零空间（Null-space）："><a href="#✍️零空间（Null-space）：" class="headerlink" title="✍️零空间（Null space）："></a>✍️零空间（Null space）：</h3><ul><li>需要注意的是，零向量一定会被包含在列空间中，因为线性变换必须保证原点位置不变。</li><li>对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量（0，0）自身。</li><li>但是对于一个非满秩的矩阵来说，他将空间压缩到一个更低的维度上，也就是说会有一系列向量在变换后成为零向量（被压缩的空间的有一部分会部分归到0向量）。</li><li>这被称为矩阵的“<strong>零空间</strong>”（Null Space）或“<strong>核</strong>”（Kernel）。</li><li>变换后的一些向量落在零向量上，而“零空间”正式这些向量所构成的空间。</li><li>对线性方程组来说，当向量v恰好为零向量时，零空间给出的就是这个向量方程所有可能的解。</li></ul><hr><h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><blockquote><p>每个方程组都有一个线性变换与之联系。<br>当逆变换存在时，你就能用这个逆变换求解方程组。<br>列空间的概念让我们清楚什么时候存在解什么时候不存在。<br>零空间的概念有助于我们理解所有可能的解的集合。</p></blockquote><hr><hr><hr><h2 id="✏️附注二："><a href="#✏️附注二：" class="headerlink" title="✏️附注二："></a>✏️附注二：</h2><h3 id="✍️非方阵（Nonsquare-Matrices）："><a href="#✍️非方阵（Nonsquare-Matrices）：" class="headerlink" title="✍️非方阵（Nonsquare Matrices）："></a>✍️非方阵（Nonsquare Matrices）：</h3><ul><li>在之前的学习中，使用的几乎都是2x2或者3x3这样的方形矩阵来举例子，但现在需要讨论一下非方阵。</li><li>讨论不同维数之间的变换是完全合理的，比如一个二维向量到三位向量的变换。</li><li>同之前一样，如果网格线保持平行且等距分布，并且原点映射为自身，就称它为线性的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BA%8C%E7%BB%B4%E5%90%91%E9%87%8F%E5%88%B0%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8F.png" alt="二维向量到三维向量"></li><li>此时要注意的是，由上图所示，输入的二维向量与输出的三维向量是完全不同的物种，他们生活在没有任何关联的空间当中。</li></ul><hr><h4 id="3x2矩阵："><a href="#3x2矩阵：" class="headerlink" title="3x2矩阵："></a>3x2矩阵：</h4><ul><li>用矩阵代表这样一个变换则和之前相同；找到每一个基向量变换后的位置，然后把基向量的坐标作为矩阵的列。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220927231819.png" alt="变换示例"></li><li>注意一点，这意味着代表这个变换的矩阵是三行两列，也就是3x2矩阵。这个矩阵的列空间是三维空间中一个过原点的二维平面，但是这个矩阵任然是满秩的。因为列空间的维数与输入空间的维数相等。</li><li>它的几何意义是将二维空间映射到三维空间上，因为矩阵有两列表面输入空间有两个基向量，有三行表明每个基向量在变换后都用三个独立的坐标来表示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x2%E7%9F%A9%E9%98%B5.png" alt="3x2矩阵"></li></ul><hr><h4 id="2x3矩阵："><a href="#2x3矩阵：" class="headerlink" title="2x3矩阵："></a>2x3矩阵：</h4><ul><li>类似的，当我们看见一个两行三列也就是2x3矩阵时，表面矩阵有三个基向量，也就是说原始空间是三维的；每个变换后的基向量用两个坐标来表示，所以他们一定落在二维空间。因此这是一个从三维空间到二维空间的变换。如下图所示例。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x3%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B.png" alt="2x3矩阵示例"></li></ul><hr><h4 id="1x2矩阵："><a href="#1x2矩阵：" class="headerlink" title="1x2矩阵："></a>1x2矩阵：</h4><ul><li>除此以外，当然还可以由二维空间到一维空间的转换，一维空间实际上就是数轴。</li><li>这里可以理解为如果一条直线上有一系列等距分布的点，在映射到数轴之后，他们将保持等距分布，这样的变换也可以用一个1x2矩阵表示，而这个矩阵的两列都只有一个数，这两列分别代表了变换后的基向量。</li><li>实际上这是一类非常有意义的变换，它与点积紧密相关。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/1x2%E7%9F%A9%E9%98%B5.png" alt="1x2矩阵"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;【&lt;strong&gt;注：本章笔记是第六章加附注二的笔记，也就是《逆矩阵，列空间与零空间》加《非方阵》。&lt;/strong&gt;】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第五章：行列式</title>
    <link href="http://example.com/2022/09/26/math_Essense_of_Linear_Algebra_P05/"/>
    <id>http://example.com/2022/09/26/math_Essense_of_Linear_Algebra_P05/</id>
    <published>2022-09-26T09:15:35.000Z</published>
    <updated>2022-09-26T15:53:09.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第五章：行列式"><a href="#3Blue1Brown-线代本质第五章：行列式" class="headerlink" title="3Blue1Brown_线代本质第五章：行列式"></a>3Blue1Brown_线代本质第五章：行列式</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第五章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️区域内面积增大减小："><a href="#✏️区域内面积增大减小：" class="headerlink" title="✏️区域内面积增大减小："></a>✏️区域内面积增大减小：</h2><ul><li>想象一些线性空间，有的变换是向外拉伸空间（Generally stretches space），有的则是向内挤压（Generally squashes space）；有件事情对理解这些线性变换很有用，那就是测量这些变换究竟对空间有多少拉伸或挤压；也就是：<strong>测量一个给定区域面积增大或减小的比例。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%98%E6%8D%A2%E5%90%8E%E7%9A%84%E9%9D%A2%E7%A7%AF.png" alt="变换后的面积"></li><li>如上图所示，i帽从（1，0）变换为（3，0），j帽从（0，1）变换为（0，2）；则由i帽和j帽决定的单位正方形的面积从原先的1x1变成了现在的3x2；它的面积增大了6倍。所以我们说这个线性变换将它的面积变为6倍。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%89%AA%E5%88%87%E7%9F%A9%E9%98%B5%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%8F%98%E6%8D%A2.png" alt="剪切矩阵的面积变换"></p><ul><li>【<strong>剪切矩阵</strong>】则是i帽不变还是在（1，0），j帽从（0，1）变为（1，1）；此时由i帽和j帽决定的单位正方形在变换后倾斜为一个平行四边形，但是它的面积是不变的。所以说即便这个变换空间向右挤压，它并不改变面积。</li><li>实际上，只要知道单位正方形面积变化的比例，他就能告诉你其他任意区域的面积变化比例（因为“网格线保持平行且等距分布”）。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%BF%90%E7%94%A8%E8%BF%91%E4%BC%BC%E7%9A%84%E6%96%B9%E6%A0%BC%E7%BC%A9%E6%94%BE.png" alt="运用近似的方格缩放"></p><ul><li>对于不是方形网格的形状，我们可以用许多放个良好近似，只要使用的方格足够小，近似就能足够好。由于所有的小方格都是进行等比缩放，所以整个形状也进行了同样比例的缩放。</li></ul><hr><h2 id="✏️线性变换的行列式（The-“deternminant”-of-a-transformation）："><a href="#✏️线性变换的行列式（The-“deternminant”-of-a-transformation）：" class="headerlink" title="✏️线性变换的行列式（The “deternminant” of a transformation）："></a>✏️线性变换的行列式（The “deternminant” of a transformation）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A1%8C%E5%88%97%E5%BC%8F.png" alt="线性变换行列式"></p><ul><li>比如说，一个线性变换的行列式是3，那么就是说他将一个区域的面积增加为原来的三倍。</li><li>同理一个线性变换的行列式是1&#x2F;2，那么就说他将一个区域的面积减少为原来的二分之一。</li><li>如果一个线性变换的行列式是0，那么说明它将整个平面压缩到一条线，甚至是一个点上。</li><li>如果变换前j帽在i帽的左侧，变换后j帽变成i帽的右侧，那么此时空间定向就发生了改变（Orientation has been reversed）。</li><li><strong>当空间定向改变，行列式为负</strong>，但是行列式的绝对值依然表示区域面积的缩放比例。</li></ul><hr><h3 id="✍️负的面积为什么与定向改变相关？"><a href="#✍️负的面积为什么与定向改变相关？" class="headerlink" title="✍️负的面积为什么与定向改变相关？"></a>✍️负的面积为什么与定向改变相关？</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA%E8%B4%9F%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5.png" alt="行列式为负值的情况"></p><ul><li>考虑i帽靠近j帽时的变换，空间也被更厉害的压缩，意味着行列式趋近于0；当i帽与j帽完全重合时，行列式为0。如果i帽继续沿着这个方向运动，则行列式继续减小为负值。</li></ul><hr><h2 id="✏️三维空间中行列式的变换："><a href="#✏️三维空间中行列式的变换：" class="headerlink" title="✏️三维空间中行列式的变换："></a>✏️三维空间中行列式的变换：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="行列式在三维空间内的变换"></p><ul><li>它告诉你的依然是变换前后的缩放比例，不过三维空间内缩放的是体积。</li><li>在三维空间中我们可以用1x1x1，即i，j，k这三个基向量，这个特殊的立方体来观察行列式的变换。</li><li>我们可以把行列式简单的看作这个平行六面体的体积<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%85%AD%E9%9D%A2%E4%BD%93%E7%9A%84%E4%BD%93%E7%A7%AF.png" alt="平行六面体的体积"></li><li>行列式为0则意味着整个空间被压缩为零体积的东西。也就是一个平面，一条直线或一个点。</li></ul><hr><h3 id="✍️如何计算行列式？："><a href="#✍️如何计算行列式？：" class="headerlink" title="✍️如何计算行列式？："></a>✍️如何计算行列式？：</h3><ul><li>首先它必须得是方形矩阵（行列数相等）。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E9%9D%A2%E7%A7%AF%E8%AE%A1%E7%AE%97%E6%8E%A8%E5%AF%BC.png" alt="行列式面积计算推导"></li><li>ad是平行四边形的面积公式底乘以高，如果c不为0的情况下，这个bc项准确的告诉你平行四边形在对角线方向上拉伸或压缩了多少；则这个公式就可以计算出拉伸后的面积。</li></ul><h3 id="✍️三阶行列式计算公式："><a href="#✍️三阶行列式计算公式：" class="headerlink" title="✍️三阶行列式计算公式："></a>✍️三阶行列式计算公式：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="三阶行列式计算公式"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第五章：行列式&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第五章：行列式&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第五章：行列式&quot;&gt;&lt;/a&gt;3Blue1Brown_线代本质第</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换</title>
    <link href="http://example.com/2022/09/25/math_Essense_of_Linear_Algebra_P04/"/>
    <id>http://example.com/2022/09/25/math_Essense_of_Linear_Algebra_P04/</id>
    <published>2022-09-25T09:15:35.000Z</published>
    <updated>2022-09-25T12:12:26.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合"><a href="#3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合" class="headerlink" title="3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合"></a>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第四章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><p>【<strong>注：本章笔记是第四章加附注一的笔记，也就是《矩阵乘法与线性变换复合》加《三维空间中的线性变换》。</strong>】</p><h2 id="✏️线性复合变换："><a href="#✏️线性复合变换：" class="headerlink" title="✏️线性复合变换："></a>✏️线性复合变换：</h2><ul><li>有时候，我们常常是想要做多种变换，比如“先旋转，后剪切”；这个新的线性变换通常被称为前两个独立变换的“<strong>复合变换</strong>”（Composition）。</li><li>和其他变换一样，我们可以通过追踪i帽和j帽的变换，并用矩阵完全描述这个复合变换。</li><li>两个矩阵相乘有着几何意义，也就是<strong>两个线性变换相继作用</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5.png" alt="复合矩阵"></li><li>这个矩阵需要从右向左读；首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换。</li><li>它起源于函数的记号，因为我们将函数写在变量左侧。所以每次将两个函数复合的时候，我们需要从右往左读。</li></ul><hr><h3 id="✍️复合矩阵的计算："><a href="#✍️复合矩阵的计算：" class="headerlink" title="✍️复合矩阵的计算："></a>✍️复合矩阵的计算：</h3><ul><li>我们希望对复合矩阵进行计算的时候，计算结果的第一列我们首先要考虑：<strong>i帽去哪里了？</strong></li><li>下图看出，i帽首先落在（1，1）。所以我们在计算时首先将示例中的M1的第一列（1，1）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第一列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_i%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_i帽变换"></li><li>其次，我们要考虑第二列：<strong>j帽去哪了？</strong></li><li>与上文中提到的i帽的计算方式一样，j帽先落在（-2，0），所以我们在计算时将示例中的M1的第一列（-2，0）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第二列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_j%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_j帽变换"></li><li>这一推理具有普适性，对任意矩阵都适用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="矩阵乘法公式"></li></ul><h3 id="✍️注意矩阵计算顺序不可对调："><a href="#✍️注意矩阵计算顺序不可对调：" class="headerlink" title="✍️注意矩阵计算顺序不可对调："></a>✍️注意矩阵计算顺序不可对调：</h3><ul><li><strong>矩阵乘法不具有交换律。</strong></li><li>如之前的推导公式中，M1M2≠M2M1；即在矩阵运算中“先剪切，后旋转”并不等于“先旋转，后剪切”。</li><li>乘积顺序影响整体的计算。</li></ul><h3 id="✍️结合律（Associativity）："><a href="#✍️结合律（Associativity）：" class="headerlink" title="✍️结合律（Associativity）："></a>✍️结合律（Associativity）：</h3><ul><li><strong>矩阵乘法满足结合律</strong>。</li><li><strong>A（BC） &#x3D; （AB）C</strong></li><li>空间变换来看，线性变换的作用对象是向量，这个计算是线性变换的复合，而不是指把一个作用于另一个。</li><li>以上的等式左边是在说：首先应用C变换和B变换，然后应用A变换；等式右边还是在说：首先应用C变换，其次应用B变换和A变换。</li><li>这只是将同样的三个变换用同样的顺序依次总用，换句话说就是：添加括号与结果无关，他们的计算顺序没有变化（记住矩阵变换始终是从右往左读的）。括号的意义在这里表示某两个要一起做，而不是他们做的顺序提前。</li></ul><hr><hr><hr><h2 id="✏️三维空间中的线性变换："><a href="#✏️三维空间中的线性变换：" class="headerlink" title="✏️三维空间中的线性变换："></a>✏️三维空间中的线性变换：</h2><ul><li>考虑这样一个线性变换，他以三维向量为输入，并以三维向量为输出；我们可以想象他在移动三维空间中的所有点，保持网格线平行且等距分布，并保持原点不动。</li><li>和二维的情形一样，我们看见三维空间中每一个点实际上只是用来代表以它本身为终点的一个向量；而我们所做的变换只是将输入向量移动至对应向量。</li><li>三维线性的变换由基向量的去向完全决定。</li><li>此时就有3个基向量，分别是x方向的i帽，y方向的j帽，z方向的k帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="三维空间的变换"></li><li>将变换后的三个基向量的坐标记录在一个3x3的矩阵中。这九个数字就完全描述了一个线性变换。</li><li>三维空间内向量的变换公式推导与二维空间几乎一致，它每个坐标都可以看作对相应基向量的缩放。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x3%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2.png" alt="3x3矩阵变换"></li><li>3x3矩阵的运用十分广泛,如计算机图形学（Computer Graphics）与机器人学（Robotics）。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
