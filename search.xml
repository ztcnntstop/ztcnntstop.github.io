<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>百人计划笔记01_1.1：图形渲染管线</title>
    <url>/2023/02/11/TA100_1_1_renderPipeline/</url>
    <content><![CDATA[<h1 id="1-1：图形渲染管线-【renderPipeline】"><a href="#1-1：图形渲染管线-【renderPipeline】" class="headerlink" title="1.1：图形渲染管线 【renderPipeline】"></a>1.1：图形渲染管线 【renderPipeline】</h1><h2 id="百人计划笔记01"><a href="#百人计划笔记01" class="headerlink" title="百人计划笔记01"></a>百人计划笔记01</h2><blockquote>
<p>霜狼may的技术美术百人计划笔记~<br>增长知识，拓宽视野~<br>可能不是每章都会写笔记，但是会持续学习！<br>不能保证全都理解到位书写正确，有错误请及时指出！感激不尽！</p>
</blockquote>
<hr>
<blockquote>
<p>渲染管线之所以叫管线，是因为它的工作流程是线性的。<br>我们的场景是3d的，但最终的输出呈现在屏幕上是2d的，那么这就是通过渲染管线的一系列处理，把这些元素转换成屏幕上呈现的2d图像。</p>
</blockquote>
<h2 id="🍅整体流程："><a href="#🍅整体流程：" class="headerlink" title="🍅整体流程："></a>🍅整体流程：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230206234708.png" alt="20230206234708"></p>
<h3 id="1-🍏应用阶段"><a href="#1-🍏应用阶段" class="headerlink" title="1.🍏应用阶段"></a>1.🍏应用阶段</h3><ul>
<li><strong>粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段</strong></li>
<li><strong>应用阶段准备的是场景</strong>，对象的基本数据：比如<strong>场景里的物体</strong>，他们的位置朝向，大小，以及物体里对应的模型里面的每一个顶点位置，法线，切线等。</li>
<li>再比如场景<strong>光源</strong>的位置，朝向，以及基本属性； <strong>摄像机</strong>朝向，位置等</li>
</ul>
<h3 id="2-🍏几何阶段"><a href="#2-🍏几何阶段" class="headerlink" title="2.🍏几何阶段"></a>2.🍏几何阶段</h3><ul>
<li><strong>顶点着色器，曲面细分，几何着色器，顶点裁切，屏幕影射。</strong></li>
<li><strong>计算顶点光照</strong>，就需要知道光源位置朝向以及摄像机的位置以及朝向，还有当前顶点的世界位置</li>
<li>又需要知道顶点在模型空间的位置，以及模型本身的位置旋转缩放等。</li>
<li><strong>曲面细分</strong>着色器通过现有顶点来生成更多顶点，也需要知道现有顶点的在模型信息里的位置</li>
<li><strong>几何着色器</strong>需要通过现有的图元来做一些几何方面的操作，生成更多的顶点和图元。比如对现有图元所在的平面生成法线，同样需要知道现有图元的顶点位置。</li>
<li><strong>几何阶段要为光栅化阶段准备数据</strong>，比如干掉屏幕以外的顶点（<strong>顶点裁剪</strong>），还需要把顶点位置从3d坐标空间转换到2d坐标空间，这就是<strong>屏幕映射</strong></li>
</ul>
<h3 id="3-🍏光栅化阶段"><a href="#3-🍏光栅化阶段" class="headerlink" title="3.🍏光栅化阶段"></a>3.🍏光栅化阶段</h3><ul>
<li><strong>三角形（点、线）设置，三角形（点、线）遍历，片段着色器。</strong></li>
<li>拿到映射到2d空间里的顶点位置，组装成三角形，还要知道这些三角形包含了哪些2d空间的像素点。这就是<strong>三角形遍历</strong></li>
<li>最后对这些点使用它们包含的数据来着色，并为后面的逐片元着色准备数据</li>
</ul>
<h3 id="4-🍏逐片元操作"><a href="#4-🍏逐片元操作" class="headerlink" title="4.🍏逐片元操作"></a>4.🍏逐片元操作</h3><ul>
<li><strong>裁剪测试，透明度测试，深度测试，模板测试，混合。</strong></li>
<li>此时操作对象就变成了光栅化操作输出的<strong>片元数据</strong>，片元可以理解成屏幕上的某一个像素点，对于这些片元我们需要进行一系列的测试。</li>
<li><strong>测试比如</strong>：透明度，深度和模板测试。通过测试的片元就保留起来，否则就丢弃掉。</li>
<li>在2d屏幕坐标系当中，<strong>同一个位置上的像素点有可能会对应于多个不同的片元。</strong></li>
<li>那么我们可能还需要把这些通过测试的片元的颜色进行一个混合操作，从而得到像素点最终输出的颜色。</li>
</ul>
<h3 id="5-🍏后处理"><a href="#5-🍏后处理" class="headerlink" title="5.🍏后处理"></a>5.🍏后处理</h3><ul>
<li>逐片元操作完成后，我们就得到了一个类似于贴图的数据保存在内存里，然后可以对这个数据做一个<strong>后处理</strong>，也可以理解成图像处理。</li>
<li>比如：模糊，景深，高光等等</li>
</ul>
<hr>
<h2 id="🍅CPU与GPU："><a href="#🍅CPU与GPU：" class="headerlink" title="🍅CPU与GPU："></a>🍅CPU与GPU：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207001656.png" alt="20230207001656"></p>
<h3 id="1-🍏应用阶段-—-cpu"><a href="#1-🍏应用阶段-—-cpu" class="headerlink" title="1.🍏应用阶段 — cpu"></a>1.🍏应用阶段 — cpu</h3><ul>
<li><strong>一般是在cpu上完成的</strong>，比如说从磁盘或内存上读取模型或贴图数据，然后加载到应用程序里。</li>
<li>比如游戏会加载模型或者贴图，在游戏场景中，<strong>首先会做一个粗粒度剔除</strong>，被遮挡的物体就不需要显示。</li>
<li><strong>设置基本渲染参数和状态</strong>，比如渲染ui和渲染场景它们的渲染参数和模式可能不一样。</li>
<li>最后通过DrawCall将这些渲染所使用的数据传给GPU去处理</li>
</ul>
<h3 id="2-🍏几何阶段，光栅化，逐片元操作—GPU"><a href="#2-🍏几何阶段，光栅化，逐片元操作—GPU" class="headerlink" title="2.🍏几何阶段，光栅化，逐片元操作—GPU"></a>2.🍏几何阶段，光栅化，逐片元操作—GPU</h3><ul>
<li>这三个阶段一般会放在GPU处理，<strong>GPU的特点是并行性比较好</strong></li>
<li>比如说，有模型可能有很多顶点都需要做光照或者着色计算，<strong>这些顶点它们只是数据不同，但是它们的几何运算方式是相同的，那么就可以把他们分配到GPU的不同工作单元上面去同时执行，这样速度就很快。</strong></li>
<li>光栅化和逐片元也是同理。</li>
</ul>
<h2 id="🍅每个阶段做的事情："><a href="#🍅每个阶段做的事情：" class="headerlink" title="🍅每个阶段做的事情："></a>🍅每个阶段做的事情：</h2><h3 id="1-🍏应用阶段-1"><a href="#1-🍏应用阶段-1" class="headerlink" title="1.🍏应用阶段"></a>1.🍏应用阶段</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207003342.png" alt="20230207003342"></p>
<ol>
<li><strong>准备场景数据</strong>，摄像机数据，光源&#x2F;阴影数据，全局数据。</li>
<li>准备好数据后，<strong>需要做一些优化</strong>，比如算法加速，干掉看不到不需要渲染的物体，做一些剔除</li>
<li><strong>设置渲染状态</strong>，准备渲染参数。比如由远到进渲染，还是不透明先渲染再渲染半透明，这个就是<strong>绘制顺序</strong>。对于不同的物体使用不同的shader渲染，以及输出渲染结果到什么地方，是renderTexture还是FrameBuffer，这是<strong>渲染目标</strong>。<strong>渲染模式</strong>，比如成像渲染或者延迟渲染等等。</li>
<li>最后设置好渲染状态和参数后，我们就会调用DrawCall，把大有渲染数据的图元输出到显存去交给GPU处理。</li>
</ol>
<h4 id="🍇基本场景数据："><a href="#🍇基本场景数据：" class="headerlink" title="🍇基本场景数据："></a>🍇基本场景数据：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207004145.png" alt="20230207004145"></p>
<h4 id="🍇光源和阴影："><a href="#🍇光源和阴影：" class="headerlink" title="🍇光源和阴影："></a>🍇光源和阴影：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223110.png" alt="20230207223110"></p>
<h4 id="🍇加速算法，粗颗粒剔除："><a href="#🍇加速算法，粗颗粒剔除：" class="headerlink" title="🍇加速算法，粗颗粒剔除："></a>🍇加速算法，粗颗粒剔除：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223310.png" alt="20230207223310"></p>
<ul>
<li>摄像机视锥之外的物体是可以裁切掉的，比如判断是否在视锥内，或者与视锥是否相交。</li>
<li>被遮挡的物体也可以剔除掉。</li>
</ul>
<h4 id="🍇渲染设置："><a href="#🍇渲染设置：" class="headerlink" title="🍇渲染设置："></a>🍇渲染设置：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223509.png" alt="20230207223509"></p>
<ul>
<li>对于不同对象使用一些合批方式，比如GPU instance或者动态批处理等等</li>
</ul>
<h4 id="🍇输出到显存："><a href="#🍇输出到显存：" class="headerlink" title="🍇输出到显存："></a>🍇输出到显存：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207223855.png" alt="20230207223855"></p>
<h3 id="2-🍏几何阶段："><a href="#2-🍏几何阶段：" class="headerlink" title="2.🍏几何阶段："></a>2.🍏几何阶段：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207224049.png" alt="20230207224049"></p>
<h4 id="🍇顶点着色器-视图变换"><a href="#🍇顶点着色器-视图变换" class="headerlink" title="🍇顶点着色器-视图变换"></a>🍇顶点着色器-视图变换</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207225721.png" alt="20230207225721"></p>
<ul>
<li><strong>对顶点做坐标系的变换，还会对他进行一定的着色操作</strong></li>
<li>投影变换：（为了最后做3d到2d的投影操作做准备）<ul>
<li>1.正交，远近一样大</li>
<li>2.透视，近大远小</li>
<li>同时投影还有一个裁剪的作用，确定该顶点是不是在视锥的远近左右上下包围平面之内</li>
</ul>
</li>
</ul>
<p>-<strong>mvp矩阵：</strong></p>
<ul>
<li><strong>Model</strong>：模型变换，施加在模型上的空间变换，包含平移变换（translateM）、旋转变换（rotateM）、对称变换（transposeM）、缩放变换（scaleM</li>
<li><strong>View</strong>：观测变换，施加在观测点上的变换，用于调整观测点位置、观测朝向、观测正方向；</li>
<li><strong>Projection</strong>：透视变换，施加在视觉上的变换，用于调整模型的透视效果（如：矩形的透视效果是梯形）。</li>
</ul>
<p>-顶点着色器还有一个作用是计算顶点光照</p>
<h4 id="🍇曲面细分（可选步骤）"><a href="#🍇曲面细分（可选步骤）" class="headerlink" title="🍇曲面细分（可选步骤）"></a>🍇曲面细分（可选步骤）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231217.png" alt="20230207231217"></p>
<ul>
<li>按照算法生成更多顶点</li>
</ul>
<h4 id="🍇几何着色器（可选步骤，基于图元的操作）"><a href="#🍇几何着色器（可选步骤，基于图元的操作）" class="headerlink" title="🍇几何着色器（可选步骤，基于图元的操作）"></a>🍇几何着色器（可选步骤，基于图元的操作）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231347.png" alt="20230207231347"></p>
<ul>
<li><strong>顶点着色器操作的对象是单个顶点，而几何着色器操作对象是一个图元；</strong></li>
<li>这个图元可能是一个顶点，也可能是一个线段，两个顶点，也有可能是多个顶点构成的连续线段，也有可能是三个顶点构成的三角形，或者其他。</li>
<li>它的作用是通过给定图元去生成更多图元</li>
</ul>
<h4 id="🍇投影"><a href="#🍇投影" class="headerlink" title="🍇投影"></a>🍇投影</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207231658.png" alt="20230207231658"></p>
<ul>
<li><p>前面的步骤都是3d空间的，那么把3d空间转换到2d屏幕的转换过程，就是<strong>投影的步骤</strong></p>
</li>
<li><p>顶点在裁剪空间的位置，xyzw会对它进行一个透视除法，把xyz除以w来完成投影操作。</p>
</li>
<li><p>这样就从投影坐标系转换到了标准设备坐标系，也就是NDC(<strong>Normalized Device Coordinates</strong>, NDC)</p>
<ul>
<li>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃&#x2F;裁剪，不会显示在你的屏幕上。</li>
</ul>
</li>
<li><p><strong>正交投影上</strong>，w始终为1，所以不管在投影空间中的任意位置，xyz除以w都不会发生变换。</p>
</li>
<li><p><strong>透视模式中</strong>，w是近处比较小，远处比较大，所以说对于近处远处的点，它们xyz除以w，投影到2d平面上就会呈现出近大远小的效果</p>
</li>
</ul>
<h4 id="🍇裁剪"><a href="#🍇裁剪" class="headerlink" title="🍇裁剪"></a>🍇裁剪</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207233402.png" alt="20230207233402"></p>
<ul>
<li>转换后如果xyz 超过-1~1的范围，则会被剔除（处于裁剪空间外）</li>
<li>在Open GL中，xyz三个维度都是从-1~1.</li>
<li>而D3D当中只有xy两个维度是从-1<del>1，z则是从0</del>1</li>
</ul>
<h4 id="🍇屏幕映射"><a href="#🍇屏幕映射" class="headerlink" title="🍇屏幕映射"></a>🍇屏幕映射</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207233925.png" alt="20230207233925"></p>
<ul>
<li>屏幕是输出设备的长宽，所以这里也有一个映射过程。</li>
<li>OpenGl和D3D的屏幕坐标系原点也不一样<ul>
<li>OpenGl的原点在左下方</li>
<li>D3D原点在左上方</li>
</ul>
</li>
</ul>
<h3 id="2-🍏光栅化阶段："><a href="#2-🍏光栅化阶段：" class="headerlink" title="2.🍏光栅化阶段："></a>2.🍏光栅化阶段：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234142.png" alt="20230207234142"></p>
<h4 id="🍇三角形设置"><a href="#🍇三角形设置" class="headerlink" title="🍇三角形设置"></a>🍇三角形设置</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234220.png" alt="20230207234220"></p>
<ul>
<li>知道这个图元的边界信息，而计算这个边界信息的过程就是三角形设置。然后就可以知道它覆盖的屏幕像素</li>
</ul>
<h4 id="🍇三角形遍历"><a href="#🍇三角形遍历" class="headerlink" title="🍇三角形遍历"></a>🍇三角形遍历</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207234856.png" alt="20230207234856"></p>
<ul>
<li>检查这些像素是否被三角形覆盖，如果被覆盖就说明这个片元属于这个三角形。</li>
<li>这种寻找被三角形网格所覆盖的所有像素的过程就叫做三角形遍历</li>
<li>得到被三角形所覆盖的所有像素后，会使用三角形的三个顶点，对每一个被覆盖的对象进行线性插值，然后得到当前三角形在像素对应片元的数据。</li>
<li>所以这里得到的片元并不等同于是像素。</li>
</ul>
<h4 id="🍇抗锯齿（MSAA）"><a href="#🍇抗锯齿（MSAA）" class="headerlink" title="🍇抗锯齿（MSAA）"></a>🍇抗锯齿（MSAA）</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230207235306.png" alt="20230207235306"></p>
<ul>
<li>MSAA使用子采样点对三角形进行覆盖测试，看这个子采样点深度缓存里面的数值进行比较，看是否通过。</li>
</ul>
<h3 id="🍏逐片元操作"><a href="#🍏逐片元操作" class="headerlink" title="🍏逐片元操作"></a>🍏逐片元操作</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208000014.png" alt="20230208000014"></p>
<ul>
<li>对通过的片元，我们需要用什么方式混合，最终输出到一个像素；这一步是可以配置的</li>
<li>然后将他们输出到目标缓冲区</li>
</ul>
<h4 id="🍇片元着色"><a href="#🍇片元着色" class="headerlink" title="🍇片元着色"></a>🍇片元着色</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208000549.png" alt="20230208000549"></p>
<ul>
<li>对于一个三角形所覆盖的片元，会使用三个顶点数据，对其进行线性插值。</li>
<li>如p点就是三个顶点进行线性插值的结果。我们还可以得到其他如UV信息，深度信息等数据</li>
<li>然后再用片元数据和其他全局数据，比如光照阴影时间等等去计算，得到最终的片元颜色</li>
</ul>
<h4 id="🍇颜色混合，透明度测试"><a href="#🍇颜色混合，透明度测试" class="headerlink" title="🍇颜色混合，透明度测试"></a>🍇颜色混合，透明度测试</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208001154.png" alt="20230208001154"></p>
<h4 id="🍇颜色混合-深度测试、模板测试"><a href="#🍇颜色混合-深度测试、模板测试" class="headerlink" title="🍇颜色混合-深度测试、模板测试"></a>🍇颜色混合-深度测试、模板测试</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208001351.png" alt="20230208001351"></p>
<ul>
<li><strong>深度测试</strong>的测试对象就是片元的深度值，把片元深度值和对应的深度缓冲当中的深度值去比较，通过比较的会保留下来</li>
<li><strong>模板测试</strong>比较模板值，我们希望对两个立方体进行描边，不希望任何一个立方体描边挡住其他的立方体，那么我们可以将两个立方体的顶点放大一点，并且将它绘制成描边的颜色。</li>
<li>然后我们进行真实立方体绘制的时候，我们会把立方体的模板值和之前描边颜色的模板值比较；模板值是描边模板值的，我们把它覆盖掉，这样就可以实现立方体永远在描边之上。</li>
<li>这个比较方式也可以配置，可以是小于通过也可以是大于通过，也可以是等于通过。</li>
</ul>
<h4 id="🍇混合"><a href="#🍇混合" class="headerlink" title="🍇混合"></a>🍇混合</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208002257.png" alt="20230208002257"></p>
<ul>
<li>逐片元最后一个操作</li>
<li></li>
</ul>
<h3 id="🍏后处理"><a href="#🍏后处理" class="headerlink" title="🍏后处理"></a>🍏后处理</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230208002742.png" alt="20230208002742"></p>
]]></content>
      <categories>
        <category>-TA100</category>
      </categories>
      <tags>
        <tag>-技术美术百人计划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Select Tool 使用文档】 （测试在线文档）</title>
    <url>/2023/01/06/TAcourse_week06_selectTool_helpDoc/</url>
    <content><![CDATA[<h1 id="【Select-Tool-使用文档】-（测试在线文档）"><a href="#【Select-Tool-使用文档】-（测试在线文档）" class="headerlink" title="【Select Tool 使用文档】 （测试在线文档）"></a><center>【Select Tool 使用文档】 （测试在线文档）</center></h1><h2 id="🐢工具介绍"><a href="#🐢工具介绍" class="headerlink" title="🐢工具介绍"></a>🐢工具介绍</h2><blockquote>
<p>✨此工具用于选择不同类型的模型<br>✨按键之间都是独立的，不会混合选择的类型<br>✨被选中的模型会在工具中显示出来</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155106.png" alt="20230106155106"></p>
<hr>
<hr>
<h2 id="🐢使用指南"><a href="#🐢使用指南" class="headerlink" title="🐢使用指南"></a>🐢使用指南</h2><blockquote>
<p>🌻选择polymeshes如下图：  </p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155132.png" alt="20230106155132"></p>
<hr>
<blockquote>
<p>🌻选择Nurbs Meshes如下图： </p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155358.png" alt="20230106155358"></p>
<hr>
<blockquote>
<p>🌻选择Curves如下图：</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155500.png" alt="20230106155500"></p>
<hr>
<blockquote>
<p>☃️若场景中没有此类选择的物体，会提示：Zero object of this type!</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106155847.png" alt="20230106155847"></p>
<hr>
<blockquote>
<p>☃️将鼠标悬停在按钮上会有功能的相应提示</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106161621.png" alt="20230106161621"></p>
<hr>
<blockquote>
<p>☃️下拉help菜单可以阅读此工具的帮助文档（也就是这篇）</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230106161816.png" alt="20230106161816"></p>
<blockquote>
<p>🐨以上就是select tool的介绍！<br>🐨此文档目前只用于托管在线文档测试！</p>
</blockquote>
]]></content>
      <categories>
        <category>-Help Doc</category>
      </categories>
      <tags>
        <tag>-Help Doc</tag>
      </tags>
  </entry>
  <entry>
    <title>houdini以及3D数学学习列表合辑</title>
    <url>/2022/09/09/houdini/</url>
    <content><![CDATA[<ul>
<li>这篇是我的Houdini学习记录了，也算是我的Houdini学习置顶占位。</li>
<li>同时为了补足我3D的知识，也在学习3D相关的数学（都是比较基础的部分）。</li>
<li>然后写的不一定是教程笔记哈，有些别的好的素材以及我也会随意写写放上来！</li>
<li>详细如下，都有各个的部分的站内链接，每篇写好了就会更新！</li>
<li>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</li>
</ul>
<hr>
<h1 id="🚩PCG部分"><a href="#🚩PCG部分" class="headerlink" title="🚩PCG部分"></a>🚩PCG部分</h1><h2 id="一：🏘️湖边小屋学习记录🏘️"><a href="#一：🏘️湖边小屋学习记录🏘️" class="headerlink" title="一：🏘️湖边小屋学习记录🏘️"></a>一：🏘️湖边小屋学习记录🏘️</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lakeHouse_top.png" alt="lakeHouse_top"><br>老经典了，还没看过兄弟姐妹的我不允许你还没看过！这是<a href="https://www.bilibili.com/video/BV1rW411j7fo?spm_id_from=333.337.search-card.all.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a></p>
<blockquote>
<p>（目前小屋笔记还在整理中，link内没东西。）</p>
</blockquote>
<p><strong>湖边小屋第一篇站内link：</strong></p>
<a href="/2022/09/13/houdini_lakeHouse_p1/" title="Houdini湖边小屋学习（一）">Houdini湖边小屋学习（一）</a>

<p><strong>湖边小屋第二篇站内link：</strong><br><strong>湖边小屋第三篇站内link：</strong></p>
<hr>
<h1 id="🚩Houdini节点知识学习以及补充部分"><a href="#🚩Houdini节点知识学习以及补充部分" class="headerlink" title="🚩Houdini节点知识学习以及补充部分"></a>🚩Houdini节点知识学习以及补充部分</h1><h2 id="一：➰关于forEach和forLoop在Houdini中的用法➰"><a href="#一：➰关于forEach和forLoop在Houdini中的用法➰" class="headerlink" title="一：➰关于forEach和forLoop在Houdini中的用法➰"></a>一：➰关于forEach和forLoop在Houdini中的用法➰</h2><p><strong>站内link：</strong></p>
<a href="/2022/09/13/houdini_foreach/" title="Houdini 中for-each 和for-loop 节点">Houdini 中for-each 和for-loop 节点</a>

<h2 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h2><hr>
<h1 id="🚩3D数学部分"><a href="#🚩3D数学部分" class="headerlink" title="🚩3D数学部分"></a>🚩3D数学部分</h1><h2 id="一：🧮3Blue1Brown线性代数的本质🧮"><a href="#一：🧮3Blue1Brown线性代数的本质🧮" class="headerlink" title="一：🧮3Blue1Brown线性代数的本质🧮"></a>一：🧮3Blue1Brown线性代数的本质🧮</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/a3Blue1Brown.png" alt="a3Blue1Brown"><br><strong>第一节站内Link：</strong></p>
<a href="/2022/09/22/math_Essense_of_Linear_Algebra_P01/" title="3Blue1Brown_线代本质第一章：向量究竟是什么">3Blue1Brown_线代本质第一章：向量究竟是什么</a>

<p><strong>第二节站内Link：</strong></p>
<a href="/2022/09/22/math_Essense_of_Linear_Algebra_P02/" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基">3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</a>

<p><strong>第三节站内Link：</strong></p>
<a href="/2022/09/24/math_Essense_of_Linear_Algebra_P03/" title="3Blue1Brown_线代本质第三章：矩阵与线性变换">3Blue1Brown_线代本质第三章：矩阵与线性变换</a>

<p><strong>第四节站内Link：</strong></p>
<a href="/2022/09/25/math_Essense_of_Linear_Algebra_P04/" title="3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换">3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换</a>

<p><strong>第五节站内Link：</strong></p>
<a href="/2022/09/26/math_Essense_of_Linear_Algebra_P05/" title="3Blue1Brown_线代本质第五章：行列式">3Blue1Brown_线代本质第五章：行列式</a>

<p><strong>第六节站内Link：</strong></p>
<a href="/2022/09/27/math_Essense_of_Linear_Algebra_P06/" title="3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间">3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</a>

<p><strong>第七节站内Link：</strong></p>
<a href="/2022/09/29/math_Essense_of_Linear_Algebra_P07/" title="3Blue1Brown_线代本质第七章：点积与对偶性">3Blue1Brown_线代本质第七章：点积与对偶性</a>

<p><strong>第八节站内Link：</strong></p>
<a href="/2022/10/03/math_Essense_of_Linear_Algebra_P08/" title="3Blue1Brown_线代本质第八章：叉积的标准介绍">3Blue1Brown_线代本质第八章：叉积的标准介绍</a>

<p><strong>第九节站内Link：</strong></p>
<a href="/2022/10/03/math_Essense_of_Linear_Algebra_P09/" title="3Blue1Brown_线代本质第九章：基变换">3Blue1Brown_线代本质第九章：基变换</a>

<p><strong>第十节站内Link：</strong></p>
<a href="/2022/10/06/math_Essense_of_Linear_Algebra_P10/" title="3Blue1Brown_线代本质第十章：特征向量与特征值">3Blue1Brown_线代本质第十章：特征向量与特征值</a>

<p><strong>第十一节站内Link：</strong></p>
<a href="/2022/10/07/math_Essense_of_Linear_Algebra_P11/" title="3Blue1Brown_线代本质第十一章：抽象向量空间">3Blue1Brown_线代本质第十一章：抽象向量空间</a>

<p><strong>第十二节站内Link：</strong></p>
<a href="/2022/10/08/math_Essense_of_Linear_Algebra_P12/" title="3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释">3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释</a>
]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini 中for-each 和for-loop 节点</title>
    <url>/2022/09/13/houdini_foreach/</url>
    <content><![CDATA[<h1 id="Houdini-中for-each-和for-loop-节点"><a href="#Houdini-中for-each-和for-loop-节点" class="headerlink" title="Houdini 中for-each 和for-loop 节点"></a>Houdini 中for-each 和for-loop 节点</h1><p>学习houdini时间不长，刚入门的时候就一直对foreach的使用比较迷糊，在这里写一篇学习笔记来认识一下这个使用方式，比较基础 。如果有问题，请各位大佬及时补充和指正！</p>
<hr>
<h2 id="Houdini中关于循环的节点简介："><a href="#Houdini中关于循环的节点简介：" class="headerlink" title="Houdini中关于循环的节点简介："></a>Houdini中关于循环的节点简介：</h2><p>houdini中一共给了这6个框架：<br><strong>1. for-each Number<br>2. for-each point<br>3. for-each primitive<br>4. for-each connected Piece<br>5. for-each Named Primitive<br>6. for-loop with Feedback</strong></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach2.png" alt="foreach2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach1.png" alt="foreach1"><br>（在这里说明我用的是houdini 18之后的版本，如果版本太靠前应该foreach节点跟这个有所出入）</p>
<ul>
<li>这个框架它本身的作用就是实现for循环，如果不想用它的框架，也可以自己创建Block begin和Block end来搭建for循环。</li>
<li>其中，<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>的构造是相似的，使用的方法也是一样的，只是针对的元素不同（点，面，name属性）</li>
<li><strong>connectivity</strong>是创造了一个class属性，根据class属性处理导入这个元素。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220921233222.png" alt="foreach2"></li>
<li>数据都是从Block Begin传入，我们中间可以任意添加节点来完成我们想要针对这个元素处理的操作，这个数据给每个元素循环处理后，最终由block end输出。end中可以选择Feedback Each Iteration来显示每一次结果，或者Merge Each Iteration来显示所有结果。</li>
</ul>
<h2 id="例子一：随机颜色："><a href="#例子一：随机颜色：" class="headerlink" title="例子一：随机颜色："></a>例子一：随机颜色：</h2><ul>
<li>针对<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>这四个框架可以做出此示例。</li>
<li>循环迭代次数不是自动给出的，需要通过Block Begin中的“Create meta import Node来创建；它的detail上会有iteration的参数。若我们希望使用foreach，来达到进入循环的元素被进行的处理或者操作有所变化，那么我们也是通过iteration来实现的。</li>
</ul>
<h3 id="for-each-point："><a href="#for-each-point：" class="headerlink" title="for-each point："></a>for-each point：</h3><ul>
<li>使用vex做一个简单的颜色随机，注意iteration不要写错<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_pt.png" alt="foreach_randCol_pt"></li>
</ul>
<h3 id="for-each-primitive："><a href="#for-each-primitive：" class="headerlink" title="for-each primitive："></a>for-each primitive：</h3><ul>
<li>对于primitive也是完全一样的<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_prim.png" alt="foreach_randCol_prim"></li>
</ul>
<h3 id="for-each-connected-Piece："><a href="#for-each-connected-Piece：" class="headerlink" title="for-each connected Piece："></a>for-each connected Piece：</h3><ul>
<li>对于for-each connected Piece，则是根据它的class属性，处理它连续的元素。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_connPiec.png" alt="foreach_randCol_class"></li>
</ul>
<h3 id="for-each-Named-Primitive："><a href="#for-each-Named-Primitive：" class="headerlink" title="for-each Named Primitive："></a>for-each Named Primitive：</h3><ul>
<li>for-each Named Primitive也是根据name属性来处理元素（属性是在piece attribute上的，可以更改，但必须保持输入输出的是一致的，否则不能匹配）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_name.png" alt="foreach_randCol_name"></li>
</ul>
<h2 id="for-each-Number的用法："><a href="#for-each-Number的用法：" class="headerlink" title="for-each Number的用法："></a>for-each Number的用法：</h2><ul>
<li>可以看出，它的Block Beginn中的method变成了“Fetch Input”，它的Block end中 Iteration Method变为了“By Count”。 他并不是对每个元素进行处理，而是对他本身进行拷贝，进入循环，它的迭代次数就是它的拷贝次数。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_number.png" alt="foreach_number"></li>
<li>由上示例，它每次的循环均为它的input，根据iteration的次数来做重复。</li>
</ul>
<h2 id="for-Loop的用法："><a href="#for-Loop的用法：" class="headerlink" title="for-Loop的用法："></a>for-Loop的用法：</h2><ul>
<li>for-loop with Feedback中，它的默认Block Beginn中的method是“Fetch FeedBack”，它的Block end中 Iteration Method是“By Count”；它的Gather Method则默认是Feedback Each Iteration。如果for-each Number是指对本身的元素进行处理，那么for-loop with Feedback就是对循环整体进行处理。</li>
<li>它是以上一个循环的end的结果作为下一次循环的起点，进行再次循环，一直循环操作我们在循环内设置的指令，直到迭代次数结束。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop.png" alt="forLoop"></li>
<li>由上图示例，这个rubbertoy朝着x轴正向移动，每次移动单位为1米，循环了五次，移动到现在5米的位置。</li>
<li>下图是merge each iteration，显示每次循环结果，可以更清晰看出。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop_MergeEachIteration.png" alt="forLoop_MergeEachIteration"></li>
</ul>
]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-Houdini节点</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini湖边小屋学习（一）</title>
    <url>/2022/09/13/houdini_lakeHouse_p1/</url>
    <content><![CDATA[<p>🐸本文为我的houdini湖边小屋笔记第一篇内容，作为我PCG的进阶学习部分来记录一下~~~<br>🐸目前是<strong>第一篇</strong><br>🐸加油加油！</p>
<hr>
<h1 id="湖边小屋第一篇"><a href="#湖边小屋第一篇" class="headerlink" title="湖边小屋第一篇"></a>湖边小屋第一篇</h1><h2 id="第一部分-Base-shape："><a href="#第一部分-Base-shape：" class="headerlink" title="第一部分 Base shape："></a>第一部分 Base shape：</h2>]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-PCG</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2022/09/13/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："><a href="#注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：" class="headerlink" title="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："></a>注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：</h3><ol>
<li>markdown all in one</li>
<li>markdown preview Enhanced</li>
<li>pasted Image    &#x2F;&#x2F;这个跟别的博主学的，用于方便copy网页图片。个人来说如果单纯本地预览确实超级方便，但是对于我来说有点鸡肋，然后放在本地并不是很好管理。</li>
</ol>
<p><strong>学到了新的我也会持续更新加在后面</strong></p>
<hr>
<h1 id="一：标题："><a href="#一：标题：" class="headerlink" title="一：标题："></a>一：标题：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这篇文章用来学习markdown语法，这是一级标题。#H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 这篇文章用来学习markdown语法，这是二级标题。#H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 这篇文章用来学习markdown语法，这是三级标题。#H3</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 其实切换起来多加几个#号就可以了，这里是四级标题。#H4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong></p>
<h1 id="这篇文章用来学习markdown语法，这是一级标题。-H1"><a href="#这篇文章用来学习markdown语法，这是一级标题。-H1" class="headerlink" title="这篇文章用来学习markdown语法，这是一级标题。#H1"></a>这篇文章用来学习markdown语法，这是一级标题。#H1</h1><h2 id="这篇文章用来学习markdown语法，这是二级标题。-H2"><a href="#这篇文章用来学习markdown语法，这是二级标题。-H2" class="headerlink" title="这篇文章用来学习markdown语法，这是二级标题。#H2"></a>这篇文章用来学习markdown语法，这是二级标题。#H2</h2><h3 id="这篇文章用来学习markdown语法，这是三级标题。-H3"><a href="#这篇文章用来学习markdown语法，这是三级标题。-H3" class="headerlink" title="这篇文章用来学习markdown语法，这是三级标题。#H3"></a>这篇文章用来学习markdown语法，这是三级标题。#H3</h3><h4 id="其实切换起来多加几个-号就可以了，这里是四级标题。-H4"><a href="#其实切换起来多加几个-号就可以了，这里是四级标题。-H4" class="headerlink" title="其实切换起来多加几个#号就可以了，这里是四级标题。#H4"></a>其实切换起来多加几个#号就可以了，这里是四级标题。#H4</h4><hr>
<h1 id="二：正文："><a href="#二：正文：" class="headerlink" title="二：正文："></a>二：正文：</h1><p>这样直接写就是正文。<br>末尾添加多余两个空格再回车，实现创建换行</p>
<p>换了一行<br>又换了一行   </p>
<p>空一行，换了一段。（换行换段我这里自动识别了）</p>
<hr>
<h1 id="三：加粗，斜体，斜体加粗，删除线："><a href="#三：加粗，斜体，斜体加粗，删除线：" class="headerlink" title="三：加粗，斜体，斜体加粗，删除线："></a>三：加粗，斜体，斜体加粗，删除线：</h1><p><strong>tips：（ctl+shift+home是选中当前行鼠标前内容，end当前行末，home当前行首）</strong></p>
<h3 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h3><p>加粗前后各（** ）包住</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**我现在变粗体了**</span></span><br><span class="line"><span class="strong">**也可也ctl+b加粗**</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong><br><strong>我现在变粗体了</strong><br><strong>也可也ctl+b加粗</strong></p>
<hr>
<h3 id="斜体，斜体加粗："><a href="#斜体，斜体加粗：" class="headerlink" title="斜体，斜体加粗："></a>斜体，斜体加粗：</h3><p>斜体前后各（* )包住<br>斜体并加粗就是前后各(*** )包住</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*我现在歪了*</span>   //斜体</span><br><span class="line"><span class="strong">**<span class="emphasis">*也可也ctl+i选中变成斜体，然后再ctl+b加粗*</span>**</span> //<span class="strong">**<span class="emphasis">*这样三个是斜体加粗</span></span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong><br><em>我现在歪了</em><br><em><strong>也可也ctl+i选中变成斜体</strong></em></p>
<hr>
<h3 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h3><p>要加删除线的文字左右分别用两个~~号包起来</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~我被杠掉了~~</span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong><br><del>我被杠掉了</del></p>
<hr>
<h1 id="四：引用，分割线："><a href="#四：引用，分割线：" class="headerlink" title="四：引用，分割线："></a>四：引用，分割线：</h1><p>引用：在引用的文字前加&gt;就行。引用也可以嵌套，只要不断&gt;&gt;&gt;&gt;&gt;&gt;就行。<br>分割线：分割线就是三个或以上的-或者*</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="line"><span class="section">---                          //分割线</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*                          //分割线</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="五：序号，段落小圆点："><a href="#五：序号，段落小圆点：" class="headerlink" title="五：序号，段落小圆点："></a>五：序号，段落小圆点：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">   1.</span> 这样是有序，（1.+空格），换行会自动添加第二个序号</span><br><span class="line"><span class="bullet">   2.</span> 这样就有第二个序号</span><br><span class="line"><span class="bullet">   3.</span> - 第三行打个这样形式的</span><br><span class="line"><span class="bullet">      1.</span> tab，二级序号</span><br><span class="line"><span class="bullet">      2.</span> 二级序号第二个</span><br><span class="line"><span class="bullet">      3.</span> 二级序号第三个</span><br><span class="line"><span class="bullet">      4.</span> 第四</span><br><span class="line"><span class="code">          如果直接换一行，换行是这样的。</span></span><br><span class="line"><span class="code">如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内</span></span><br><span class="line"><span class="code">         1. 三级序号</span></span><br><span class="line"><span class="code">         66. 如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</span></span><br><span class="line"><span class="code">         - 这样打是个小圆点点（-加一个空格）</span></span><br><span class="line"><span class="code">         - 换行会自动给你补全这个小圆点</span></span><br><span class="line"><span class="code">         </span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<ol>
<li>这样是有序，（1.+空格），换行会自动添加第二个序号</li>
<li>这样就有第二个序号</li>
<li><ul>
<li>第三行打个这样形式的</li>
</ul>
<ol>
<li>tab，二级序号</li>
<li>二级序号第二个</li>
<li>二级序号第三个</li>
<li>第四<br> 如果直接换一行，换行是这样的。<br>如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内<ol>
<li>三级序号</li>
<li>如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</li>
</ol>
<ul>
<li>这样打是个小圆点点（-加一个空格）</li>
<li>换行会自动给你补全这个小圆点</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="六：添加图片："><a href="#六：添加图片：" class="headerlink" title="六：添加图片："></a>六：添加图片：</h1><p><strong>网络图片链接：</strong><br>ctl+alt+v，粘贴从在线网页上复制的内容，使用了拓展包，所以默认会加载到正在编辑的markdown的文件夹下<br>网络图片可以直接使用它的链接（不过网络图片连接很可能不知道啥时候就挂了，我自己用的图床是阿里云OSS，先测试几个月看看效果）</p>
<p><strong>markdown源码（此图片来自网络，如侵权，可联系删除）：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">beishangwa</span>](<span class="link">https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg</span>)</span><br></pre></td></tr></table></figure>
<p>下面的图就是网页上copy下来的悲伤蛙渲染效果。使用 ![]() 来链接图片。</p>
<p><img src="https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg" alt="beishangwa"></p>
<p><strong>本地图片链接方式：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">./beishangwa.png</span>)</span><br></pre></td></tr></table></figure>
<p>如果这样的话就可以使用本地的悲伤蛙（找不到路径需要.&#x2F;一下，vs可以识别路径里的图，这里估计会挂，我本地应该不在这个路径，建议放在相应的md文件夹内方便定义路径）</p>
<hr>
<h1 id="七：转义字符："><a href="#七：转义字符：" class="headerlink" title="七：转义字符："></a>七：转义字符：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| character | name     |</span><br><span class="line">| --------- | -------- |</span><br><span class="line">| \\        | 反斜杠   |</span><br><span class="line">| \`        | 反引号   |</span><br><span class="line">| \<span class="emphasis">*        | 星号     |</span></span><br><span class="line"><span class="emphasis">| \_        | 下划线   |</span></span><br><span class="line"><span class="emphasis">| \&#123;\&#125;      | 大括号   |</span></span><br><span class="line"><span class="emphasis">| \[\]      | 中括号   |</span></span><br><span class="line"><span class="emphasis">| \(\)      | 小括号   |</span></span><br><span class="line"><span class="emphasis">| \#        | 井号     |</span></span><br><span class="line"><span class="emphasis">| \+        | 加号     |</span></span><br><span class="line"><span class="emphasis">| \-        | 减号     |</span></span><br><span class="line"><span class="emphasis">| \.        | 英文句号 |</span></span><br><span class="line"><span class="emphasis">| \!        | 感叹号   |</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<table>
<thead>
<tr>
<th>character</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>{}</td>
<td>大括号</td>
</tr>
<tr>
<td>[]</td>
<td>中括号</td>
</tr>
<tr>
<td>()</td>
<td>小括号</td>
</tr>
<tr>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>-</td>
<td>减号</td>
</tr>
<tr>
<td>.</td>
<td>英文句号</td>
</tr>
<tr>
<td>!</td>
<td>感叹号</td>
</tr>
</tbody></table>
<hr>
<h1 id="八：表格"><a href="#八：表格" class="headerlink" title="八：表格"></a>八：表格</h1><p>(源码在vs显示的格式化修改：alt+shift+f)<br>表格中均默认左对齐，右对齐使用—后加：，或者居中对齐使用—前后各：：</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">##### 左对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---- | -------- |</span><br><span class="line">| 悲伤蛙 | 绿   | 蛙子     |</span><br><span class="line">| 哈士奇 | 黑白 | 狗子     |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 右对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---: | -------: |</span><br><span class="line">| 悲伤蛙 |   绿 |     蛙子 |</span><br><span class="line">| 哈士奇 |   黑 |     狗子 |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 居中对齐：</span></span><br><span class="line">| 姓名   | 颜色  | 种族类型 |</span><br><span class="line">| ------ | :---: | :------: |</span><br><span class="line">| 悲伤蛙 |  绿   |   蛙子   |</span><br><span class="line">| 哈士奇 |  黑   |   狗子   |</span><br></pre></td></tr></table></figure>


<p><strong>渲染效果：</strong></p>
<h5 id="左对齐："><a href="#左对齐：" class="headerlink" title="左对齐："></a>左对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th>颜色</th>
<th>种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td>绿</td>
<td>蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td>黑白</td>
<td>狗子</td>
</tr>
</tbody></table>
<h5 id="右对齐："><a href="#右对齐：" class="headerlink" title="右对齐："></a>右对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th align="right">颜色</th>
<th align="right">种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td align="right">绿</td>
<td align="right">蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td align="right">黑</td>
<td align="right">狗子</td>
</tr>
</tbody></table>
<h5 id="居中对齐："><a href="#居中对齐：" class="headerlink" title="居中对齐："></a>居中对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th align="center">颜色</th>
<th align="center">种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td align="center">绿</td>
<td align="center">蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td align="center">黑</td>
<td align="center">狗子</td>
</tr>
</tbody></table>
<hr>
<h1 id="九：正文对齐方式："><a href="#九：正文对齐方式：" class="headerlink" title="九：正文对齐方式："></a>九：正文对齐方式：</h1><p>markdown我查了一下好像是没有对齐的，但是它基本支持html的语法，所以我们可以写成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">**居中对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**左对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**右对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<p><strong>居中对齐：</strong></p>
<center>帅哥美女一键三连</center>

<p><strong>左对齐：</strong></p>
<p align="left">帅哥美女一键三连</p>

<p><strong>右对齐：</strong></p>
<p align="right">帅哥美女一键三连</p>

<hr>
<h1 id="十：插入链接"><a href="#十：插入链接" class="headerlink" title="十：插入链接"></a>十：插入链接</h1><p>还是ctl + C 然后选中需要添加链接的文字ctl + V<br>这是一个<a href="https://markdown.com.cn/basic-syntax/">markdown语法</a>链接</p>
<hr>
<h1 id="十一：代码框"><a href="#十一：代码框" class="headerlink" title="十一：代码框"></a>十一：代码框</h1><p>代码前后使用&#96;&#96;&#96;包裹,并指定一种语言</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\  <span class="code">```markdown</span></span><br><span class="line"><span class="code">      中间是内容</span></span><br><span class="line"><span class="code">\  ```</span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">中间是内容</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="十二-hexo内插入网页视频"><a href="#十二-hexo内插入网页视频" class="headerlink" title="十二: hexo内插入网页视频"></a>十二: hexo内插入网页视频</h1><h5 id="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"><a href="#目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）" class="headerlink" title="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"></a>目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）</h5><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=939470868&amp;bvid=BV1VT4y1B7QL&amp;cid=731375438&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">height: 100%; left: 0; top: 0;&quot;</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=939470868&bvid=BV1VT4y1B7QL&cid=731375438&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>



<hr>
<h1 id="十三-emoji"><a href="#十三-emoji" class="headerlink" title="十三: emoji"></a>十三: emoji</h1><p>推荐网站<a href="https://emojipedia.org/">emojipedia</a><br>直接复制粘贴就好，可以正确渲染<br>示例：<br>🍇<br>🐗<br>🙃<br>🗻</p>
<hr>
<p>当然，也可以使用 <a href="https://unicode.org/emoji/charts/full-emoji-list.html">full emoji list</a><br>格式：<code>&amp;#x  +unicode + ;</code></p>
<p>范例：<br><code>&amp;#x1F601;</code><br><code>&amp;#x1F602;</code></p>
<p>渲染效果：<br>&amp;#x1F601;<br>&amp;#x1F602;</p>
<hr>
<h1 id="十四-图床"><a href="#十四-图床" class="headerlink" title="十四: 图床"></a>十四: 图床</h1><p>我配置的是阿里云OSS + PicGo + vscode的方案<br>由于我的编辑器是vscode，所以在vscode上传图片的快捷键如下：</p>
<p>上传截图：ctl+alt+u</p>
<hr>
<p><strong><center>待续，学到后再加</center></strong></p>
]]></content>
      <categories>
        <category>-Markdown</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini去年（2022）的程序化生成总结~</title>
    <url>/2023/06/19/houdini_procedural_modeling2022/</url>
    <content><![CDATA[<h1 id="😈总结一下去年（2022）的Houdini"><a href="#😈总结一下去年（2022）的Houdini" class="headerlink" title="😈总结一下去年（2022）的Houdini~"></a>😈总结一下去年（2022）的Houdini~</h1><blockquote>
<p>🍺最开始做Houdini程序化资产的时候还没有现在这个个人网站，于是现在填补一下发发，总结一下<br>🍺嘛~ 现在有一阵子没碰houdini了，希望最近继续富有激情的学习Houdini~</p>
</blockquote>
<ul>
<li>以下的Breakdown均发在bilibili了，连接也会在下面放出~ 其实都是最开始接触Houdini的时候做的，当时最感兴趣的还得是Sop模块，现在看来我做的不太好，只能说今年还会继续改进。</li>
<li>当然了~ 目前已经开始着手学习Houdini到UE5这一流程，请期待后续的更新！</li>
</ul>
<h2 id="👻BreakDown视频"><a href="#👻BreakDown视频" class="headerlink" title="👻BreakDown视频"></a>👻BreakDown视频</h2><blockquote>
<p>以下是三个Breakdown,具体放在我的Blibili了，可以点击查看~<br><a href="https://www.bilibili.com/video/BV1VT4y1B7QL/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">1.City In The Sky</a><br><a href="https://www.bilibili.com/video/BV1vW4y1U7Ly/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">2.TrainNight</a><br><a href="https://www.bilibili.com/video/BV1te411u7TE/?spm_id_from=333.999.0.0&vd_source=95a1cfccd5b1e6779677de477b25aa31">3.Env</a></p>
</blockquote>
<h2 id="👻BreakDown图文"><a href="#👻BreakDown图文" class="headerlink" title="👻BreakDown图文"></a>👻BreakDown图文</h2><h3 id="City-In-the-Sky"><a href="#City-In-the-Sky" class="headerlink" title="City In the Sky"></a>City In the Sky</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_01.png" alt="Tech_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_02.png" alt="Tech_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ivyTool.gif" alt="ivyTool"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bricksGenerator.gif" alt="bricksGenerator"></p>
<hr>
<h3 id="TrainNight"><a href="#TrainNight" class="headerlink" title="TrainNight"></a>TrainNight</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_03.png" alt="Tech_03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_04.png" alt="Tech_04"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/nt-bdgenerator.gif" alt="nt-bdgenerator"></p>
<hr>
<h3 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Tech_05.png" alt="Tech_05"></p>
<ul>
<li>详细展示可以查阅我的b站<a href="https://space.bilibili.com/552910222?spm_id_from=333.788.0.0">ZeTiiCannotStop</a>，也欢迎去b站私信我与我讨论~</li>
</ul>
]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-procedural modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</title>
    <url>/2022/09/22/math_Essense_of_Linear_Algebra_P02/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第二章：线性组合，张成的空间与基"><a href="#3Blue1Brown-线代本质第二章：线性组合，张成的空间与基" class="headerlink" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基"></a>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第二章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️基向量："><a href="#✏️基向量：" class="headerlink" title="✏️基向量："></a>✏️基向量：</h2><h3 id="✍️在xy坐标系中两个特殊向量："><a href="#✍️在xy坐标系中两个特殊向量：" class="headerlink" title="✍️在xy坐标系中两个特殊向量："></a>✍️在xy坐标系中两个特殊向量：</h3><ul>
<li>一个指向正右方，长度为1，通常被称为“i-hat”（i帽）或x方向的单位向量。</li>
<li>另一个指向正上方，长度为1，通常被称为“j-hat”（j帽）或者y方向的单位向量。</li>
<li><strong>i-hat与j-hat这两个向量有特殊的名称，他们是xy坐标轴的“基向量”（basis vector）。</strong></li>
<li>这是在表述：当你把坐标看为标量时，基向量实际上就是这些标量的缩放对象。</li>
</ul>
<hr>
<h3 id="✍️例子1："><a href="#✍️例子1：" class="headerlink" title="✍️例子1："></a>✍️例子1：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ihat_jhat.png" alt="ihat_jhat"></p>
<ul>
<li><strong>由上图示意看出，（3，-2）可以想象为</strong>：x坐标是一个标量，它将i帽拉升为原来的三倍；y坐标也是一个标量，它将j帽反向并拉伸为原来的两倍。从这个角度看，这个向量实际上是两个经过缩放的向量的和。</li>
<li>“<strong>缩放向量并且相加</strong>”这一概念十分重要。</li>
</ul>
<hr>
<h3 id="✍️如果我们选择不同的基向量会怎么样："><a href="#✍️如果我们选择不同的基向量会怎么样：" class="headerlink" title="✍️如果我们选择不同的基向量会怎么样："></a>✍️如果我们选择不同的基向量会怎么样：</h3><ul>
<li><strong>我们完全可以选择不同的基向量，获得一个合理的新坐标系。</strong></li>
<li>比如随便选一个指向右上方的向量，再随便选择一个指向右下方的向量，想象通过选择两个标量，分别用于缩放二者的其中一个， 然后把他们相加，就可以得到不同的结果。通过改变所选择的向量，我们可以得到所有向量。</li>
<li>一对新的基向量，同样允许我们在一对数和二维向量之间自由转化。但是这种变化关系与我们之前使用的i帽和j帽的变化关系完全不同。</li>
<li><strong>每当我们用数字描述向量的时候，它都依赖于我们正在使用的基。</strong></li>
<li><strong>两个数乘向量的和被称为这两个向量的线性组合（Linear combination）。</strong></li>
<li><strong>那么线性怎么来的可以考虑为：</strong> 如果固定其中一个标量，让另一个标量自由变化，所产生的终点会描述出一条直线，如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/linearCombination.png" alt="linearCombination"></li>
</ul>
<hr>
<ul>
<li><strong>如果让两个标量同时自由变换，考虑所有可得到的向量，可能有两种情况（实际是三种）：</strong><ol>
<li>大部分情况下，对于一对初始向量，你能达到平面中每一个点；所有二维向量都尽在掌握。</li>
<li>另一种较为糟糕的情况是，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上。</li>
<li>事实上还有第三种情况就是，两个向量都是零向量,那就只能在原点了。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="向量变换的三种情况"></li>
</ol>
</li>
</ul>
<hr>
<h2 id="✏️张成空间（span）："><a href="#✏️张成空间（span）：" class="headerlink" title="✏️张成空间（span）："></a>✏️张成空间（span）：</h2><p><strong>概念：</strong><br>    - <strong>所有可以表示为给定向量线性组合的向量的集合，被成为给定向量张成的空间。</strong></p>
<ul>
<li>下图：向量全部线性组合构成的向量集合成为“张成的空间”，a与b在实数范围内变动。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%BC%A0%E6%88%90%E7%A9%BA%E9%97%B4.png" alt="张成空间"></li>
</ul>
<h3 id="✍️二维空间内张成空间："><a href="#✍️二维空间内张成空间：" class="headerlink" title="✍️二维空间内张成空间："></a>✍️二维空间内张成空间：</h3><ul>
<li>通常情况下，我们用向量的终点代表向量（起点是原点）；用这种方法来看，如果要考虑落在一条直线上所有向量的时候，只需要考虑直线本身就行了。所以也可以考虑为，如果同时考虑xy坐标系中所有向量，将每个向量抽象为它的终点，实际上就不用考虑所有的肩头了，只需要考虑无限大的二维平面本身即可。</li>
<li>如果考虑一个向量，我们就可以把他看作箭头；如果考虑多个向量，则可以把他们都看作是点。</li>
<li>对大部分二维向量来说，它们的张成空间是整个无限大的二维平面；但如果共线，他们的张成空间就是一条直线。</li>
</ul>
<hr>
<h3 id="✍️三维空间内张成空间："><a href="#✍️三维空间内张成空间：" class="headerlink" title="✍️三维空间内张成空间："></a>✍️三维空间内张成空间：</h3><h4 id="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："><a href="#在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：" class="headerlink" title="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："></a>在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="两个向量在三维空间"></p>
<ul>
<li>这两个向量的张成空间就是他们所有可能的线性组合；也就是缩放再相加之后所有可得到的向量。</li>
<li>逐渐改变线性组合中的这两个标量，把缩放后的向量相加，然后跟着最终向量的终点走，这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量的张成空间。（所有终点落在这个平面上的向量集合是这两个向量的张成空间）</li>
</ul>
<h4 id="如果加上第三个向量，他们的张成空间是这样的："><a href="#如果加上第三个向量，他们的张成空间是这样的：" class="headerlink" title="如果加上第三个向量，他们的张成空间是这样的："></a>如果加上第三个向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="三个向量在三维空间"></p>
<ul>
<li>选择三个向量分别进行缩放，然后把结果相加。</li>
<li>这三个向量所有可能的线性作何构成了他们的张成空间。</li>
<li>如果第三个向量恰好落在前两个向量所张成的平面上，那么他们张成的空间并不改变，还是在这个平面中。</li>
<li>但是如果随机选一个向量，他几乎不可能落在前两个向量所张成的平面中；这种情况下，由于第三个向量指向不同的方向，我们就能得到所有的三维向量。（可以考虑成：当我们缩放第三个向量的时候，他将前两个向量张成平面来回沿着它的方向移动，从而扫过整个三维空间。）</li>
</ul>
<hr>
<h2 id="✏️Linearly-dependent-和-Linearly-Independent："><a href="#✏️Linearly-dependent-和-Linearly-Independent：" class="headerlink" title="✏️Linearly dependent 和 Linearly Independent："></a>✏️Linearly dependent 和 Linearly Independent：</h2><h4 id="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："><a href="#当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：" class="headerlink" title="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："></a>当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：</h4><ul>
<li>这种情况说明一组向量中至少有一个是多余的，没有对张成空间做出任何贡献，我们取走这个多余的向量也不减少张成空间，这样的情况下，我们称它为“<strong>线性相关</strong>”（<strong>Linearly dependent</strong>）的。</li>
</ul>
<h4 id="如果所有向量都给张成空间添加了新的维度："><a href="#如果所有向量都给张成空间添加了新的维度：" class="headerlink" title="如果所有向量都给张成空间添加了新的维度："></a>如果所有向量都给张成空间添加了新的维度：</h4><ul>
<li>这种情况就称之为“<strong>线性无关</strong>”（<strong>Linearly Independent</strong>）的。</li>
</ul>
<hr>
<h2 id="✏️基的严格定义（Technical-definition-of-basis）："><a href="#✏️基的严格定义（Technical-definition-of-basis）：" class="headerlink" title="✏️基的严格定义（Technical definition of basis）："></a>✏️基的严格定义（Technical definition of basis）：</h2><ul>
<li>The basis of a vector space is a set of linearly independent vectors that span the full space<br>(向量空间的一组基是张成该空间的一个线性无关向量集)<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89.png" alt="基的严格定义"></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换</title>
    <url>/2022/09/25/math_Essense_of_Linear_Algebra_P04/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合"><a href="#3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合" class="headerlink" title="3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合"></a>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第四章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<p>【<strong>注：本章笔记是第四章加附注一的笔记，也就是《矩阵乘法与线性变换复合》加《三维空间中的线性变换》。</strong>】</p>
<h2 id="✏️线性复合变换："><a href="#✏️线性复合变换：" class="headerlink" title="✏️线性复合变换："></a>✏️线性复合变换：</h2><ul>
<li>有时候，我们常常是想要做多种变换，比如“先旋转，后剪切”；这个新的线性变换通常被称为前两个独立变换的“<strong>复合变换</strong>”（Composition）。</li>
<li>和其他变换一样，我们可以通过追踪i帽和j帽的变换，并用矩阵完全描述这个复合变换。</li>
<li>两个矩阵相乘有着几何意义，也就是<strong>两个线性变换相继作用</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5.png" alt="复合矩阵"></li>
<li>这个矩阵需要从右向左读；首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换。</li>
<li>它起源于函数的记号，因为我们将函数写在变量左侧。所以每次将两个函数复合的时候，我们需要从右往左读。</li>
</ul>
<hr>
<h3 id="✍️复合矩阵的计算："><a href="#✍️复合矩阵的计算：" class="headerlink" title="✍️复合矩阵的计算："></a>✍️复合矩阵的计算：</h3><ul>
<li>我们希望对复合矩阵进行计算的时候，计算结果的第一列我们首先要考虑：<strong>i帽去哪里了？</strong></li>
<li>下图看出，i帽首先落在（1，1）。所以我们在计算时首先将示例中的M1的第一列（1，1）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第一列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_i%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_i帽变换"></li>
<li>其次，我们要考虑第二列：<strong>j帽去哪了？</strong></li>
<li>与上文中提到的i帽的计算方式一样，j帽先落在（-2，0），所以我们在计算时将示例中的M1的第一列（-2，0）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第二列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_j%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_j帽变换"></li>
<li>这一推理具有普适性，对任意矩阵都适用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="矩阵乘法公式"></li>
</ul>
<h3 id="✍️注意矩阵计算顺序不可对调："><a href="#✍️注意矩阵计算顺序不可对调：" class="headerlink" title="✍️注意矩阵计算顺序不可对调："></a>✍️注意矩阵计算顺序不可对调：</h3><ul>
<li><strong>矩阵乘法不具有交换律。</strong></li>
<li>如之前的推导公式中，M1M2≠M2M1；即在矩阵运算中“先剪切，后旋转”并不等于“先旋转，后剪切”。</li>
<li>乘积顺序影响整体的计算。</li>
</ul>
<h3 id="✍️结合律（Associativity）："><a href="#✍️结合律（Associativity）：" class="headerlink" title="✍️结合律（Associativity）："></a>✍️结合律（Associativity）：</h3><ul>
<li><strong>矩阵乘法满足结合律</strong>。</li>
<li><strong>A（BC） &#x3D; （AB）C</strong></li>
<li>空间变换来看，线性变换的作用对象是向量，这个计算是线性变换的复合，而不是指把一个作用于另一个。</li>
<li>以上的等式左边是在说：首先应用C变换和B变换，然后应用A变换；等式右边还是在说：首先应用C变换，其次应用B变换和A变换。</li>
<li>这只是将同样的三个变换用同样的顺序依次总用，换句话说就是：添加括号与结果无关，他们的计算顺序没有变化（记住矩阵变换始终是从右往左读的）。括号的意义在这里表示某两个要一起做，而不是他们做的顺序提前。</li>
</ul>
<hr>
<hr>
<hr>
<h2 id="✏️三维空间中的线性变换："><a href="#✏️三维空间中的线性变换：" class="headerlink" title="✏️三维空间中的线性变换："></a>✏️三维空间中的线性变换：</h2><ul>
<li>考虑这样一个线性变换，他以三维向量为输入，并以三维向量为输出；我们可以想象他在移动三维空间中的所有点，保持网格线平行且等距分布，并保持原点不动。</li>
<li>和二维的情形一样，我们看见三维空间中每一个点实际上只是用来代表以它本身为终点的一个向量；而我们所做的变换只是将输入向量移动至对应向量。</li>
<li>三维线性的变换由基向量的去向完全决定。</li>
<li>此时就有3个基向量，分别是x方向的i帽，y方向的j帽，z方向的k帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="三维空间的变换"></li>
<li>将变换后的三个基向量的坐标记录在一个3x3的矩阵中。这九个数字就完全描述了一个线性变换。</li>
<li>三维空间内向量的变换公式推导与二维空间几乎一致，它每个坐标都可以看作对相应基向量的缩放。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x3%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2.png" alt="3x3矩阵变换"></li>
<li>3x3矩阵的运用十分广泛,如计算机图形学（Computer Graphics）与机器人学（Robotics）。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第三章：矩阵与线性变换</title>
    <url>/2022/09/24/math_Essense_of_Linear_Algebra_P03/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第三章：矩阵与线性变换"><a href="#3Blue1Brown-线代本质第三章：矩阵与线性变换" class="headerlink" title="3Blue1Brown_线代本质第三章：矩阵与线性变换"></a>3Blue1Brown_线代本质第三章：矩阵与线性变换</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第三章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️线性变换："><a href="#✏️线性变换：" class="headerlink" title="✏️线性变换："></a>✏️线性变换：</h2><p>【<strong>注</strong>：这章节讨论在二维空间的样子，以及与矩阵向量乘法的关联，并展示一种不用死记硬背的考虑矩阵向量乘法的方法。】</p>
<h3 id="✍️解析“线性变换”："><a href="#✍️解析“线性变换”：" class="headerlink" title="✍️解析“线性变换”："></a>✍️解析“线性变换”：</h3><ul>
<li>Linear Transformation &#x3D; Linear Function</li>
<li>“变换”（Transformation）本质上是“函数”（function）的一种花哨的说法；它接受输入内容，并输出对应结果。</li>
<li>变换和函数意义相同还要用不同的词汇表达的原因是：使用“变换”是在暗示以特定的方式来可视化这一“输入”“输出”关系；“变换”这个词在按时我们用运动去思考。</li>
<li>每一个输入向量都移动到输出向量的位置：将向量看作是点，那么变换就是空间中的点移动到其他点的位置。</li>
<li><strong>直观的说，如果一个变换具有以下两条性质，我们就可以称它是线性的</strong>：<br>  <strong>1. 直线在变换后仍然保持为直线，不能有所弯曲。</strong><br>  <strong>2. 原点保持固定。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99.png" alt="线性变换规则"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220924214734.png" alt="20220924214734"></li>
<li><strong>总的来说，可以把线性变换看作是“保持网格线平行且等距分布”的变换</strong>。部分线性变换比较容易思考，如：网格以原点为轴心进行旋转；其他的则稍加复杂。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="线性变换"></li>
</ul>
<hr>
<h3 id="✍️如何用数值描述线性变换："><a href="#✍️如何用数值描述线性变换：" class="headerlink" title="✍️如何用数值描述线性变换："></a>✍️如何用数值描述线性变换：</h3><ul>
<li><p>我们给出一个向量坐标，希望得到一个变换后向量的坐标只需要通过：</p>
<ul>
<li><strong>记录两个基向量i帽和j帽变换后的位置，其他向量也会随之而动</strong></li>
</ul>
</li>
<li><p>由下图可视，向量v的坐标原本为（-1，2），这个向量可以看作为-1与i帽之积和2与j帽之基的和。如果运用一些变换，使得向量一起运动，并尊重“网格保持平行且等距分布”这个原则，变换后的向量v的位置，就是-1与变换后i帽之积加上2与变换后j帽之积。</p>
</li>
<li><p>换句话说，向量v是i帽和j帽的一个特定线性组合；那么变换后的向量v也是变换后i帽与j帽同样的线性组合。这就意味着，你可以只根据变换后的i帽与j帽，就推断出变化后的v。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E5%80%BC%E6%8F%8F%E8%BF%B0%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="数值描述线性变换"></p>
</li>
<li><p>一般情况下，一个向量的坐标是（x，y），变换后的向量就是x乘变换后的i帽，加上y乘变换后的j帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%85%AC%E5%BC%8Fpng.png" alt="公式png"></p>
</li>
<li><p>一个二维线性变换仅由四个数字完全确定：变换后i帽的两个坐标与变换后j帽的两个作坐标。</p>
</li>
<li><p>通常我们将这些坐标装在一个2x2的格子中，称它为2x2矩阵。</p>
</li>
</ul>
<hr>
<h2 id="✏️矩阵："><a href="#✏️矩阵：" class="headerlink" title="✏️矩阵："></a>✏️矩阵：</h2><ul>
<li>如果有一个描述线性变换的2x2矩阵，以及一个给定的初始向量，你只需要取初始向量的坐标，将他们分别于矩阵的特定列相乘，然后结果相加即可。这与“缩放基向量再相加”的思想一致。</li>
<li><strong>矩阵在这里只是一个记号，它含有描述线性变换的信息。</strong></li>
<li>如下图所示：我们可以把矩阵的第一列（a，c）看作是变换后第一个基向量，把第二列（b，d）看作是变换后第二个基向量；我们将这个变换作用于向量（x，y），它的结果就是（ax+by，cx+dy）。我们可以把它定义为<strong>矩阵向量乘法</strong>。<strong>矩阵放在向量左边，类似一个函数</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x2%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F.png" alt="2x2矩阵公式"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E4%B9%98%E6%B3%95.png" alt="矩阵向量乘法"></li>
<li><strong>我们完全可以把矩阵的列看作变换后的基向量，把矩阵向量的乘法看作他们的线性组合。</strong></li>
<li>线性变换是操纵空间的一种手段；这种变换只需要几个数字就可以描述清楚，这些数字就是变换后的基向量的坐标。</li>
</ul>
<hr>
<h3 id="✍️示例：逆时针旋转90度"><a href="#✍️示例：逆时针旋转90度" class="headerlink" title="✍️示例：逆时针旋转90度"></a>✍️示例：逆时针旋转90度</h3><ul>
<li>如下图示例，i帽初始为（1，0），j帽初始为（0，1）；如果将他们逆时针旋转90度，那么变换后的i帽就是（0，-1），j帽就是（-1，0）。</li>
<li>如果此时我们想计算一个向量逆时针旋转90度：可以直接将这个向量（x，y）与变换后的i帽与j帽相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E9%80%86%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC90%E5%BA%A6%E6%A1%88%E4%BE%8B.png" alt="向量逆时针旋转90度案例"></li>
</ul>
<hr>
<h3 id="✍️Shear（剪切-x2F-错切）："><a href="#✍️Shear（剪切-x2F-错切）：" class="headerlink" title="✍️Shear（剪切&#x2F;错切）："></a>✍️Shear（剪切&#x2F;错切）：</h3><ul>
<li>i帽保持为（1，0），j帽移动到坐标（1，1）。为了计算一个向量变换后的位置，可以直接将向量与这个矩阵相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220925165136.png" alt="shear"></li>
</ul>
<hr>
<h3 id="✍️反向思考："><a href="#✍️反向思考：" class="headerlink" title="✍️反向思考："></a>✍️反向思考：</h3><ul>
<li>如果我们希望推测一个矩阵代表的线性变换是什么样的，我们可以将i帽与j帽先移动到变换后的位置，空间其他剩余部分则跟随二者一起运动，以保持网格线平行且等距分布。</li>
<li>如果变换后的i帽和变换后的j帽是线性相关的，意味着其中一个向量是另一个的倍数，那么这个线性变换将整个二维空间挤压到他们所在的一条直线上，也就是这儿两个线性相关向量所张成的一维空间。</li>
</ul>
<hr>
<h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><ul>
<li><strong>总之，线性变换是操纵空间的一种手段，它保持网格线平行且等距分布，并且保持原点不动。</strong></li>
<li>这种变换只需要几个数字就能够描述清楚，这些数字就是变换后基向量的坐标；以这些坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言。矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。</li>
<li>矩阵都可以理解为对空间的一种特定变换。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第一章：向量究竟是什么</title>
    <url>/2022/09/22/math_Essense_of_Linear_Algebra_P01/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第一章：向量究竟是什么"><a href="#3Blue1Brown-线代本质第一章：向量究竟是什么" class="headerlink" title="3Blue1Brown_线代本质第一章：向量究竟是什么"></a>3Blue1Brown_线代本质第一章：向量究竟是什么</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️向量基本解释："><a href="#✏️向量基本解释：" class="headerlink" title="✏️向量基本解释："></a>✏️向量基本解释：</h2><ul>
<li><strong>在线性代数中，最基础，最根源的组成部分就是向量</strong></li>
<li><strong>一般来说，有三种看待向量的观点，他们看似不同却有所关联。</strong><ul>
<li>物理专业的角度</li>
<li>数学角度</li>
<li>计算机角度</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector.png" alt="vector"></p>
<hr>
<h3 id="📝物理专业的角度："><a href="#📝物理专业的角度：" class="headerlink" title="📝物理专业的角度："></a>📝物理专业的角度：</h3><ul>
<li><strong>向量是空间中的箭头。</strong></li>
<li>决定一个向量的是：<ol>
<li>它的长度。</li>
<li>它所指的方向。</li>
</ol>
</li>
<li>只要上述两个特征不改变，就可以自由移动一个向量而保持它本身不被改变。</li>
<li>处在平面中的向量是二维的。</li>
<li>处在生活空间中的向量是三维的。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2vs3Dimensional.png" alt="2vs3Dimensional"></p>
<hr>
<h3 id="📝计算机角度："><a href="#📝计算机角度：" class="headerlink" title="📝计算机角度："></a>📝计算机角度：</h3><ul>
<li><strong>向量是有序的数字列表。</strong></li>
<li>比如你正在做一个有关房价的分析，你关心的只有两个特征：<ol>
<li>房屋面积。</li>
<li>房屋价格。</li>
</ol>
</li>
<li>注意数字列表的<strong>数字顺序不可颠倒</strong></li>
<li>在这个房屋的例子里可以表述为：用二维向量对房屋进行建模。</li>
<li>在这里，向量只不过是列表的一个花哨的说法，这个向量是二维的因为它的列表长度是2。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cs_vector.png" alt="csStudent_vector"></p>
<hr>
<h3 id="📝数学角度："><a href="#📝数学角度：" class="headerlink" title="📝数学角度："></a>📝数学角度：</h3><ul>
<li><strong>向量可以是任何东西，只要保证两个向量相加以及数字与向量相乘是有意义的即可。</strong></li>
<li>这种方式看待向量就较为抽象了。这里可以看出，向量加法和向量数乘贯穿线性代数，二者起着很重要的作用。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/math_vector.png" alt="math_vector"></p>
<hr>
<h2 id="✏️向量思考方式："><a href="#✏️向量思考方式：" class="headerlink" title="✏️向量思考方式："></a>✏️向量思考方式：</h2><ul>
<li>首先考虑一个坐落在某个坐标系（例如x-y平面）中的箭头，箭头起点位于原点。</li>
<li>在线性代数中，向量经常以原点作为起点；这与物理学理念（向量可以在空间中自由落脚）不同。</li>
<li>一旦理解了【向量是空间中的箭头】，那么我们可以通过【向量坐标】来理解【向量是一个有序数字列表】</li>
<li>因为这两种观念的碰撞，恰恰形成了线性代数中的重要概念。</li>
</ul>
<hr>
<h3 id="📝平面空间内："><a href="#📝平面空间内：" class="headerlink" title="📝平面空间内："></a>📝平面空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="vector平面空间"></p>
<ul>
<li>来看这个箭头在x-y平面空间内（每个间距单位为1），它的这对数指导我们如何从原点（向量起点）出发到达它的尖端（向量终点）。</li>
<li>第一个数告诉我们沿着x轴走多远，正数代表向右移动，负数代表向左移动。</li>
<li>第二个数告诉我们沿着y轴走多远。正数代表向上移动，负数代表向下移动。</li>
<li>为了把向量和点区别开，向量采用的写法是将这对数竖着写，并用方括号括起来。（（-2，3）这样表示的向量也是可以的，没有区别）。</li>
<li>每一对数给出为一一个向量（有且只有一个）。</li>
<li>每一个向量恰好对应为一一对数。</li>
</ul>
<hr>
<h3 id="📝三维空间内："><a href="#📝三维空间内：" class="headerlink" title="📝三维空间内："></a>📝三维空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%90%91%E9%87%8F1.png" alt="三维空间向量1"></p>
<ul>
<li>三维空间内我们再添加一个垂直于x轴和y轴的第三根z轴</li>
<li>这种情况下，每个向量就与一个有序的三元数组对应。</li>
<li>第一个数告诉你沿平行x轴走多远，第二个数告诉你沿平行y轴走多远，第三个数告诉你沿平行z轴走多远。</li>
<li>每个三元数组给出为一一个向量。</li>
<li>每个向量对应唯一的三元数组。</li>
</ul>
<hr>
<h3 id="📝向量加法和向量数乘："><a href="#📝向量加法和向量数乘：" class="headerlink" title="📝向量加法和向量数乘："></a>📝向量加法和向量数乘：</h3><ul>
<li>线性代数中每一个主题都围绕着这两种运算。</li>
</ul>
<h4 id="✍️向量加法："><a href="#✍️向量加法：" class="headerlink" title="✍️向量加法："></a>✍️向量加法：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vectorSum.png" alt="vectorSum"></p>
<ul>
<li>向量加法：<ul>
<li>我们通过平移第二个向量，使他的起点与第一个向量的终点重合；然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是他们的和</li>
</ul>
</li>
<li>向量加法的定义差不多是线代中唯一允许向量离开原点的情形。</li>
<li>我们可以把向量加法看作数轴上加法的一种扩展。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E8%BD%B4%E5%8A%A0%E6%B3%95.png" alt="数轴加法"></li>
<li>回到x-y平面内，我们可以以下图方式所思考向量的加法，即：它朝着x轴，y轴分别运动的总量；先完成它水平运动，再完成竖直运动。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="向量加法运算方式"></li>
</ul>
<hr>
<h4 id="✍️向量数乘："><a href="#✍️向量数乘：" class="headerlink" title="✍️向量数乘："></a>✍️向量数乘：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E6%95%B0%E4%B9%98.png" alt="向量数乘"></p>
<ul>
<li>向量与其他数（标量）相乘的方式叫做“Scaling”（缩放）。</li>
<li>数字（标量）在线性代数的作用就是缩放向量；负数与向量相乘则会改变向量的方向。</li>
</ul>
<hr>
<h3 id="📝总结："><a href="#📝总结：" class="headerlink" title="📝总结："></a>📝总结：</h3><ul>
<li><strong>怎么看待向量都无所谓，它的实际作用也很少体现在这些观点的其中一个上，而是更多的体现在它能够在这些观点中相互转化。</strong></li>
<li>线性代数为数据分析提供了一条将大量数据列表概念化，可视化的渠道。他让数据样式变得非常明晰，并让我们了解特定运算的意义。</li>
<li>另一方面，线代给物理学家和计算机图形程序员提供了一种语言，让他们通过计算机能处理的数字来描述并操纵空间。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</title>
    <url>/2022/09/27/math_Essense_of_Linear_Algebra_P06/</url>
    <content><![CDATA[<blockquote>
<p>【<strong>注：本章笔记是第六章加附注二的笔记，也就是《逆矩阵，列空间与零空间》加《非方阵》。</strong>】</p>
</blockquote>
<h1 id="3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间"><a href="#3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间" class="headerlink" title="3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间"></a>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第六章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️逆矩阵（Inverse-Matrices）："><a href="#✏️逆矩阵（Inverse-Matrices）：" class="headerlink" title="✏️逆矩阵（Inverse Matrices）："></a>✏️逆矩阵（Inverse Matrices）：</h2><h3 id="✍️矩阵的用途："><a href="#✍️矩阵的用途：" class="headerlink" title="✍️矩阵的用途："></a>✍️矩阵的用途：</h3><ul>
<li>操纵空间，并且线性代数几乎在所有技术领域都有体现。</li>
<li>它能帮助我们求解特定的方程组。</li>
<li>如果一个特定的方程里面它只存在常数和未知变量（没有幂，没有奇怪的函数，没有未知量间的乘积等等），我们整理这个方程组，将未知量放在左边，常数项放在右边；如果能对其未知变量就更好（必要情况下添加系数0）；此时，就被称为“<strong>线性方程组</strong>”（Linear system of equations）</li>
<li>此时我们可以将此整合成一个含有常数系数和未知变量的矩阵，以及他们乘积所得到的一个常数向量。</li>
<li><strong>（注意：此时先将范围限制在方程数目与未知量数目相等的情况内）</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B9%E7%A8%8B%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5.png" alt="方程组和矩阵"></li>
<li>如上图，<strong>我们称系数矩阵为A，包含未知数的向量为粗体x，右侧的常数向量为v</strong>。这不仅仅是将方程组写进一行的书写技巧，它还阐明了这个问题中优美的几何直观部分。</li>
<li><strong>矩阵A代表一种线性变换，所以求解Ax&#x3D;v意味着我们去寻找一个向量x，使得它在变换后与v重合。</strong></li>
<li>所以求解此方程组，我们完全可以只考虑对空间的变换，以及变换后向量的重叠。</li>
</ul>
<hr>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E9%87%8F%E6%9E%84%E6%88%90%E7%9A%84%E6%96%B9%E7%A8%8B%E7%BB%84.png" alt="两个未知量构成的方程组"></p>
<ul>
<li>现在上图这个含有两个未知量构成的方程组，它的解依赖于矩阵A所代表的变换。</li>
<li>将空间挤压到一条线或一个点等低维空间，A保持空间为2维。</li>
<li>我们将它们分为两种情况：<ol>
<li>A的行列式为0。</li>
<li>A的行列式不为0。</li>
</ol>
</li>
</ul>
<h4 id="A的行列式不为0的情况："><a href="#A的行列式不为0的情况：" class="headerlink" title="A的行列式不为0的情况："></a>A的行列式不为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8D%E4%B8%BA0.png" alt="A的行列式不为0"></p>
<ul>
<li>这种情况下，有且只有一个向量在变换后与v重合，并且可以通过逆向进行变换来找到这个向量。如同倒带一样，通过跟踪v的动向，就能找到满足Ax&#x3D;v的向量x。</li>
<li>当你逆向进行变换时，它实际上对应了另一个线性变换，通常被称为“A的逆”，记为A^(-1)。</li>
<li>这个过程在几何上就对应与逆向进行变换并跟踪v的动向。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E9%80%86.png" alt="A的逆"></li>
<li>随机选一个矩阵，有很大的可能会遇到这一非零行列式的情况。也就是说，对于两个未知量和两个方程所构成的方程组存在它唯一的解。</li>
<li>当方程树木与未知量数目相同时，这一思想在高维情况下也有意义。同样也可以给方程组赋予几何意义。</li>
<li>只要保证A不将空间挤压到一个更低的维度，那么就是A的行列式不为零的情况，那他就存在逆变换（A逆）。这使得应用A变换在应用A逆变换之后，结果恒等。</li>
</ul>
<hr>
<h4 id="A的行列式为0的情况："><a href="#A的行列式为0的情况：" class="headerlink" title="A的行列式为0的情况："></a>A的行列式为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA0.png" alt="A的行列式为0"></p>
<ul>
<li>这个方程组相关的变换会压缩到更低的维度。</li>
<li>此时不存在逆变换，函数无法将一条线变换回一个平面。</li>
<li>此时的解依旧存在，向量v很可能恰好处于这条线上。三维空间时，解的存在难度就会更高。</li>
</ul>
<hr>
<h2 id="✏️秩（rank）："><a href="#✏️秩（rank）：" class="headerlink" title="✏️秩（rank）："></a>✏️秩（rank）：</h2><ul>
<li>当变换结果为一条直线时，也就是说结果是一维的，我们称这个变换的秩为1（Rank1）。</li>
<li>如果变换后的向量落在某个二维平面上，我们称这个变换的秩为2（Rank2）。</li>
<li><strong>所以说“秩”代表着变换后空间的维数。</strong></li>
<li>所以说对于2x2的矩阵，它的秩最大为2，意味着基向量仍旧能张成整个二维空间，并且矩阵的行列式不为0。</li>
<li>如果对于3x3矩阵来说，秩为2的时候意味着空间被压缩了，和秩为1的情况下相比较，压缩的并不是那么严重。</li>
<li>如果一个三维变换的行列式不为0，变换结果仍旧充满整个三维空间，那么它的秩为3。</li>
</ul>
<hr>
<h2 id="✏️列空间（Column-Space）："><a href="#✏️列空间（Column-Space）：" class="headerlink" title="✏️列空间（Column Space）："></a>✏️列空间（Column Space）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%97%E7%A9%BA%E9%97%B4.png" alt="矩阵的列空间"></p>
<ul>
<li>无论是一条直线，一个平面还是三维空间，所有可能变换结果的集合被称为矩阵的“<strong>列空间</strong>”（Column Space）。</li>
<li>这个来源很简单，<strong>矩阵的列告诉你基向量变换后的位置。这些变换后的基向量张成的空间就是所有可能的变换结果</strong>。换句话说，<strong>列空间就是矩阵的列所张成的空间</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%88%97%E5%BC%A0%E6%88%90%E7%9A%84%E7%A9%BA%E9%97%B4.png" alt="列张成的空间"></li>
<li><strong>所以更精确的说，秩的定义是列空间的维数。</strong></li>
<li><strong>当秩达到最大值时，意味着秩与列数相等，我们称之为“满秩”（Full Rank）</strong></li>
</ul>
<hr>
<h3 id="✍️零空间（Null-space）："><a href="#✍️零空间（Null-space）：" class="headerlink" title="✍️零空间（Null space）："></a>✍️零空间（Null space）：</h3><ul>
<li>需要注意的是，零向量一定会被包含在列空间中，因为线性变换必须保证原点位置不变。</li>
<li>对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量（0，0）自身。</li>
<li>但是对于一个非满秩的矩阵来说，他将空间压缩到一个更低的维度上，也就是说会有一系列向量在变换后成为零向量（被压缩的空间的有一部分会部分归到0向量）。</li>
<li>这被称为矩阵的“<strong>零空间</strong>”（Null Space）或“<strong>核</strong>”（Kernel）。</li>
<li>变换后的一些向量落在零向量上，而“零空间”正式这些向量所构成的空间。</li>
<li>对线性方程组来说，当向量v恰好为零向量时，零空间给出的就是这个向量方程所有可能的解。</li>
</ul>
<hr>
<h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><blockquote>
<p>每个方程组都有一个线性变换与之联系。<br>当逆变换存在时，你就能用这个逆变换求解方程组。<br>列空间的概念让我们清楚什么时候存在解什么时候不存在。<br>零空间的概念有助于我们理解所有可能的解的集合。</p>
</blockquote>
<hr>
<hr>
<hr>
<h2 id="✏️附注二："><a href="#✏️附注二：" class="headerlink" title="✏️附注二："></a>✏️附注二：</h2><h3 id="✍️非方阵（Nonsquare-Matrices）："><a href="#✍️非方阵（Nonsquare-Matrices）：" class="headerlink" title="✍️非方阵（Nonsquare Matrices）："></a>✍️非方阵（Nonsquare Matrices）：</h3><ul>
<li>在之前的学习中，使用的几乎都是2x2或者3x3这样的方形矩阵来举例子，但现在需要讨论一下非方阵。</li>
<li>讨论不同维数之间的变换是完全合理的，比如一个二维向量到三位向量的变换。</li>
<li>同之前一样，如果网格线保持平行且等距分布，并且原点映射为自身，就称它为线性的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BA%8C%E7%BB%B4%E5%90%91%E9%87%8F%E5%88%B0%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8F.png" alt="二维向量到三维向量"></li>
<li>此时要注意的是，由上图所示，输入的二维向量与输出的三维向量是完全不同的物种，他们生活在没有任何关联的空间当中。</li>
</ul>
<hr>
<h4 id="3x2矩阵："><a href="#3x2矩阵：" class="headerlink" title="3x2矩阵："></a>3x2矩阵：</h4><ul>
<li>用矩阵代表这样一个变换则和之前相同；找到每一个基向量变换后的位置，然后把基向量的坐标作为矩阵的列。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220927231819.png" alt="变换示例"></li>
<li>注意一点，这意味着代表这个变换的矩阵是三行两列，也就是3x2矩阵。这个矩阵的列空间是三维空间中一个过原点的二维平面，但是这个矩阵任然是满秩的。因为列空间的维数与输入空间的维数相等。</li>
<li>它的几何意义是将二维空间映射到三维空间上，因为矩阵有两列表面输入空间有两个基向量，有三行表明每个基向量在变换后都用三个独立的坐标来表示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x2%E7%9F%A9%E9%98%B5.png" alt="3x2矩阵"></li>
</ul>
<hr>
<h4 id="2x3矩阵："><a href="#2x3矩阵：" class="headerlink" title="2x3矩阵："></a>2x3矩阵：</h4><ul>
<li>类似的，当我们看见一个两行三列也就是2x3矩阵时，表面矩阵有三个基向量，也就是说原始空间是三维的；每个变换后的基向量用两个坐标来表示，所以他们一定落在二维空间。因此这是一个从三维空间到二维空间的变换。如下图所示例。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x3%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B.png" alt="2x3矩阵示例"></li>
</ul>
<hr>
<h4 id="1x2矩阵："><a href="#1x2矩阵：" class="headerlink" title="1x2矩阵："></a>1x2矩阵：</h4><ul>
<li>除此以外，当然还可以由二维空间到一维空间的转换，一维空间实际上就是数轴。</li>
<li>这里可以理解为如果一条直线上有一系列等距分布的点，在映射到数轴之后，他们将保持等距分布，这样的变换也可以用一个1x2矩阵表示，而这个矩阵的两列都只有一个数，这两列分别代表了变换后的基向量。</li>
<li>实际上这是一类非常有意义的变换，它与点积紧密相关。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/1x2%E7%9F%A9%E9%98%B5.png" alt="1x2矩阵"></li>
</ul>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第八章：叉积的标准介绍</title>
    <url>/2022/10/03/math_Essense_of_Linear_Algebra_P08/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第八章：叉积的标准介绍"><a href="#3Blue1Brown-线代本质第八章：叉积的标准介绍" class="headerlink" title="3Blue1Brown_线代本质第八章：叉积的标准介绍"></a>3Blue1Brown_线代本质第八章：叉积的标准介绍</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第八章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<blockquote>
<p>【注：此篇为第八章第一部分《叉积的标准介绍》和第二部分《以线性变换的眼光看叉积》的集合】</p>
</blockquote>
<hr>
<h2 id="✏️叉积（cross-product）："><a href="#✏️叉积（cross-product）：" class="headerlink" title="✏️叉积（cross product）："></a>✏️叉积（cross product）：</h2><h3 id="✍️基本理解（非严格意义上的叉乘）："><a href="#✍️基本理解（非严格意义上的叉乘）：" class="headerlink" title="✍️基本理解（非严格意义上的叉乘）："></a>✍️基本理解（非严格意义上的叉乘）：</h3><ul>
<li>从平面空间说起，加入有两个向量v和w，考虑他们所张成的平行四边形，v和w的叉积v X w 其实就是这个平行四边形的面积。</li>
<li>当然我们还要考虑定向问题；如果v在w的右侧，那么v叉乘w为正；并且值等于平行四边形的面积。如果v在w的左侧，那么v叉乘w为负。这就是说顺序会对叉积有影响。</li>
<li>如果你不计算w叉乘v，而是交换二者位置计算，那么叉积就是之前计算结果的相反数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="叉积平面空间"></li>
<li>记住顺序的方法是：当你按顺序求两个基向量的叉积，即i帽叉乘j帽，结果应该是正的。基向量的顺序就是定向的基础，因为i帽在j帽的右侧。同理运用到v和w上一样如此，v在w右侧，结果为正；反之为负。</li>
<li>举例如下图，如果v的坐标为（-3，1），w的坐标为（2，1），以他们的坐标为列构成的行列式为（（-3）*1—） - （2 * 1），也就是-5。很显然，他们构成的平行四边形的面积为5；但v在w左侧，所以行列式结果为-5。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%A4%BA%E4%BE%8B%E4%B8%80.png" alt="第八章示例一"></li>
<li>如果两个向量垂直，或接近垂直，和他们指向接近时相比，此时的叉积更大。所以当两个向量接近通向时，他们的叉积更小。因为两条边接近垂直的时候，平行四边形的面积会更大。</li>
<li>如果放大其中的一个向量，比如将v放大为3倍，那么平行四边形的面积也放大三倍。这也就是说，3v叉乘w正好是v叉乘w的三倍。</li>
</ul>
<hr>
<h3 id="✍️严格意义上的叉乘："><a href="#✍️严格意义上的叉乘：" class="headerlink" title="✍️严格意义上的叉乘："></a>✍️严格意义上的叉乘：</h3><ul>
<li>通过两个三维向量，生成一个新的三维向量。</li>
<li>我们还是要考虑这两个向量围成的平行四边形，而这个平行四边形的面积依然会发挥着重要的作用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E7%9A%84%E5%9F%BA%E7%A1%80.png" alt="叉积的基础"></li>
<li>但是此时，叉积的结果应当是一个向量，所以就不能单纯用它的面积这个数来理解。<strong>这个向量的长度是这个平行四边形的面积，而这个向量的方向与平行四边形所在的面垂直</strong>。</li>
</ul>
<h4 id="叉积的方向："><a href="#叉积的方向：" class="headerlink" title="叉积的方向："></a>叉积的方向：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%88%99.png" alt="右手定则"></p>
<ul>
<li>因为长度为这个平行四边形面积并垂直于给定面的向量一共有两个，且方向相反，这里就需要用<strong>右手定则</strong>：<strong>右手食指指向v的方向，中指指向w的方向，当你把大拇指竖起来的方向，他所指的方向就是叉积的方向。</strong></li>
</ul>
<h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E4%B9%98%E7%9A%84%E4%B8%89%E9%98%B6%E8%BF%90%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="叉乘的三阶运算公式"></p>
<ul>
<li>这样计算并非巧合。</li>
</ul>
<hr>
<h2 id="✏️以线性变换的眼光看叉积："><a href="#✏️以线性变换的眼光看叉积：" class="headerlink" title="✏️以线性变换的眼光看叉积："></a>✏️以线性变换的眼光看叉积：</h2><h3 id="✍️推理过程："><a href="#✍️推理过程：" class="headerlink" title="✍️推理过程："></a>✍️推理过程：</h3><ul>
<li>对偶性的思想在于：每当你看见一个多维空间到数轴的线性变换时，它都与那个空间中唯一一个向量对应，也就是说应用线性变换和与这个向量点乘等价。数值上说，这是因为这类线性变换可以用一个只有一行的矩阵描述，而它的每一列给出了变换后基向量的位置。将这个矩阵与某个向量v相乘，在计算上与将矩阵转置得到的向量和v点乘相同。</li>
<li>这里的收获在于，每当你看到一个从空间到数轴的线性变换，你都能找到一个向量，被称为这个变换的对偶向量。使得应用线性变换和对偶向量点乘等价。</li>
<li>叉积的运算给出了此过程一个鲜活的实例。</li>
</ul>
<h3 id="✍️关于叉积的证明计划："><a href="#✍️关于叉积的证明计划：" class="headerlink" title="✍️关于叉积的证明计划："></a>✍️关于叉积的证明计划：</h3><ol>
<li>根据v和w定义一个三维到一维的线性变换。</li>
<li>找到它的对偶向量。</li>
<li>这个对偶向量就会是v和w的叉积。</li>
</ol>
<ul>
<li>理解线性变换能够解释清楚叉积的计算过程和几何含义之间的关系。</li>
<li><strong>真正的三维向量的叉积接受两个向量并输出一个向量</strong>，它并不是接收三个向量并输出一个数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF.png" alt="以线性变换看待叉积"></li>
<li>如上图所示，将第一个向量u看作可变向量，比如（x，y，z），而v和w保持不变；那么我们就有一个从三维空间到数轴的函数了。你输入一个向量（x，y，z），然后通过矩阵的行列式得到一个数。这个向量的第一列是（x，y，z），其余的两列是常向量v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_02.png" alt="以线性变换看待叉积_02"></li>
<li>这个函数的几何意义是，对于任一输入的向量（x，y，z），你都考虑由它和v与w确定的平行六面体得到它的体积，然后根据定向确定符号。</li>
</ul>
<h3 id="但是这个函数从哪里来，为什么会这么计算？"><a href="#但是这个函数从哪里来，为什么会这么计算？" class="headerlink" title="但是这个函数从哪里来，为什么会这么计算？"></a><strong>但是这个函数从哪里来，为什么会这么计算？</strong></h3><ul>
<li>这个函数一个至关重要的性质就是它是线性的，因此可以引入对偶性的特性。</li>
<li>因为它是线性的，我们就知道可以通过矩阵乘法来描述这个函数；具体的说，因为这个函数从三维空间到一维空间，就会存在一个1x3矩阵来代表这个变换。而对偶性的整体思路是从多维空间到一维空间的变换的特别之处在于你可以把这个矩阵立起来并且将整个变换看作与这个特定向量的点积。</li>
<li>如下图所示，我们要找的就是这个特殊的三维向量，现在称之为P，使得P与其他任一向量（x，y，z）的点积等于一个3x3矩阵的行列式，这个3x3矩阵的第一列为（x，y，z），其余两列分别为v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_03.png" alt="以线性变换看待叉积_03"></li>
<li>P与向量（x，y，z）点乘给出的结果以及右侧行列式的计算结果如下图所示：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_04.png" alt="以线性变换看待叉积_04"></li>
<li>这里某些常数涉及了v和w的坐标的特定组合。因此这些常数，也就是v和w的坐标的特定组合，就是我们寻找到向量P的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_05.png" alt="以线性变换看待叉积_05"></li>
<li>等号右侧的过程，对于哪些进行过叉积计算的人来说是很熟悉的。</li>
<li>像这样合并x，y和z前面的常数项，和把i帽，j帽和k帽放进矩阵第一列进行计算，然后合并个项前面的系数没有区别。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_06.png" alt="以线性变换看待叉积_06"></li>
<li>在矩阵中插入i帽，j帽和k帽在传递一个信号，告诉我们应该把这些系数理解成一个向量坐标。</li>
<li>因此，这一切都在说明，这个奇怪的运算过程可以看作是以下问题的答案：<ul>
<li>当你将向量p和某个向量（x，y，z）点乘时，所得的结果等于一个3x3矩阵的行列式，这个矩阵第一列为（x，y，z），其余两列为v和w的坐标。考虑什么样的向量p可以完成这一特殊性质。</li>
<li>也可以这样说：当年将向量p和某个向量（x，y，z）点乘时，所得结果等于一个由（x，y，z）个v与w确定的平行六面体的邮箱体积，什么样的向量p可以完成这一特殊性质？</li>
</ul>
</li>
<li>记住一点，向量p与其他向量的点积的几何解释是将其他向量投影到p上，然后将投影长度与p的长度相乘。</li>
<li>根据这点，平行六面体的体积可以这样考虑：首先获得由v和w确定的平行四边形的面积，乘以向量（x，y，z）在垂直于平行四边形方向上的分量。</li>
<li>换句话说，我们找到线性函数对于给定向量的作用，是将这个向量投影到垂直于v和w的直线上，然后将投影长度于v和w张成的平行四边形的面积相乘。这和垂直于v和w且长度为平行四边形面积的向量与（x，y，z）点乘是同一回事。</li>
<li>更重要的是，如果你选择了合适的向量方向，点积为正的情况就会与（x，y，z），v和w满足右手定则的情况相吻合。</li>
<li>这意味着我们找到了一个向量p，使得p与和某个向量（x，y，z）点乘时所得结果等于一个3x3矩阵的行列式；这个矩阵的三列分别为（x，y，z），v的坐标和w的坐标。</li>
<li>因此我们之前通过特殊符号技巧进行计算所得到的向量必然在几何上与这个向量对应。这激素叉积的计算过程与几何解释有关的根本原因。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_07.png" alt="以线性变换看待叉积_07"></li>
</ul>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第五章：行列式</title>
    <url>/2022/09/26/math_Essense_of_Linear_Algebra_P05/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第五章：行列式"><a href="#3Blue1Brown-线代本质第五章：行列式" class="headerlink" title="3Blue1Brown_线代本质第五章：行列式"></a>3Blue1Brown_线代本质第五章：行列式</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第五章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️区域内面积增大减小："><a href="#✏️区域内面积增大减小：" class="headerlink" title="✏️区域内面积增大减小："></a>✏️区域内面积增大减小：</h2><ul>
<li>想象一些线性空间，有的变换是向外拉伸空间（Generally stretches space），有的则是向内挤压（Generally squashes space）；有件事情对理解这些线性变换很有用，那就是测量这些变换究竟对空间有多少拉伸或挤压；也就是：<strong>测量一个给定区域面积增大或减小的比例。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%98%E6%8D%A2%E5%90%8E%E7%9A%84%E9%9D%A2%E7%A7%AF.png" alt="变换后的面积"></li>
<li>如上图所示，i帽从（1，0）变换为（3，0），j帽从（0，1）变换为（0，2）；则由i帽和j帽决定的单位正方形的面积从原先的1x1变成了现在的3x2；它的面积增大了6倍。所以我们说这个线性变换将它的面积变为6倍。</li>
</ul>
<hr>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%89%AA%E5%88%87%E7%9F%A9%E9%98%B5%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%8F%98%E6%8D%A2.png" alt="剪切矩阵的面积变换"></p>
<ul>
<li>【<strong>剪切矩阵</strong>】则是i帽不变还是在（1，0），j帽从（0，1）变为（1，1）；此时由i帽和j帽决定的单位正方形在变换后倾斜为一个平行四边形，但是它的面积是不变的。所以说即便这个变换空间向右挤压，它并不改变面积。</li>
<li>实际上，只要知道单位正方形面积变化的比例，他就能告诉你其他任意区域的面积变化比例（因为“网格线保持平行且等距分布”）。</li>
</ul>
<hr>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%BF%90%E7%94%A8%E8%BF%91%E4%BC%BC%E7%9A%84%E6%96%B9%E6%A0%BC%E7%BC%A9%E6%94%BE.png" alt="运用近似的方格缩放"></p>
<ul>
<li>对于不是方形网格的形状，我们可以用许多放个良好近似，只要使用的方格足够小，近似就能足够好。由于所有的小方格都是进行等比缩放，所以整个形状也进行了同样比例的缩放。</li>
</ul>
<hr>
<h2 id="✏️线性变换的行列式（The-“deternminant”-of-a-transformation）："><a href="#✏️线性变换的行列式（The-“deternminant”-of-a-transformation）：" class="headerlink" title="✏️线性变换的行列式（The “deternminant” of a transformation）："></a>✏️线性变换的行列式（The “deternminant” of a transformation）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A1%8C%E5%88%97%E5%BC%8F.png" alt="线性变换行列式"></p>
<ul>
<li>比如说，一个线性变换的行列式是3，那么就是说他将一个区域的面积增加为原来的三倍。</li>
<li>同理一个线性变换的行列式是1&#x2F;2，那么就说他将一个区域的面积减少为原来的二分之一。</li>
<li>如果一个线性变换的行列式是0，那么说明它将整个平面压缩到一条线，甚至是一个点上。</li>
<li>如果变换前j帽在i帽的左侧，变换后j帽变成i帽的右侧，那么此时空间定向就发生了改变（Orientation has been reversed）。</li>
<li><strong>当空间定向改变，行列式为负</strong>，但是行列式的绝对值依然表示区域面积的缩放比例。</li>
</ul>
<hr>
<h3 id="✍️负的面积为什么与定向改变相关？"><a href="#✍️负的面积为什么与定向改变相关？" class="headerlink" title="✍️负的面积为什么与定向改变相关？"></a>✍️负的面积为什么与定向改变相关？</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA%E8%B4%9F%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5.png" alt="行列式为负值的情况"></p>
<ul>
<li>考虑i帽靠近j帽时的变换，空间也被更厉害的压缩，意味着行列式趋近于0；当i帽与j帽完全重合时，行列式为0。如果i帽继续沿着这个方向运动，则行列式继续减小为负值。</li>
</ul>
<hr>
<h2 id="✏️三维空间中行列式的变换："><a href="#✏️三维空间中行列式的变换：" class="headerlink" title="✏️三维空间中行列式的变换："></a>✏️三维空间中行列式的变换：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="行列式在三维空间内的变换"></p>
<ul>
<li>它告诉你的依然是变换前后的缩放比例，不过三维空间内缩放的是体积。</li>
<li>在三维空间中我们可以用1x1x1，即i，j，k这三个基向量，这个特殊的立方体来观察行列式的变换。</li>
<li>我们可以把行列式简单的看作这个平行六面体的体积<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%85%AD%E9%9D%A2%E4%BD%93%E7%9A%84%E4%BD%93%E7%A7%AF.png" alt="平行六面体的体积"></li>
<li>行列式为0则意味着整个空间被压缩为零体积的东西。也就是一个平面，一条直线或一个点。</li>
</ul>
<hr>
<h3 id="✍️如何计算行列式？："><a href="#✍️如何计算行列式？：" class="headerlink" title="✍️如何计算行列式？："></a>✍️如何计算行列式？：</h3><ul>
<li>首先它必须得是方形矩阵（行列数相等）。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E9%9D%A2%E7%A7%AF%E8%AE%A1%E7%AE%97%E6%8E%A8%E5%AF%BC.png" alt="行列式面积计算推导"></li>
<li>ad是平行四边形的面积公式底乘以高，如果c不为0的情况下，这个bc项准确的告诉你平行四边形在对角线方向上拉伸或压缩了多少；则这个公式就可以计算出拉伸后的面积。</li>
</ul>
<h3 id="✍️三阶行列式计算公式："><a href="#✍️三阶行列式计算公式：" class="headerlink" title="✍️三阶行列式计算公式："></a>✍️三阶行列式计算公式：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="三阶行列式计算公式"></p>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第七章：点积与对偶性</title>
    <url>/2022/09/29/math_Essense_of_Linear_Algebra_P07/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第七章：点积与对偶性"><a href="#3Blue1Brown-线代本质第七章：点积与对偶性" class="headerlink" title="3Blue1Brown_线代本质第七章：点积与对偶性"></a>3Blue1Brown_线代本质第七章：点积与对偶性</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第七章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️点积（dot-product）："><a href="#✏️点积（dot-product）：" class="headerlink" title="✏️点积（dot product）："></a>✏️点积（dot product）：</h2><h3 id="✍️点积的标准观点："><a href="#✍️点积的标准观点：" class="headerlink" title="✍️点积的标准观点："></a>✍️点积的标准观点：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E7%9A%84%E6%A0%87%E5%87%86%E8%A7%82%E7%82%B9.png" alt="点积的标准观点"></p>
<ul>
<li><strong>如果有两个维数相同的向量，或是两个长度相同的数组，求它的点积，就是将相应的坐标配对，求出每一对坐标的乘积，然后结果相加。</strong></li>
</ul>
<hr>
<h3 id="✍️几何计算："><a href="#✍️几何计算：" class="headerlink" title="✍️几何计算："></a>✍️几何计算：</h3><ul>
<li>这个计算有一个优美的几何解释：<ul>
<li><strong>如果要求两个向量v和w的点积，想象向量w朝着过原点和向量v终点的直线上投影（这里指正交投影），将投影的长度与向量v的长度相乘，就得到了他们的点积，v点乘w。</strong> 所以当两个向量的指向大致相同时，他们的点积为正。（方向为正）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="点乘几何计算"></li>
<li><strong>除非w的投影与v的方向相反，这种情况下点积为负。</strong> （指向方向相反）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%B4%9F%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="负数情况下点乘几何计算"></li>
<li><strong>当他们互相垂直的时候，意味着一个向量在另一个向量上的投影为零向量。</strong></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E9%9B%B6%E5%90%91%E9%87%8F%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="零向量情况下点乘几何计算"></li>
</ul>
</li>
</ul>
<hr>
<h3 id="✍️点积与顺序无关："><a href="#✍️点积与顺序无关：" class="headerlink" title="✍️点积与顺序无关："></a>✍️点积与顺序无关：</h3><ul>
<li><strong>你可以将v投影到w上，将v投影长度与w长度相乘；或者将w投影到v上，与将w投影长度与v相乘；他们的结果是一样的。</strong> </li>
<li>上面的话可以这么理解：<ul>
<li>可以先想想v与w长度相等，我们可以利用对称性，来知道他们的结果是相等的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E9%A1%BA%E5%BA%8F.png" alt="点积顺序"></li>
<li>如果我们此时将v放大两倍（现在成为2v），使得他们长度不同，那么现在对称性就被破坏了；但是我们可以这样理解2v和w的点积：<ul>
<li>如果认为w向v上投影，那么2v点乘w就应该恰好是v点乘w的两倍，现在就是（2v）·w&#x3D;2（v·w）；这是因为，将v放大为原来的两倍并不改变w的投影长度，但是被投影的向量长度变为原来的两倍。</li>
<li>另一方面，如果将v投影到w上，将v变为原来的两倍（2v），那么这次的是投影长度就变为原来的两倍（2v），但是被投影的向量w长度保持不变；所以总体效果任然是点积变为两倍。</li>
</ul>
</li>
<li>在两种理解方式下，缩放向量对点积结果的影响是相同的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="✍️对偶性（duality）："><a href="#✍️对偶性（duality）：" class="headerlink" title="✍️对偶性（duality）："></a>✍️对偶性（duality）：</h3><ul>
<li>有不少函数能够接收二维向量并输出一个数，同样是二维输入与一维输出，和一般函数相比，线性变换的要求更加严格。</li>
<li>如果你有一些列等距分布于一条直线上的点，然后应用变换，线性变换会保持这些点等距分布在输出空间中（也就是数轴上）；否则，如果这些点没有等距分布，那么这个变换就不是线性的。</li>
<li>这些线性变换完全由他对i帽和j帽的变换决定，但是这一次，这些基向量只落在一个数上。所以当我们将他们变换后的位置记录为矩阵的列时，矩阵的每列只是一个单独的数。</li>
<li>假设有一个线性变换，它将i帽和j帽分别变换到1和-2，要跟踪一个向量，比如向量（4，3），在变换后的去向；将这个向量分解为4乘以i帽加上3乘以j帽。由于线性性质，在变换后，这个向量的位置是4乘以变换后的i帽也就是1（4 * 1），加上3乘以变换后的j帽也就是-2（3 * -2）；那么他最终结果落在-2上。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E5%81%B6%E6%80%A7%E7%A4%BA%E4%BE%8B.png" alt="变换示例"></li>
<li>上图展示的就是1x2矩阵于向量相乘这一数值运算过程，感觉上就和两个向量的点积是一样的。那这个1x2矩阵正像是一个倾倒的向量。</li>
<li>1x2矩阵与二维向量之间有着微妙的联系；这种关系在于：将向量放倒从而得到与之相关的矩阵，获奖矩阵直立，从而得到与之相关向量。</li>
<li>因为我们现在只是从数值表达上来看待这个联系，所以向量和1x2矩阵来回之间转换看起来毫无意义。</li>
<li>几何上，将向量转换为数的线性变换和这个向量本身有着某种关系。</li>
</ul>
<hr>
<h4 id="【假设我们还不知道点积与投影有关：】"><a href="#【假设我们还不知道点积与投影有关：】" class="headerlink" title="【假设我们还不知道点积与投影有关：】"></a>【<strong>假设我们还不知道点积与投影有关：</strong>】</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD.png" alt="u帽"></p>
<ul>
<li>现在将数轴复制一份，然后保持0在原点；考虑一个二维向量，它的终点落在这条数轴上，我们现在管他叫“u帽”。</li>
<li>如果将二维向量直接投影到这条数轴上，实际上我们这样定义了一个从二维向量到数的函数；这个函数是线性的，它在直线上等距分布的点在投影到数轴上后依然等距分布。它输出的结果是数，而不是二维向量。</li>
<li>我们应该把它看作一个接收两个坐标并输出一个坐标的函数。</li>
<li>不过，u帽是二维空间中的一个向量，而它碰巧又落在这条数轴上，根据这个投影，我们定义了一个从二维向量到数的线性变换。所以我们就能找到描述这个变换的1x2矩阵。</li>
</ul>
<hr>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1.png" alt="u帽与i帽的投影"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1%E7%A4%BA%E6%84%8F.png" alt="u帽与i帽的投影示意"></p>
<ul>
<li>上图我们可以来看u帽和i帽之间的投影，因为u帽和i帽都是向量单位，那么将i帽向u帽所在的直线投影与u帽向x轴投影看上去完全对称。根据对称性，u帽向x轴的投影得到的数就是u帽的横坐标（ux）。</li>
<li>j帽的推理与x帽的一致，那么u帽的纵坐标就是（uy）。</li>
<li>所以描述投影变换的1x2矩阵的两列，就分别是u帽的两个坐标。</li>
<li>而空间中任意向量经过投影的变换结果，也就是投影矩阵与这个向量相乘；和这个向量与u帽的点积在计算上完全相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98%E4%B8%8E%E7%82%B9%E7%A7%AF.png" alt="矩阵向量相乘与点积"></li>
<li>这就是为什么单位向量的点积可以解读为将向量投影到单位向量所在的直线上所得到的投影长度。</li>
</ul>
<hr>
<h4 id="非单位向量"><a href="#非单位向量" class="headerlink" title="非单位向量"></a>非单位向量</h4><ul>
<li>只要变换是线性的，那么新矩阵就可以看作基向量向着数轴投影并乘以新矩阵的变换倍数。这就素为什么向量与给定非向量的点积可以解读为：首先给向量投影，然后将投影的值于给定向量长度相乘。</li>
</ul>
<hr>
<h3 id="总结对偶性："><a href="#总结对偶性：" class="headerlink" title="总结对偶性："></a>总结对偶性：</h3><ul>
<li>你在任何时候看见一个线性变换，它的输出空间是一维数轴；无论它是如何定义的，空间中会存在唯一的向量v与之相关。就这一意义而言，应用变换和于向量v做点积是一样的。</li>
<li>它是数学中“<strong>对偶性</strong>”的一个实例。</li>
<li><strong>对偶性</strong>贯穿数学始终，在多个方面均有体现。粗略地说，它是指：<strong>两种数学事物之间自然而又出乎意料的对应关系</strong></li>
<li>犹如刚刚的实例，我们可以说一个向量的对偶是由它定义的线性变换。</li>
<li>一个多维空间到一个一维空间的线性变换的对偶是多维空间中的某个特定向量。</li>
<li>表面上看，点积是理解投影的有利几何工具，并且方便检验两个向量的指向是否相同（指向相同为正，指向相反为负，垂直为0）</li>
<li>两个向量点乘，就是将其中一个向量转化为线性变换。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第十一章：抽象向量空间</title>
    <url>/2022/10/07/math_Essense_of_Linear_Algebra_P11/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第十一章：抽象向量空间"><a href="#3Blue1Brown-线代本质第十一章：抽象向量空间" class="headerlink" title="3Blue1Brown_线代本质第十一章：抽象向量空间"></a>3Blue1Brown_线代本质第十一章：抽象向量空间</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十一章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>《<strong>线代本质》的内容这一章其实就是完结啦！！！下一章是《克莱姆法则，几何解释》，由于官方账号发在一起了，所以我会把下一章一起当作这个系列的笔记写在一起，所以下一章是第十二章！</strong></li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️抽象向量空间："><a href="#✏️抽象向量空间：" class="headerlink" title="✏️抽象向量空间："></a>✏️抽象向量空间：</h2><h3 id="✍️再来想想什么是向量："><a href="#✍️再来想想什么是向量：" class="headerlink" title="✍️再来想想什么是向量："></a>✍️再来想想什么是向量：</h3><ul>
<li><strong>坐标的描述是相对随意的，因为这完全依赖于我们所选定的坐标系</strong>。</li>
<li>行列式告诉你的是一个变换对面积的缩放比例；特征向量则是在变换中留在它所张成的空间中的向量。这二者都是暗含于空间中的性质，可以自由选取坐标系，这并不会改变它们最根本的值。所以：<strong>行列式和特征向量与所选坐标系无关</strong>。</li>
<li>但是，<strong>如果向量根本并不是由一组实数构成，它们的本质更具空间性；那么此时，数学中所说的“空间”（space）或“空间性”（spatial）究竟表示什么？</strong></li>
<li>所以，我们应当考虑一种：<ul>
<li><strong>既不是一个箭头，也不是一组数字，但是同样具有向量特征的东西</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="✏️函数（function）："><a href="#✏️函数（function）：" class="headerlink" title="✏️函数（function）："></a>✏️函数（function）：</h2><h3 id="✍️函数与向量"><a href="#✍️函数与向量" class="headerlink" title="✍️函数与向量"></a>✍️函数与向量</h3><ul>
<li><strong>从某种意义上说，函数实际上只是另一种向量</strong>；<ul>
<li>类比两个向量相加的方法，我们也可以将两个函数f和g相加，从而获得一个新的函数（f+g），这种方式是合理的。如下图所示。</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E7%9B%B8%E5%8A%A0.png" alt="函数相加"></p>
<ul>
<li>这个新函数在任意一点处的值，比如在-4的值，就是f和g在这一点处的值的和。</li>
<li>具体一点说，这个和函数在任意一点x处的值（f+g）（x）等于f（x）加上g（x）。</li>
<li>这和向量对应坐标相加十分相似；只不过某种程度上来说，它有无穷多个坐标要相加。如下图所示。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F.png" alt="函数与向量"></p>
<hr>
<h3 id="✍️函数与实数："><a href="#✍️函数与实数：" class="headerlink" title="✍️函数与实数："></a>✍️函数与实数：</h3><ul>
<li>类似的，<strong>函数与一个实属相乘也有着合理的解释</strong>：<ul>
<li>我们只是把输出的值与那个数相乘。如下图所示</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E6%95%B0%E7%9B%B8%E4%B9%98.png" alt="函数与实数相乘"></p>
<ul>
<li>这再次和向量对应坐标数乘类似。如下图所示</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E6%95%B0%E4%B9%98.png" alt="函数与向量数乘"></p>
<hr>
<h3 id="✍️应用向量的特征到函数："><a href="#✍️应用向量的特征到函数：" class="headerlink" title="✍️应用向量的特征到函数："></a>✍️应用向量的特征到函数：</h3><ul>
<li><strong>因为对向量所能进行的操作不过向量相加和数乘两种，所以，最初以空间中的箭头为背景考虑的线性代数的合理概念和解决问题的手段，应该能原封不动地被我们取出来，然后应用于函数。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E7%89%B9%E5%BE%81%E5%BA%94%E7%94%A8%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%AD.png" alt="向量特征应用到函数中"></li>
<li>举个例子， 函数到线性变换有一个完全合理的解释，这个变换接受一个函数，并把它变成另一个函数；从微积分中可以找到一个常见的例子————导数。他将一个函数变换到另一个函数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%87%BD%E6%95%B0%E5%8F%98%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0.png" alt="函数变为另一个函数"></li>
<li>有时你听到的是“算子”（线性算子，“Linear operator”）而不是“变换”，它们是一样的。</li>
</ul>
<hr>
<h3 id="✍️“一个函数变换是线性的”是什么意思？"><a href="#✍️“一个函数变换是线性的”是什么意思？" class="headerlink" title="✍️“一个函数变换是线性的”是什么意思？"></a>✍️“一个函数变换是线性的”是什么意思？</h3><ul>
<li>线性的严格定义是相对抽象而且符号繁重的；但是，抽象性带来的好处是我们能得到一般性的结论，它不仅适用于箭头，也适用于函数。</li>
<li>满足以下两条性质的变换是线性的：<ol>
<li><strong>可加性（Additivity）</strong><ul>
<li>可加性意味着如果你把两个向量v和w相加，然后对它们的和应用变换，得到的结果和将变换后的v与变换后的w相加一致。</li>
</ul>
</li>
<li><strong>成比例（一阶齐次）（Scaling）</strong><ul>
<li>成比例是说，你讲一个向量v与某个数相乘，然后应用变换，得到的结果和变化后的v与这个数相乘一致。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89.png" alt="线性的严格定义"></p>
<ul>
<li>你经常会听到一种描述方法是：<strong>“线性变换保持向量加法运算和数乘运算”</strong></li>
<li>这两条性质的一个最重要的推论就是：<strong>一个线性变换可以通过它对基向量的作用来完全描述，这使得矩阵向量乘法成为可能</strong>。因为任一向量都能表达为基向量以某种方式进行的线性组合，所以求一个向量变换后的结果，实际上就是求出变换后的基向量以相同方式进行线性组合的结果。</li>
<li>这就跟箭头一样，这一点对函数来说同样正确。</li>
</ul>
<h4 id="求导（Derivative）是线性运算："><a href="#求导（Derivative）是线性运算：" class="headerlink" title="求导（Derivative）是线性运算："></a>求导（Derivative）是线性运算：</h4><ul>
<li>举个例子：<ul>
<li><strong>求导（Derivative）是线性运算。</strong></li>
<li>如果你把两个函数相加，然后求导数；等同于先求两个函数的导数，然后把结果相加。</li>
<li>类似的，如果你将函数与数相乘，然后求导数；等同先求导数，然后把结果相乘。</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%B1%82%E5%AF%BC%E6%98%AF%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97.png" alt="求导是线性运算"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%B1%82%E5%AF%BC%E6%98%AF%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_02.png" alt="求导是线性运算_02"></p>
<hr>
<h2 id="✏️用矩阵来描述求导："><a href="#✏️用矩阵来描述求导：" class="headerlink" title="✏️用矩阵来描述求导："></a>✏️用矩阵来描述求导：</h2><blockquote>
<p>这可能有些棘手，因为函数空间倾向于有无穷维。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F.png" alt="空间内的多项式"></p>
<ul>
<li>我们现在把目光限制在多项式空间上，如上图，有几个多项式。虽然这个空间中每一个多项式都只有有限项，但整个空间应该包含任意高次的多项式。</li>
<li>首先我们要做的是给这个空间赋予坐标的含义，这需要选取一个基。</li>
<li>因为多项式已经是数乘x的不同次幂再做加和的形式，所以我们很自然就可以去x的不同次幂作为<strong>基函数（basis function）</strong>。换句话说，第一个基函数就是一个常函数，即b0（x）&#x3D;1；第二个基函数是b1（x）&#x3D;x；第三个基函数是b2（x）&#x3D;x^2；依此类推。</li>
<li>基函数在这里起到的作用，和i帽，j帽，k帽在向量的世界中起到的作用类似。</li>
<li>因为多项式的次数可以任意高，所以这个基函数集也是无穷大的。</li>
</ul>
<hr>
<ul>
<li><strong>如下图</strong>，取出多项式的坐标，然后把它放在矩阵的右侧。对结果的第一个坐标有贡献的只有1乘以4这一项，也就是说结果的常数项是4。这对应用于4x的导数是常数4.</li>
<li>对矩阵向量乘积的第二个坐标有贡献的只有2乘以5这一项，也就是说结果中x前的系数是10。</li>
<li>与之相似的，矩阵向量乘积的第三个坐标就是3乘以1，这对应于x^3 的导数是 3x^2。</li>
<li>在此之后的坐标都是0。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E5%BA%94%E7%9F%A9%E9%98%B5.png" alt="空间内的多项式对应矩阵"></li>
<li>求导满足线性性质是这一过程成为可能。</li>
</ul>
<hr>
<h3 id="✍️线代和函数中概念之间的关联"><a href="#✍️线代和函数中概念之间的关联" class="headerlink" title="✍️线代和函数中概念之间的关联"></a>✍️线代和函数中概念之间的关联</h3><ul>
<li>矩阵向量乘法看起来好像跟求导毫不相干，但是它们其实是一家人。我们提到的许多线性代数的概念，在函数中都能找到对应的别名。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E4%BB%A3%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E8%81%94.png" alt="线代和函数的关联"></li>
</ul>
<hr>
<h2 id="✏️公理（Axioms）："><a href="#✏️公理（Axioms）：" class="headerlink" title="✏️公理（Axioms）："></a>✏️公理（Axioms）：</h2><h3 id="✍️上述提到的与向量有什么关系？："><a href="#✍️上述提到的与向量有什么关系？：" class="headerlink" title="✍️上述提到的与向量有什么关系？："></a>✍️上述提到的与向量有什么关系？：</h3><ul>
<li><strong>数学中有很多类似向量的事物，只要你处理的对象集具有合理的数乘和相加的概念，不管是空间中的箭头，一组数，函数的集合，还是自定义的其他奇怪东西的集合；线性代数中所有关于向量，线性变换和其他概念都应该适用于它。</strong></li>
<li>这些类似向量的事物，它们构成的集合被称为“向量空间”。</li>
<li>为了这些构想出来的向量空间合理，<strong>我们需要做的是建立一系列向量加法和数乘必须遵守的规则</strong>，如下：<blockquote>
<ol>
<li>向量加法满足结合律</li>
<li>向量加法满足交换律</li>
<li>向量加法的单位元存在</li>
<li>每个向量的加法逆元均存在</li>
<li>标量乘法与标量的域乘法相容</li>
<li>标量乘法的单位元纯真</li>
<li>标量乘法对向量加法满足分配律</li>
<li>标量乘法对域加法满足分配律</li>
</ol>
</blockquote>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95%E5%92%8C%E6%95%B0%E4%B9%98%E7%9A%84%E8%A7%84%E5%88%99.png" alt="向量加法和数乘的规则"></p>
<ul>
<li><strong>如上所述，这些规则被称为“公理”（Axioms）。</strong></li>
<li>在线性代数的现代理论中，如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足上述的八条公理。</li>
<li>不过这些实际上就是一个清单，用来保证向量加法和数乘的概念确实是你所希望的那样。</li>
</ul>
<h3 id="✍️公理的作用："><a href="#✍️公理的作用：" class="headerlink" title="✍️公理的作用："></a>✍️公理的作用：</h3><ul>
<li><strong>这些公理并非基础的自然法则，它们是一个媒介（interface）</strong>；也就是发现这些结论的数学家一边连接着你，一边也连接着其他的人，也就是想要把这些结论应用于新的向量空间的人。</li>
<li>有了这些公理，我们只需要根据这些公理去证明你的结论就可以了。只要其他人的定义满足这些公理，他们就能顺利的应用你的结论。</li>
<li>因此，你往往会把你所有的结论抽象的表述出来；也就是说仅仅根据这些公理表述，而不是集中于某一种特定的向量上，像是空间中的箭头或者函数等。</li>
<li>简而言之，这就是每一本教科书都会根据可加性和成比例性来定义线性变换，而不是用我们之前看到的“网格线保持平行且等距分布来”来定义。</li>
<li>所以，只要遵守上述“公理”的东西，都可以被定义为向量。</li>
</ul>
<hr>
<h2 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h2><p><strong>《线代本质》的内容这一章其实就是完结啦！！！下一章是《克莱姆法则，几何解释》，由于官方账号发在一起了，所以我会把下一章一起当作这个系列的笔记写在一起，所以下一章是第十二章！</strong></p>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第九章：基变换</title>
    <url>/2022/10/03/math_Essense_of_Linear_Algebra_P09/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第九章：基变换"><a href="#3Blue1Brown-线代本质第九章：基变换" class="headerlink" title="3Blue1Brown_线代本质第九章：基变换"></a>3Blue1Brown_线代本质第九章：基变换</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第九章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️基变换："><a href="#✏️基变换：" class="headerlink" title="✏️基变换："></a>✏️基变换：</h2><h3 id="✍️基的选择："><a href="#✍️基的选择：" class="headerlink" title="✍️基的选择："></a>✍️基的选择：</h3><ul>
<li>发生在向量与一组数之间的任意一种转化，都被称为一个坐标系（coordinate system），而其中两个特殊的向量i帽和j帽，被我们称为这个标准坐标的基向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_01.png" alt="基变换_01"></li>
<li>如上图所示，如果使用另一组不同的基向量，分别称之为b1和b2，它的第一个基向量b1指向右上方，第二个基向量b2指向左上方。如果在这个变换中，用坐标（5&#x2F;3.1&#x2F;3）来描述它，这意味着，根据他的两个基向量，获得那个向量的方法是b1乘以5&#x2F;3,b2乘以1&#x2F;3,再将两个结果相加。</li>
<li>总之，无论何时，我们用坐标来描述一个向量，将第一个坐标乘以b1，第二个坐标乘以b2，然后将两者相加，他最终得到的向量 ，会和我们认为的相同坐标的向量完全不同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_02.png" alt="基变换_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_03.png" alt="基变换_03"></li>
<li>如上图两个向量的表示方法看出，虽然我们都在关注空间中同一个向量，但可以用不同的语言（空间）和数字来描述它，使得结果大不相同。</li>
<li>如果我们使用普通的坐标系，并用方形网格表示单位，那么<strong>这些网格只是提供了一个可视化坐标系的途径，因此，它依赖我们对基的选择。因为在空间中，本身是没有网格的</strong>。</li>
<li><strong>如果用不同的方式绘制这个网格，它同样是一个框架，也只不过是有助于用另一种方式理解坐标含义的可视化工具。</strong></li>
<li>但是无论如何绘制这个网格，<strong>大家的原点总会是在（0，0），因此大家的原点是重合的。</strong> 它就是任何向量乘以0时你所得到的坐标。</li>
<li>但是，其他方式绘制的坐标轴的方向与网格间距有所不同，这依赖于它对基的选择。</li>
</ul>
<hr>
<h3 id="✍️如何在不同的坐标系之间进行转化？："><a href="#✍️如何在不同的坐标系之间进行转化？：" class="headerlink" title="✍️如何在不同的坐标系之间进行转化？："></a>✍️如何在不同的坐标系之间进行转化？：</h3><ul>
<li>一旦你将矩阵向量乘法理解为应用一个特定的线性变换，就会有一种非常直观的方法来考虑这里发生的事。</li>
<li>一个矩阵列为某个特殊的基向量时，这个矩阵可以看作一个线性变换，它将我们的基向量i帽和j帽，也就是我们眼中的（1，0）和（0，1），变换为那个特殊的基向量，也就是特殊被重新定义的（1，0）和（0，1）.</li>
<li>变换后的向量仍旧时相同的线性组合，不过使用的时新的基向量。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_04.png" alt="基变换_04"></li>
</ul>
<hr>
<h3 id="✍️逆（Inverse）："><a href="#✍️逆（Inverse）：" class="headerlink" title="✍️逆（Inverse）："></a>✍️逆（Inverse）：</h3><ul>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2_05.png" alt="基变换_05"></li>
<li>一个变换的逆是一个新的变换，它将所选的变换逆向进行。实践当中，尤其是在超过二维空间中研究时，你可以用计算机来计算矩阵的逆。</li>
<li>如果想知道一个矩阵变换的逆，那我们用这个基变换矩阵的逆乘以我们所使用的向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86_01.png" alt="基变换矩阵的逆_01"></li>
<li>以上就是如何在坐标系之间对单个向量的描述进行相互转化。</li>
<li>一个矩阵代表的是一个特殊的基向量，却用我们的坐标来描述；对于一个向量，这个矩阵将它的语言描述转化为我们的语言描述。</li>
<li>逆矩阵则与之相反。</li>
<li>向量并不是唯一用坐标表示的东西</li>
</ul>
<hr>
<ul>
<li>考虑某个线性变换，譬如逆时针旋转90度；用矩阵代表它的时候，我们是在跟踪i帽和j帽的去向；i帽变换后坐标是（0，1），j帽变换后坐标是（-1，0）；这些坐标也就成为了矩阵的列。</li>
<li>但是这种表示与我们对基向量的选择密切相关，因为我们跟踪的是i帽和j帽，并且是在我们自己的坐标系中记录着他们的去向。</li>
</ul>
<h3 id="✍️如何转化一个矩阵？："><a href="#✍️如何转化一个矩阵？：" class="headerlink" title="✍️如何转化一个矩阵？："></a>✍️如何转化一个矩阵？：</h3><blockquote>
<p>注：以下描述的我们的语言是我们使用的语言，代表我们使用的基向量和坐标系；另一种语言表述的变换暂用詹妮弗的语言代替，詹妮弗跟我们使用不同的坐标系和基向量。</p>
</blockquote>
<ol>
<li>我们从詹妮弗的语言描述的任意向量出发。</li>
<li>首先，我们不用它的语言描述这一过程，而是用基变换矩阵，转化为用我们的语言描述。这个矩阵的列代表是用我们的语言描述她的基向量。此时给出的是同一个向量，只不过是用我们的语言描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_01.png" alt="如何转化一个矩阵_01"></li>
<li>然后，将所得结果左乘线性变换矩阵；此时给出的是变换后的向量，但仍然是我们的语言来描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_02.png" alt="如何转化一个矩阵_02"></li>
<li>最后一步，像之前一样将所的结果左乘基变换矩阵的逆，从而得到变换后的向量，然而使用詹妮弗的语言来描述的。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5_03.png" alt="如何转化一个矩阵_03"></li>
</ol>
<ul>
<li>因为我们能够对詹妮弗语言描述的任一向量做同样的事情，首先应用基变换，然后应用线性变换，最后应用基变换的逆。这三个矩阵的复合给出的就是用詹妮弗语言买哦书店线性变换矩阵。它接收由詹妮弗语言描述的向量。，并输出用詹妮弗语言描述的变换后的向量。</li>
<li>所以如果詹妮弗用这个计算结果的矩阵与她坐标系中的一个向量相乘，结果就是在她坐标系中描述该向量旋转90度的结果。</li>
</ul>
<hr>
<h3 id="✍️总结："><a href="#✍️总结：" class="headerlink" title="✍️总结："></a>✍️总结：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E5%AD%A6%E4%B8%8A%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%BD%9C%E7%94%A8.png" alt="数学上的转移作用"></p>
<ul>
<li>每当你看到这样一个表达式：A逆乘以M乘以A，这就暗示着一种数学上的转移作用。中间的矩阵代表一种你所见的变换，而外侧两个矩阵代表着转移作用，也就是视角上的转化。矩阵乘积任然代表着同一个变换，只不过是从其他人的角度来看的。</li>
</ul>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第十章：特征向量与特征值</title>
    <url>/2022/10/06/math_Essense_of_Linear_Algebra_P10/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第十章：特征向量与特征值"><a href="#3Blue1Brown-线代本质第十章：特征向量与特征值" class="headerlink" title="3Blue1Brown_线代本质第十章：特征向量与特征值"></a>3Blue1Brown_线代本质第十章：特征向量与特征值</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️特征向量与特征值（Eigenvectors-and-Eigenvalues）："><a href="#✏️特征向量与特征值（Eigenvectors-and-Eigenvalues）：" class="headerlink" title="✏️特征向量与特征值（Eigenvectors and Eigenvalues）："></a>✏️特征向量与特征值（Eigenvectors and Eigenvalues）：</h2><h3 id="✍️举例描述："><a href="#✍️举例描述：" class="headerlink" title="✍️举例描述："></a>✍️举例描述：</h3><ul>
<li>首先，考虑二维空间中的某个线性变换，它将基向量i帽变换到坐标（3，0），j帽变换到坐标（1，2）。 我们关注它对一个特定向量的作用，并且考虑这个向量张成的空间，也就是通过原点和向量尖端的直线。大部分向量在变换中都离开了其张成的空间，意思是如果向量正好落在这条直线上，感觉更像是巧合。不过，某些特殊向量的确留在它们张成的空间里，与i围着矩阵对他的作用仅仅是拉伸或者压缩而已，如同一个标量。</li>
<li>在上文提到的变换中，基向量i帽就是这样一个特殊向量；i帽张成的空间是x轴，从矩阵的第一列看出，i帽变成了原来的三倍，但任然留在x轴上。</li>
<li>此外因为线性变换的性质，x轴上的任何其他向量都只是被拉伸为原来的三倍，因此也就留在它们张成的空间里。</li>
<li>有一个略显隐蔽的向量（-1，1），它在变换中也留在自己张成的空间里；它最终被拉伸为原来的两倍。同上，线性性质暗示着一点，处在他所张成的对角线上的其他任何一个向量也仅仅被拉伸为原来的两倍。</li>
<li>对这个变换而言，以上就是所拥有这一特殊性质（留在它们张成的空间里）的向量。x轴上的向量被拉伸为原来的三倍，而对角线上的向量被拉伸为原来的两倍。任何其他向量在变换中都有或多或少的旋转，从而离开它张成的直线。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_01.png" alt="特征向量_01"></li>
<li><strong>这些特殊的向量就被称为变换的“特征向量”；每个特征向量都有一个所属的值，被称为“特征值”，即衡量特征向量在变换中拉伸或压缩比例的因子。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_02.png" alt="特征向量_02"></li>
</ul>
<hr>
<h3 id="✍️特征值可以为负吗？："><a href="#✍️特征值可以为负吗？：" class="headerlink" title="✍️特征值可以为负吗？："></a>✍️特征值可以为负吗？：</h3><ul>
<li>可以，并且与特征值为正的情况下并无差别。</li>
<li>举个例子，你有一个特征值-1&#x2F;2的特征向量，意味着这给个向量被反向，并且被压缩成原来的一半。但是重点在于，它停留在它张成的直线上，并未发生旋转。</li>
<li>考虑一个三维空间中的旋转，如果你能找到这个旋转的特征向量，也就是留在他张成空间里的向量，那么你找到的就是旋转轴（axis of rotation）。而且把一个三维旋转看成绕某个轴旋转一定角度，要比考虑相应的3x3矩阵直观的多。顺带一提，在这种情况下，相应的特征值必须为1，因为旋转并不缩放任何一个向量，所以向量的长度保持不变。</li>
<li>对于任意矩阵描述的线性变换，你可以通过将矩阵的列看作变换后的基向量来理解它。但是理解线性变换作用的关键往往是较少依赖于你的特定坐标系；更好的方法是求出它的特征向量和特征值。</li>
</ul>
<hr>
<h3 id="✍️计算思想："><a href="#✍️计算思想：" class="headerlink" title="✍️计算思想："></a>✍️计算思想：</h3><ul>
<li>用符号表示的话，下图所示就是特征向量的概念。A是代表某个变换的矩阵，v是特征向量；λ（lambda）是一个数，也就是对应的特征值。</li>
<li>这个等式也就是说：矩阵向量乘积，也就是A乘以v，等于特征向量v乘以某个数λ。</li>
<li>因此求解矩阵A的特征向量和特征值，实际上就是求解使得这个等式成立的向量v和数λ。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_01.png" alt="特征向量_计算_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_02.png" alt="特征向量_计算_02"></li>
<li>等号左侧代表的是矩阵向量乘积，但是等号右侧代表的是向量数乘。所以我们首先将等号右侧重写为某个矩阵向量乘积，其中，矩阵的作用效果是将任一向量乘以λ；这个矩阵的列代表着变换后的基向量，而每个基向量仅仅与λ相乘。所以这个矩阵的对角元素均为λ，而其余位置都是0。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_03.png" alt="特征向量_计算_03"></li>
<li>通常的书写方式是提出因子λ，写作λ乘以I，这里的I就是单位矩阵，对角元均为1；现在两侧就都是矩阵向量乘积的形式。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_04.png" alt="特征向量_计算_04"></li>
</ul>
<hr>
<ul>
<li>如下图所示，此时，我们就能将等号右侧的东西移到左侧，然后提出因子v。现在我们得到的是一个新的矩阵：A减去λ乘以单位矩阵。我们就寻找一个向量v，使得这个新矩阵与v相乘结果为零向量。如果v本身就是零向量的话，这个等式恒成立，但这没什么意思，因为我们希望的是一个非零特征向量；所以我们寻找的是一个det（A-λI）&#x3D; 0 的情况。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_05.png" alt="特征向量_计算_05"></li>
<li>所以，<strong>空间压缩，对应的就是矩阵的行列式为零的情况</strong>。举个例子，假设你有一个矩阵，列为（2，1）和（2，3），考虑每个对角元都减去某个变量λ；然后逐渐调整λ的值，当λ的值改变时，矩阵本身发生改变，因此行列式也在改变。目标在于找到一个λ使得这个行列式为零。也就是说调整后的变换将空间压缩到一个更低的维度上。在这个列子中，λ等于1时恰到好处。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_06.png" alt="特征向量_计算_06"></li>
<li>当然，如果选择其他矩阵，那特征值不一定是1，λ就需要取其他的值来使行列式为零。</li>
<li>当λ等于1时，A减去λ乘以单位矩阵将空间压缩到一条直线上，这意味着存在一个非零向量v，使得A减去λ乘以单位矩阵的结果乘以v等于零向量。记住一点就是：我们关注它是因为它意味着A乘以v等于λ乘以v。也就是说向量v是A的一个特征向量，在变换中停留在它张成的空间里。</li>
<li>在上述的例子中，v对应的特征值是1，所以它实际上保持不变。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F_%E8%AE%A1%E7%AE%97_07.png" alt="特征向量_计算_07"></li>
</ul>
<hr>
<h4 id="二维线性变换不一定有特征向量："><a href="#二维线性变换不一定有特征向量：" class="headerlink" title="二维线性变换不一定有特征向量："></a>二维线性变换不一定有特征向量：</h4><ul>
<li>举例来说，想象一个90度旋转，它并没有特征向量，因为每一个向量都发生了旋转并离开了其张成的空间。</li>
</ul>
<h4 id="只有一个特征值，但是特征向量不止在一条直线上："><a href="#只有一个特征值，但是特征向量不止在一条直线上：" class="headerlink" title="只有一个特征值，但是特征向量不止在一条直线上："></a>只有一个特征值，但是特征向量不止在一条直线上：</h4><ul>
<li>一个简单的例子：将所有向量变为两倍的矩阵，唯一的特征值是2，但是平面内每一个向量都是属于这个特征值的特征向量。</li>
</ul>
<hr>
<h2 id="✏️特征基（Eigenbasis）："><a href="#✏️特征基（Eigenbasis）：" class="headerlink" title="✏️特征基（Eigenbasis）："></a>✏️特征基（Eigenbasis）：</h2><h4 id="如果基向量恰好是特征向量，会发生什么？"><a href="#如果基向量恰好是特征向量，会发生什么？" class="headerlink" title="如果基向量恰好是特征向量，会发生什么？"></a>如果基向量恰好是特征向量，会发生什么？</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%9F%BA_01.png" alt="特征基_01"></p>
<ul>
<li>如上图所示，比如说，可能i帽变为原来的（-1）倍，j帽变为原来的2倍；将它们的新坐标作为矩阵的列，注意它们的倍数-1和2，也就是i帽和j帽所属的特征值，位于矩阵的对角线上，而其他的元素均为0。</li>
<li>除了对角元素以外其他元素均为0的矩阵被称为<strong>对角矩阵</strong>（Diagonal Matrix）。解读它的方法是，所有的基向量都是特征向量。矩阵的对角元是它们所属的特征值。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5.png" alt="对角矩阵"></li>
<li>对角矩阵在很多方面都更容易处理，其中一个重要方面是，矩阵与自己多次相乘的结果更容易计算；因为对角矩阵仅仅让基向量与某个特征值相乘，所以多次应用矩阵乘法，比如一百次，也只是将每个基向量与对应特征值的一百次幂相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="对角矩阵乘法"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95_02.png" alt="对角矩阵乘法_02"></li>
<li>相比之下，尝试计算一个非对角矩阵的一百次幂，就很不容易。</li>
</ul>
<hr>
<ul>
<li>我们知道了特征向量的计算更为简便，所以可以通过变换坐标系，使得特征向量就是基向量，并用特征向量作为基。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5_01.png" alt="基变换矩阵_01"></li>
<li>取出你想用做新基的向量的坐标，在这里指的是两个特征向量，然后将坐标作为一个矩阵的列，这个矩阵就是<strong>基变换矩阵</strong>，在右侧写下基变换矩阵，在左侧写下基变换矩阵的逆，当你将原始的变换夹在两个矩阵中间时，所得的矩阵代表队是同一个变换，不过是从新基向量所构成的坐标系的角度来看的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5_02.png" alt="基变换矩阵_02"></li>
<li>用特征向量来完成这件事的意义在于，这个新矩必然是对角的，并且对角元为对应的特征值。这是因为，他所处的坐标系的基向量在变换中只进行了缩放。</li>
<li><strong>一组基向量（同样是特征向量）构成的集合被称为一组“特征基”</strong>，这也非常合理。</li>
<li>所以说，如果你要计算这个矩阵的一百次幂，一种更容易的做法是先变换到特征基，在那个坐标系中计算一百次幂之后，再转换回标准坐标系。</li>
</ul>
<h3 id="✍️并非所有矩阵都可以对角化"><a href="#✍️并非所有矩阵都可以对角化" class="headerlink" title="✍️并非所有矩阵都可以对角化"></a>✍️并非所有矩阵都可以对角化</h3><ul>
<li>切记，并不是所有变换都能进行这一过程，并非所有矩阵都可以对角化。</li>
<li>比如剪切变换，它的特征向量不够多，并不能张成全空间。</li>
<li>如果你能找到一组特征基（能张成全空间的特征向量），矩阵运算就会变得非常轻松。</li>
</ul>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释</title>
    <url>/2022/10/08/math_Essense_of_Linear_Algebra_P12/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释"><a href="#3Blue1Brown-线代本质第十二章：克莱姆法则，几何解释" class="headerlink" title="3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释"></a>3Blue1Brown_线代本质第十二章：克莱姆法则，几何解释</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第十二章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>《<strong>线代本质》的内容在我的第十一章的笔记就是完结篇，这篇第十二章《克莱姆法则，几何解释》由于官方账号发在一起了，所以我也当作这个系列一起写了</strong></li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️克莱姆法则，几何解释："><a href="#✏️克莱姆法则，几何解释：" class="headerlink" title="✏️克莱姆法则，几何解释："></a>✏️克莱姆法则，几何解释：</h2><h3 id="✍️克莱姆法则以及背后的几何原理："><a href="#✍️克莱姆法则以及背后的几何原理：" class="headerlink" title="✍️克莱姆法则以及背后的几何原理："></a>✍️克莱姆法则以及背后的几何原理：</h3><ul>
<li><strong>克莱姆法则是线性代数中一个关于求解线性方程组的定理。它适用于变量和方程数目相等的线性方程组。</strong></li>
<li>克莱姆法则并不是计算线性方程组最好的方法，比如高斯消元法（Gaussian Elimination）会算的更快。这一部分内容就可以当作是扩展视野，它会帮你加深对线性方程组的理解。</li>
<li>在知道了这方面的知识后，你就会发现行列式或者线性方程组，这些知识都非常相关。</li>
<li><strong>举例来说：这里有x和y两个未知数和两个方程，原则上来说，只要未知数和方程个数一样，我们所说的都适用。</strong></li>
<li><strong>目前，我们将只讨论非零行列式的情况。这意味着线性变换后不改变维数。每个输入向量有且仅有一个输出向量；且每一个输出向量也仅对应一个输入向量。</strong></li>
</ul>
<hr>
<h3 id="✍️正交变换（Orthonormal）："><a href="#✍️正交变换（Orthonormal）：" class="headerlink" title="✍️正交变换（Orthonormal）："></a>✍️正交变换（Orthonormal）：</h3><ul>
<li>那些不改变点积的矩阵变换有一个特殊的名字：“正交变换”（Orthonormal）。它们使基向量在变化后依然保持单位长度且互相垂直。</li>
<li>可以想象成是旋转矩阵，相当于刚体运动，没有拉伸，压缩或者变形。</li>
<li>用正交矩阵来求解线性系统非常简单，因为点积保持不变，所以已知的输出向量和矩阵的列向量的点积，分别等同于未知输入向量和各个基向量的点积。也就是输入向量的每一个坐标。</li>
<li>因此，在特殊情况下，x等于第一列向量已知向量的点积，y等于第二列向量与已知向量的点积。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%AD%A3%E4%BA%A4%E5%8F%98%E6%8D%A2.png" alt="正交变换"></li>
<li>注意：这个思路对于大多数线性方程组都不成立，但是他给了我们一个方向去思考：有没有另一种对输入向量坐标值的几何解释，能在矩阵变换后保持不变呢？</li>
</ul>
<hr>
<h4 id="在二维空间中："><a href="#在二维空间中：" class="headerlink" title="在二维空间中："></a>在二维空间中：</h4><ul>
<li>如果逆非常熟悉行列式，你可能会想到一个很棒的想法：这个由第一个基向量i和位置的输入向量[x；y]组成的平行四边形；面积是长度为1的底，乘上与底边垂直的高（也就是输入向量y的坐标值）。</li>
<li>因此，我们拐了一个弯，用这个平行四边形的面积来表示y值。</li>
<li>更准确的说，你应该考虑这个平行四边形的有向面积。如下图所示。</li>
<li>正如行列式的那样，如果向量y的坐标为负，那么四边形的面积也为负。前提是你把基向量i放在第一位来定义平行四边形。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF.png" alt="平行四边形的有向面积"></li>
<li>同样，观察由未知的输入向量和第二基向量j组成的平行四边形；它的面积等于向量的x坐标。</li>
<li>用这种方式表示x的值也有点奇怪。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%BB%A5j%E4%B8%BA%E5%BA%95%EF%BC%89.png" alt="平行四边形的有向面积（以j为底）"></li>
</ul>
<hr>
<h4 id="在三维空间中："><a href="#在三维空间中：" class="headerlink" title="在三维空间中："></a>在三维空间中：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%85%AD%E9%9D%A2%E4%BD%93%E9%9D%A2%E7%A7%AF.png" alt="平行六面体面积"></p>
<ul>
<li>考虑向量与另外两个基向量i和j所组成的平行六面体，底面是由基向量i和j组成的正方形，面积是1；所以他的体积等于它的高，也就是我们这个向量的z坐标。</li>
<li>同样的，用这个奇怪的方法来描述向量在某一个轴上的坐标值，可以先考虑向量，和除了这个轴紫外的两个基向量组成的平行六面体。然后其体积就是对应的坐标值。</li>
<li>另外，我们可以讨论平行六面体的有向体积，就是之前在行列式中提到过的右手法则。这时，你列出的这三个向量的顺序就很重要了。这样就表明坐标的正负性也是有意义的。</li>
</ul>
<hr>
<h3 id="✍️将坐标值和面积或体积联系起来的意义："><a href="#✍️将坐标值和面积或体积联系起来的意义：" class="headerlink" title="✍️将坐标值和面积或体积联系起来的意义："></a>✍️将坐标值和面积或体积联系起来的意义：</h3><ul>
<li>因为当你做矩阵变换后，平行四边形的面积不一定保持不变，可能成比例的增大或减小。但是，所有面积伸缩的比例都是一样的，都等于给定变换矩阵的行列式。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%89%80%E6%9C%89%E9%9D%A2%E7%A7%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E6%AF%94%E4%BE%8B%E9%83%BD%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%88%97%E5%BC%8F.png" alt="所有面积伸缩的比例都等于给定行列式"></li>
<li>考虑一个新的平行四边形；第一条边是变换后的第一基向量（也就是矩阵的第一列）；第二条边是变换后的[x,y]，那它的面积是多大呢？</li>
<li>其实这就是我们之前提及的平行四边形的变换。变换前，面积是未知输入向量的y坐标值，所以变换后的面积等于矩阵的行列式乘以y值。</li>
<li>所以可以用输出的平行四边形面积除以矩阵的行列式计算出y。既然我们已知最终变换后的向量，那么可以构造一个新矩阵，第一列和我们原先的矩阵相同，而第二列是输出向量，然后取新矩阵的行列式。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B0%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt="新平行四边形面积"></li>
<li>我们只需使用到变换后的两个向量，也就是矩阵的列向量和已知输出向量，就能计算出位置输入向量的y值，此时方程已经解好一半了。</li>
<li>我们可以用相同的方法得出x值。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B0%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF_x.png" alt="新平行四边形面积_x"></li>
<li><strong>这个线性方程组的解法，被称为克莱姆法则。</strong></li>
<li>三维或者多维的计算结果也基本如此。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2023阶段作品集</title>
    <url>/2023/04/28/protfolio_2023/</url>
    <content><![CDATA[<h1 id="2023阶段作品集"><a href="#2023阶段作品集" class="headerlink" title="2023阶段作品集"></a>2023阶段作品集</h1><blockquote>
<p>🍺你好，这里是我阶段性作品的更新！今后会不断完善！<br>🍺今后会将重点放在SD，Houdini以及UE的效果上，请期待后续！<br>🍺关于所展示的效果，我大部分均在bilibili放出了分解，请前去：<a href="https://space.bilibili.com/552910222?spm_id_from=333.788.0.0">ZeTiiCannotstop的blibili</a>  来查看</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/00_cover.png" alt="00_cover"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/00_01.png" alt="00_01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p01.png" alt="p01"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p02.png" alt="p02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p03.png" alt="p03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p04.png" alt="p04"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p05.png" alt="p05"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p06.png" alt="p06"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p07.png" alt="p07"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p08.png" alt="p08"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p09.png" alt="p09"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p10.png" alt="p10"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p11.png" alt="p11"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p12.png" alt="p12"></p>
]]></content>
      <categories>
        <category>-Protfolio</category>
      </categories>
      <tags>
        <tag>-Protfolio</tag>
      </tags>
  </entry>
  <entry>
    <title>2022/11月-2023/1月 SD练习</title>
    <url>/2023/01/18/sd_practice001/</url>
    <content><![CDATA[<h1 id="2022-x2F-11月-2023-x2F-1月-SD练习"><a href="#2022-x2F-11月-2023-x2F-1月-SD练习" class="headerlink" title="2022&#x2F;11月-2023&#x2F;1月 SD练习"></a>2022&#x2F;11月-2023&#x2F;1月 SD练习</h1><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP3.png" alt="sdTOP3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP3_1.png" alt="sdTOP3_1"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render.png" alt="wood_paint_peeling_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render2.png" alt="wood_paint_peeling_render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_paint_peeling_render3.png" alt="wood_paint_peeling_render3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/tarmac_worn_roadMark_render.png" alt="tarmac_worn_roadMark_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/tarmac_worn_roadMark_render2.png" alt="tarmac_worn_roadMark_render2"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP5.png" alt="sdTOP5"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches04_render_NObg3.png" alt="patches04_render_NObg3"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches05_render.png" alt="patches05_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches01_render.png" alt="patches01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches03_render.png" alt="patches03_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches04_render.png" alt="patches04_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/patches02_render.png" alt="patches02_render"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP6.png" alt="sdTOP6"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ji.png" alt="ji"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lowlow.png" alt="lowlow"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTop_sand.png" alt="sdTop_sand"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_realistic001_render.png" alt="sand_realistic001_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_realistic001_render2.png" alt="sand_realistic001_render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_stylized001_render.png" alt="sand_stylized001_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sand_stylized002_render.png" alt="sand_stylized002_render"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP4.png" alt="sdTOP4"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wood_patterns_stylized01_render.png" alt="wood_patterns_stylized01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_woodPlanks01_render.png" alt="Ground_woodPlanks01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_wall_mix01_render.png" alt="WOOD_wall_mix01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_pattern02_render.png" alt="WOOD_pattern02_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards001_scrachesPeeling_old_Render.png" alt="woodBoards001_scrachesPeeling_old_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards001_scrachesPeeling_old_Render2.png" alt="woodBoards001_scrachesPeeling_old_Render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/woodBoards002_horizontalBoards_colorMix_Render.png" alt="woodBoards002_horizontalBoards_colorMix_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/WOOD_board002_hotizontal_render.png" alt="WOOD_board002_hotizontal_render"></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/top.png" alt="top"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile2_render.png" alt="Ground_Tile2_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile0_render.png" alt="Ground_Tile0_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Bricks_Tile01_render.png" alt="Bricks_Tile01_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Ground_Tile1_render.png" alt="Ground_Tile1_render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metalPlates001_rustPeeling_Render.png" alt="metalPlates001_rustPeeling_Render"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metalPlates001_rustPeeling_Render2.png" alt="metalPlates001_rustPeeling_Render2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wall_smooth_render.png" alt="wall_smooth_render"></p>
]]></content>
      <categories>
        <category>-Substance Designer</category>
      </categories>
      <tags>
        <tag>-Substance Designer</tag>
      </tags>
  </entry>
  <entry>
    <title>Substance Designer这一阵子的练习汇总（一）</title>
    <url>/2022/12/10/sd_sdPractice_woodPeeling/</url>
    <content><![CDATA[<h1 id="这里是关于SD生成器的"><a href="#这里是关于SD生成器的" class="headerlink" title="这里是关于SD生成器的"></a><center>这里是关于SD生成器的</center></h1><h3 id="木漆剥落生成器以及水彩笔触生成器"><a href="#木漆剥落生成器以及水彩笔触生成器" class="headerlink" title="木漆剥落生成器以及水彩笔触生成器"></a><center>木漆剥落生成器以及水彩笔触生成器</center></h3>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=390513592&bvid=BV1vd4y1t7Ca&cid=902733440&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>



]]></content>
      <categories>
        <category>-Substance Designer</category>
      </categories>
      <tags>
        <tag>-Substance Designer</tag>
      </tags>
  </entry>
  <entry>
    <title>Light_a_Project_in_UE</title>
    <url>/2022/09/18/ue_Light_a_Project_in_UE/</url>
    <content><![CDATA[<p><strong>🍊这篇是UE的灯光与烘培的学习笔记，不大全面，有问题请随时指正🍊</strong><br>🍊这里是b站<a href="https://www.bilibili.com/video/BV17K4y1L7Gf/?spm_id_from=333.788.recommend_more_video.3&vd_source=95a1cfccd5b1e6779677de477b25aa31%5C">链接</a>🍊</p>
<hr>
<h1 id="Unreal-灯光照明与烘培"><a href="#Unreal-灯光照明与烘培" class="headerlink" title="Unreal 灯光照明与烘培"></a>Unreal 灯光照明与烘培</h1><h2 id="🚩【主要涵盖的话题】"><a href="#🚩【主要涵盖的话题】" class="headerlink" title="🚩【主要涵盖的话题】"></a>🚩【主要涵盖的话题】</h2><ol>
<li>技术和艺术的讨论</li>
<li>资产和场景的准备</li>
<li>灯光烘培设置</li>
<li>动态照明设置</li>
<li>图像基础的灯光设置</li>
<li>阴影</li>
<li>反射</li>
</ol>
<hr>
<h2 id="🚩【一：目标媒介】"><a href="#🚩【一：目标媒介】" class="headerlink" title="🚩【一：目标媒介】"></a>🚩【一：目标媒介】</h2><ul>
<li>考虑项目是否会定义到移动设备，或者是在一些需要高保真的媒体设备使用</li>
<li>每个镜头都是独立的视频项目的编辑方案</li>
<li>对于24FPS，30FPS和60FPS的项目的不同处理的方案</li>
<li>不需要完全实时渲染的项目</li>
<li>如果整个项目都是静态的，那么可以预先烘培</li>
<li>开放世界的灯光无法提前烘培，所以需要light map并使用动态照明处理</li>
<li>考虑硬件的最低规格</li>
</ul>
<hr>
<h2 id="🚩【二：Deferred-Renderer和Forward-Renderer】"><a href="#🚩【二：Deferred-Renderer和Forward-Renderer】" class="headerlink" title="🚩【二：Deferred Renderer和Forward Renderer】"></a>🚩【二：Deferred Renderer和Forward Renderer】</h2><h3 id="🥕Deferred-Renderer："><a href="#🥕Deferred-Renderer：" class="headerlink" title="🥕Deferred Renderer："></a>🥕Deferred Renderer：</h3><ul>
<li>是UE4的默认渲染器</li>
<li>它的工作方式就是储存所有原始数据在Screen Space Buffers（Color，Normal，Depth，…）然后将他们组合到一起成为Final Image</li>
<li>照明灯光一起评估</li>
<li>额外的screen space则会被用在更复杂的后处理效果与照明效果的组合</li>
<li>支持所有的渲染功能</li>
</ul>
<h3 id="🥕Forward-Renderer："><a href="#🥕Forward-Renderer：" class="headerlink" title="🥕Forward Renderer："></a>🥕Forward Renderer：</h3><ul>
<li>为了VR开发的</li>
<li>所有的lighting和shading都在object draw time进行评估计算</li>
<li>可以做特有的材质优化</li>
<li>更多的抗锯齿操作</li>
</ul>
<hr>
<h2 id="🚩【三：如何给一套好的照明准备资产】"><a href="#🚩【三：如何给一套好的照明准备资产】" class="headerlink" title="🚩【三：如何给一套好的照明准备资产】"></a>🚩【三：如何给一套好的照明准备资产】</h2><ol>
<li><strong>确保材质是物理正确的</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/matRef.png" alt="matRef"><br>   常见问题有：<ul>
<li><ol>
<li>base color太亮或太暗。</li>
</ol>
</li>
<li><ol start="2">
<li>金属度为了确认是不是金属最好保持是1或0。</li>
</ol>
</li>
<li><ol start="3">
<li>specular保持0到1之间的灰度，而不是颜色。</li>
</ol>
</li>
<li><ol start="4">
<li>最黑的常见物是碳（rgb：0.03），最白的是雪（rgb：0.9）。永远不会是纯白或纯黑。</li>
</ol>
</li>
<li><ol start="5">
<li>vantablack是世界上最黑的黑（rgb：0.0045, roughness:1）</li>
</ol>
</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vantablack.png" alt="vantablack"></li>
</ul>
</li>
<li><strong>打灯前确保移除自动曝光</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/deactiveAutoExposure.png" alt="deactiveAutoExposure"></li>
<li><strong>放置chrome sphere和grey sphere</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/chromeSphere.png" alt="chromeSphere"><br> 保证它是纯反射物</li>
<li><strong>设置一个3.14（pi）的 directional light，并且用color picker 查看灰度</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/50%Grey.png" alt="50%Grey"></li>
</ol>
<hr>
<h2 id="🚩【四：烘培灯光-VS-动态灯光】"><a href="#🚩【四：烘培灯光-VS-动态灯光】" class="headerlink" title="🚩【四：烘培灯光 VS 动态灯光】"></a>🚩【四：烘培灯光 VS 动态灯光】</h2><h3 id="🥕Baked-Lighting："><a href="#🥕Baked-Lighting：" class="headerlink" title="🥕Baked Lighting："></a>🥕Baked Lighting：</h3><h4 id="🤓优势："><a href="#🤓优势：" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol>
<li>GI</li>
<li>cheap soft shadows，陈本低的阴影</li>
<li>Less GPU demanding，较低的GPU需求</li>
</ol>
<h4 id="😈劣势："><a href="#😈劣势：" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol>
<li>slower iteration，迭代变慢</li>
<li>static lighting，是静态的，如果生成更多的资产则新资产不会对照明产生影响</li>
<li>more maps in memory，需要储存空间来放light maps</li>
</ol>
<h3 id="🥕Dynamic-Lighting："><a href="#🥕Dynamic-Lighting：" class="headerlink" title="🥕Dynamic Lighting："></a>🥕Dynamic Lighting：</h3><h4 id="🤓优势：-1"><a href="#🤓优势：-1" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol>
<li>what u see is what u get，所见及所得</li>
<li>非静态的</li>
</ol>
<h4 id="😈劣势：-1"><a href="#😈劣势：-1" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol>
<li>No GI</li>
<li>GPU demanding，对GPU有要求</li>
</ol>
<hr>
<h2 id="🚩【五：常用烘培灯光设置】"><a href="#🚩【五：常用烘培灯光设置】" class="headerlink" title="🚩【五：常用烘培灯光设置】"></a>🚩【五：常用烘培灯光设置】</h2><h3 id="基础灯光设置："><a href="#基础灯光设置：" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol>
<li>Direction Light（Stationary）</li>
<li>Lightmass Baking（GI）</li>
<li>Skydome（static）</li>
</ol>
<h3 id="什么是light-map？"><a href="#什么是light-map？" class="headerlink" title="什么是light map？"></a>什么是light map？</h3><ul>
<li>light maps以纹理贴图的形式储存了灯光信息</li>
<li>它是HDR tecture并且储存了灯光方向</li>
<li>它的好处是处理起来很快，阴影柔和，但是如果文件太小则会缺少阴影的细节清晰度。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset2.png" alt="lightasset2"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset.png" alt="lightasset"></li>
<li>min lightmap resolution将定义UV islands（padding）之间的空间</li>
<li>更小的padding会减少像素的浪费以及在相同的分辨率下得到更好的阴影效果</li>
</ul>
<hr>
<h3 id="Lighting-Type："><a href="#Lighting-Type：" class="headerlink" title="Lighting Type："></a>Lighting Type：</h3><ul>
<li>当烘培灯光时，一般只会使用static light（静态光） 或者是 stationary light（固定光）</li>
<li>emit photons：<ul>
<li>Directional light</li>
<li>point light</li>
<li>spot light</li>
</ul>
</li>
<li>emit no photon：<ul>
<li>sky light</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Lightmass-Setting："><a href="#Lightmass-Setting：" class="headerlink" title="Lightmass Setting："></a>Lightmass Setting：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass.png" alt="lightmass"></p>
<ul>
<li>static Lighting Level Scale * Indirect Lighting Quality &#x3D; 1.0;</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass_chart.png" alt="lightmass_chart"></p>
<ul>
<li>间接照明质量是最影响时长的</li>
</ul>
<hr>
<ul>
<li><strong>volume light sample scale</strong><ul>
<li>降低static lighting level scale会增加volume lighting samples的数量</li>
</ul>
</li>
<li><strong>lightmass Portal</strong><ul>
<li>对门窗类型的照明十分有用</li>
</ul>
</li>
<li><strong>lighting Scenarios</strong><ul>
<li>只用编辑一个enviroment level</li>
<li>照明方案会以light maps的形式分别储存</li>
<li>一个时间使用一个照明方案（不存在过渡，不能同时拥有两种在一个场景）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🚩【六：常用动态照明设置】"><a href="#🚩【六：常用动态照明设置】" class="headerlink" title="🚩【六：常用动态照明设置】"></a>🚩【六：常用动态照明设置】</h2><h3 id="基础灯光设置：-1"><a href="#基础灯光设置：-1" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol>
<li>Direction Light（movable）</li>
<li>SKydome（moveable）</li>
<li>Distance Field AO</li>
<li>Screen Space AO</li>
</ol>
<h3 id="什么是Distance-Field："><a href="#什么是Distance-Field：" class="headerlink" title="什么是Distance Field："></a>什么是Distance Field：</h3><ul>
<li>Distance Field 储存了每个点到最近表面的距离</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/distanceField.png" alt="distanceField"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/df_setup.png" alt="df_setup"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/dfao.png" alt="dfao"></li>
<li>需要避免过多的缩放</li>
<li>很大的物体对于distance field 的支持不理想，需要拆分成较小的部分</li>
</ul>
<h2 id="🚩【七：图像基础的照明-IBL】"><a href="#🚩【七：图像基础的照明-IBL】" class="headerlink" title="🚩【七：图像基础的照明 IBL】"></a>🚩【七：图像基础的照明 IBL】</h2><h3 id="基础灯光设置：-2"><a href="#基础灯光设置：-2" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ul>
<li>设置场景，确保有一个平面可以投射并接受阴影</li>
<li>有一个back plate（需要制作跟踪）（可以理解为UE里做nuke的事情）</li>
<li>Directional light（moveable）</li>
<li>Skylight with HDRI（moveable）</li>
<li>fake steps shadow</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/backPlate.png" alt="backPlate"></li>
<li>当人走向光照位置则激活阴影</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/IBL.png" alt="IBL"></li>
</ul>
<hr>
<h2 id="🚩【八：shadow-maps，for-Dynamic-Shadowing】"><a href="#🚩【八：shadow-maps，for-Dynamic-Shadowing】" class="headerlink" title="🚩【八：shadow maps，for Dynamic Shadowing】"></a>🚩【八：shadow maps，for Dynamic Shadowing】</h2><ul>
<li>Depth map，判断存在阴影的部分</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/depthMap.png" alt="depthMap"></li>
<li>如果shadow map质量太低会有锯齿</li>
<li>如果shadow map bias太高则会有漏光</li>
<li>使用相机视锥来优化场景，近景给予更多的资源</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/camFrustum.png" alt="camFrustum"></li>
</ul>
<hr>
<h2 id="🚩【九：Directional-Light-Stationary-area-shadows：】"><a href="#🚩【九：Directional-Light-Stationary-area-shadows：】" class="headerlink" title="🚩【九：Directional Light Stationary area shadows：】"></a>🚩【九：Directional Light Stationary area shadows：】</h2><ul>
<li>激活Lightmass下的：use Area Shadows for Stationary Light</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/areaShadow.png" alt="areaShadow"></li>
</ul>
<hr>
<h2 id="🚩【十：capsule-shadows：】"><a href="#🚩【十：capsule-shadows：】" class="headerlink" title="🚩【十：capsule shadows：】"></a>🚩【十：capsule shadows：】</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/capsuleshadows.png" alt="capsuleshadows"></p>
<ul>
<li>使用一个类似资产的外轮廓来创建一个十分柔和的阴影</li>
</ul>
<hr>
<h2 id="🚩【十一：Raytraced-contact-shadows：】"><a href="#🚩【十一：Raytraced-contact-shadows：】" class="headerlink" title="🚩【十一：Raytraced contact shadows：】"></a>🚩【十一：Raytraced contact shadows：】</h2><ul>
<li>将contact shadow length 设置的很小来获得细节上的阴影</li>
<li>在比例很小的物体上很有用，但是比较耗费资源</li>
</ul>
<hr>
<h2 id="🚩【十二：Reflections：】"><a href="#🚩【十二：Reflections：】" class="headerlink" title="🚩【十二：Reflections：】"></a>🚩【十二：Reflections：】</h2><ul>
<li>反射较为资源</li>
<li>使用planer reflection来得到平面的反射（本质是在镜像它），平面的物体适用，但此不适用于有机形状。</li>
</ul>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-灯光</tag>
      </tags>
  </entry>
  <entry>
    <title>UE_Lighting Type</title>
    <url>/2022/11/03/ue_LightingType/</url>
    <content><![CDATA[<h1 id="UE4-虚幻引擎基础照明-灯光类型"><a href="#UE4-虚幻引擎基础照明-灯光类型" class="headerlink" title="UE4_虚幻引擎基础照明_灯光类型"></a>UE4_虚幻引擎基础照明_灯光类型</h1><blockquote>
<p>🍉本学习笔记是对UE灯光基础类型的理解，特此做记录，大佬自行跳过哈！</p>
</blockquote>
<hr>
<h2 id="✏️场景照明基础设置："><a href="#✏️场景照明基础设置：" class="headerlink" title="✏️场景照明基础设置："></a>✏️场景照明基础设置：</h2><ol>
<li><strong>Sky Light</strong>（提供间接照明）</li>
<li><strong>Directional Light</strong>（提供直接照明和光源方向）</li>
<li><strong>Point Lights</strong>（点光源）</li>
<li><strong>Spot Light</strong> （聚光灯）</li>
<li><strong>Rect Light</strong> （面光源）</li>
</ol>
<ul>
<li>以上提到的就是最常见的灯光，下面会介绍以上灯光几个常用属性便于打光时进行一个较为基础的设置。</li>
</ul>
<hr>
<h3 id="✍️使用【Directional-Light】需要注意的设置有如下几点："><a href="#✍️使用【Directional-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Directional Light】需要注意的设置有如下几点："></a>✍️使用【Directional Light】需要注意的设置有如下几点：</h3><ol>
<li><p><strong>【Mobility】</strong></p>
<ul>
<li><strong>static</strong>（静止），灯光全部会被烘培，纯静态光源，非实时，消耗最低，游戏中无法改变光源。</li>
<li><strong>stationary</strong>（静态），只烘培静态几何体的投影和反射光找，其他则为动态光源，此设置还允许光源在游戏中改变颜色和强度，但其并不会移动，且允许部分烘焙光照。</li>
<li><strong>movable</strong>（可移动），纯动态光源，可实时移动并动态投射阴影，消耗最多，拥有最高灵活性。</li>
</ul>
</li>
<li><p><strong>【Light】</strong></p>
</li>
</ol>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/directionalLight_Light.png" alt="directionalLight_Light"></p>
<ul>
<li><strong>Intensity</strong>，光照强度，场景光照量的多少</li>
<li><strong>Light color&#x2F; temperature</strong>，光照颜色，最好使用Temperature（开尔文）以取得真实的照明效果</li>
<li><strong>source angle&#x2F;source soft angle</strong>，针对柔化阴影</li>
<li><strong>affects world</strong>，开启或关闭灯光的影响</li>
<li><strong>cast shadows</strong>，是否投射阴影</li>
<li><strong>indirect lighting Intensity</strong>，如果将此提高，则此灯光再其中贡献更多的照明效果，可用于在阴影区域获得更多的反射光。</li>
</ul>
<hr>
<h3 id="✍️使用【Sky-Light】需要注意的设置有如下几点："><a href="#✍️使用【Sky-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Sky Light】需要注意的设置有如下几点："></a>✍️使用【Sky Light】需要注意的设置有如下几点：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SkyLight_Light.png" alt="SkyLight_Light"></p>
<ol>
<li><strong>【Cube Map】</strong><ul>
<li>帮助投射颜色</li>
<li>通常我们不会在这种类似HDR的照明下更改过多的灯光设置，所以尽量保持默认就可以。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="✍️使用【Point-Light】需要注意的设置有如下几点："><a href="#✍️使用【Point-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Point Light】需要注意的设置有如下几点："></a>✍️使用【Point Light】需要注意的设置有如下几点：</h3><ul>
<li>是最常使用的灯光，点光源，大部分命名相同的属性与directional Light相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/spotLight_Light.png" alt="pointLight_Light"><ul>
<li><strong>Attenuation Radius</strong>，衰减半径，可以理解是光照的距离或光照影响的半径，越大越远。</li>
<li><strong>source Radius</strong>，灯光半径，可以场景光中得到一些更柔和的灯光阴影，也有助于灯光获取更多信息，默认0的时候是一个很小的光源点。</li>
<li><strong>source Length</strong>，灯光长度，通常与source radius一起使用，在不想增加衰减半径的情况下，可以通过source Length来调整灯光影响的范围，看起来更加自然。</li>
<li><strong>use Inverse Squared Falloff</strong>，是否使用反比平方比。这是灯光的一种算法，是一种不同类型的光源衰减，主要是用来复制真实世界中的光源行为。它会让光照在靠近其源时非常亮，而在远离源时很快就变暗。</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/Lighting_4_2.jpg" alt="反比平方比"></p>
<h4 id="反比平方比的理解："><a href="#反比平方比的理解：" class="headerlink" title="反比平方比的理解："></a>反比平方比的理解：</h4><ul>
<li><p>使用平方反比衰减同时会改变光源的根本行为。首先，亮度从任意值变更为在 流明 中进行计算。这表示使用指数衰减（默认）的亮度为3的光源看起来是亮的，但如果您将其切换到平方反比衰减，光源仅有3流明，这时光源基本上看不见。</p>
</li>
<li><p>光源半径在使用平方反比衰减时也会改变。在使用默认的指数衰减时，半径可视为光源运动的范围，同时越接近半径范围，光照越会衰减。在使用平方反比衰减时，半径更像是一个限定值，对于衰减发生的实际范围不会产生影响。这表示您 可以 为获得最为真实的光源衰减而把半径值设置得非常高。但是，考虑到重叠的固定光源问题，一般情况下不要这样操作。</p>
</li>
</ul>
<hr>
<h3 id="✍️使用【Spot-Light】需要注意的设置有如下几点："><a href="#✍️使用【Spot-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Spot Light】需要注意的设置有如下几点："></a>✍️使用【Spot Light】需要注意的设置有如下几点：</h3><ul>
<li>实际上设置与点光源很相似，也是常用照明形式，是锥形的聚光灯投射形式。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/spotLights_Light.png" alt="spotLights_Light"></li>
<li><strong>inner cone angle&#x2F;outter cone angle</strong>，内外半径</li>
<li>其余大致设置与point light相似</li>
</ul>
<hr>
<h3 id="✍️使用【Rect-Light】需要注意的设置有如下几点："><a href="#✍️使用【Rect-Light】需要注意的设置有如下几点：" class="headerlink" title="✍️使用【Rect Light】需要注意的设置有如下几点："></a>✍️使用【Rect Light】需要注意的设置有如下几点：</h3><ul>
<li>有点像从一个实际的矩形散发出来的光，起着光源作用。</li>
<li>它在性能方面消耗较多，需要谨慎使用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RectLight_Light.png" alt="RectLight_Light"></li>
<li><strong>source Width&#x2F;source Height</strong>, 光源的长宽，注意如果直接缩放灯光其实是不会对灯光大小范围产生变化的，此时就需要设置灯光属性中的长宽。</li>
<li>其他设置与其他光源没有不同。</li>
</ul>
<hr>
<h2 id="✏️灯光优化："><a href="#✏️灯光优化：" class="headerlink" title="✏️灯光优化："></a>✏️灯光优化：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/UEviewMode.png" alt="UEviewMode"></p>
<ul>
<li>可以去带viewport中<strong>Detail Lighting</strong>的模式下进行灯光的调试，此模式不带材质的颜色信息，材质均会显示50%的灰度，但是依旧能看见法线以及粗糙度。这一模式可以帮助准确的查看灯光的颜色和强度。</li>
<li><strong>Light complexity</strong> 可以看见灯光的复合程度，从蓝到绿到红到白的这样一种变化，这是性能的可视化表现，其中消耗最高的是白色，以此类推。</li>
<li><strong>stationary Light overLap</strong>，此模式可以看清场景内使用stationary light投射出的动态阴影，但是它对于重叠的灯光范围（灯光半径相交的部分）有限制，最多使用四盏overlapping stationary lights。太多的灯光重叠，引擎会只计算那些有效的部分并且踢掉其中的一些多的。</li>
<li>使用starter content中的<strong>color calibrator</strong>来检查场景内光源。</li>
</ul>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-灯光</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5和SD_美漫风格的火车场景</title>
    <url>/2023/06/20/ue_TrainSC/</url>
    <content><![CDATA[<h1 id="UE整点心潮澎湃的风格！"><a href="#UE整点心潮澎湃的风格！" class="headerlink" title="UE整点心潮澎湃的风格！"></a>UE整点心潮澎湃的风格！</h1><blockquote>
<p>🍺看完【蜘蛛侠·纵横宇宙】的内心：真的太帅了！！！<br>🍺于是模仿一丢丢他的风格~<br>🍺火车的设计参考a站大佬lorenzo-lanfranconi，由于我改变了风格，与大佬的设计有所出入~</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/p01.png" alt="p01"></p>
<center>【具体展示可以看我b站的视频呦~】</center>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=360096437&bvid=BV1HX4y1s7r4&cid=1170158454&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>



]]></content>
      <categories>
        <category>-ue</category>
      </categories>
      <tags>
        <tag>-ue</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4官方材质课_基础篇</title>
    <url>/2022/09/13/ue_MatClass_foundation/</url>
    <content><![CDATA[<p>🐸本文为虚幻官方材质课的学习记录，并不完全，在此按我的个人需求记录了如下笔记。<strong>这一篇是基础篇</strong>。<br>🐸这里是基础篇<a href="https://www.bilibili.com/video/BV1fX4y1N7Fw?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸这里是高级篇<a href="https://www.bilibili.com/video/BV1sy4y127HZ/?spm_id_from=333.788.video.desc.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸<strong>加油 ！ 加油 ！</strong></p>
<hr>
<h1 id="UE4官方材质课-基础篇"><a href="#UE4官方材质课-基础篇" class="headerlink" title="UE4官方材质课_基础篇"></a>UE4官方材质课_基础篇</h1><h2 id="一：了解材质："><a href="#一：了解材质：" class="headerlink" title="一：了解材质："></a>一：了解材质：</h2><h3 id="🚩PBR（Physically-Based-Rendering）："><a href="#🚩PBR（Physically-Based-Rendering）：" class="headerlink" title="🚩PBR（Physically-Based Rendering）："></a>🚩PBR（Physically-Based Rendering）：</h3><p>基于物理的渲染。<br>它提供了一种光照和渲染方法，能够更精确的描绘光和表面之间的作用。<br>PBR流程能更真实的模拟光照和材质之间的物理交互效果。</p>
<ul>
<li>直观便于理解</li>
<li>物理上更具准确性<ul>
<li>pbr基于物理定律，如能量守恒定律和平方反比定律(Inverse-square law)</li>
<li>pbr材质在不同的光照下会表现的更一致</li>
</ul>
</li>
<li>使用真实的物理测量单位表示亮度<ul>
<li>Lumens(流明),Lux（勒克斯）</li>
</ul>
</li>
</ul>
<p>💡简单来说基于物理的渲染本质上是通过：</p>
<ul>
<li>材质</li>
<li>灯光</li>
<li>曝光</li>
</ul>
<p>这三大部分控制的组合结果。</p>
<h3 id="🚩Primary-PBR-Inputs："><a href="#🚩Primary-PBR-Inputs：" class="headerlink" title="🚩Primary PBR Inputs："></a>🚩Primary PBR Inputs：</h3><ul>
<li>Base col</li>
<li>Metallic</li>
<li>Specular</li>
<li>Roughness</li>
</ul>
<h4 id="🏕️Base-color（Albedo）"><a href="#🏕️Base-color（Albedo）" class="headerlink" title="🏕️Base color（Albedo）"></a>🏕️Base color（Albedo）</h4><ul>
<li>flat color,没有任何光照信息（没有高光和阴影）</li>
<li>只保存颜色信息</li>
<li>可以是linear RGB，也可也是一个Vector3</li>
<li>各个通道的数值位于0到1之间（纯白和纯黑会导致一些场景的曝光问题）</li>
</ul>
<h4 id="🏕️Metalic"><a href="#🏕️Metalic" class="headerlink" title="🏕️Metalic"></a>🏕️Metalic</h4><ul>
<li>Gray scale</li>
<li>数值在0 到 1的区间,不包含任何色彩信息</li>
<li>金属最正确的设置方式是全开或全关<ul>
<li>数值为0时，材质底色是diffuse</li>
<li>数值为1时，材质底色是specular&#x2F;reflection color</li>
<li>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metallic.png" alt="metallic"></li>
</ul>
</li>
</ul>
<h4 id="🏕️Roughness"><a href="#🏕️Roughness" class="headerlink" title="🏕️Roughness"></a>🏕️Roughness</h4><ul>
<li>Gray scale</li>
<li>数值在0 到 1的区间,不包含任何色彩信息<ul>
<li>数值为0时，无限接近于镜面反射</li>
<li>数值为1时，为粗糙表面</li>
</ul>
</li>
</ul>
<p>粗糙度是能量守恒的体现。</p>
<h4 id="🏕️Specular"><a href="#🏕️Specular" class="headerlink" title="🏕️Specular"></a>🏕️Specular</h4><ul>
<li>控制高光和反射（specular highlights and reflections）</li>
<li>Gray scale</li>
<li>一般情况下保持default value 0.5就可以了</li>
<li>通常情况下，我们通过调整Roughness来调整高光质感</li>
<li>正常世界中，所有物体都有一定程度的反射和高光效果</li>
</ul>
<p>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/roughness.png" alt="roughness"></p>
<h3 id="🚩UE支持的图片文件的格式（常用）："><a href="#🚩UE支持的图片文件的格式（常用）：" class="headerlink" title="🚩UE支持的图片文件的格式（常用）："></a>🚩UE支持的图片文件的格式（常用）：</h3><table>
<thead>
<tr>
<th>未压缩格式</th>
<th>压缩格式</th>
</tr>
</thead>
<tbody><tr>
<td>BMP</td>
<td>PNG（simple Alpha）</td>
</tr>
<tr>
<td>TGA（Alpha）</td>
<td>JPG</td>
</tr>
<tr>
<td>PSD</td>
<td>DDS</td>
</tr>
<tr>
<td></td>
<td>HDR</td>
</tr>
</tbody></table>
<ul>
<li>simple Alpha通常被用于植被</li>
</ul>
<h3 id="🚩贴图规则："><a href="#🚩贴图规则：" class="headerlink" title="🚩贴图规则："></a>🚩贴图规则：</h3><ul>
<li>最大支持8k</li>
<li>长宽必须是2的指数幂（512，1024，2048）</li>
<li>roughness，metallic，specular均不需要rgb通道，所以直接储存为gray scale导入UE。这样他们就会被自动设置成灰度图，并且不会启动sRGB或者Linear的颜色空间</li>
<li>Normal 贴图也同理，不需要使用sRGB</li>
<li>HDR 也不需要使用sRGB，因为它的取值一般会超出范围</li>
<li>sRGB只适用于颜色贴图（导入需要确保灰度图没有勾选sRGB）</li>
<li>所有的灰度贴图只要储存形式正确，那么UE会直接自动设置为禁用sRGB</li>
<li>所有的base col应当将压缩格式设置为DXT1（在贴图设置选项中，compression也可以自行更改，如果格式正确，那么UE会自动为你设置好它的compression setting）</li>
</ul>
<h3 id="🚩贴图导入方式："><a href="#🚩贴图导入方式：" class="headerlink" title="🚩贴图导入方式："></a>🚩贴图导入方式：</h3><ul>
<li>直接拖入项目</li>
<li>右键在content browser选择import Assets</li>
</ul>
<h3 id="🚩UE材质编辑器tips："><a href="#🚩UE材质编辑器tips：" class="headerlink" title="🚩UE材质编辑器tips："></a>🚩UE材质编辑器tips：</h3><ul>
<li>双击节点之间的连线，创建dot整理节点</li>
<li>c，创建comment</li>
<li>ctl+拖动节点连线来改变节点连接输出的位置</li>
<li>clean up删除此节点图中的孤立节点（unused node）</li>
<li>connector改变节点显示方式</li>
<li>T，创建texture sample</li>
</ul>
<h3 id="🚩混合模式："><a href="#🚩混合模式：" class="headerlink" title="🚩混合模式："></a>🚩混合模式：</h3><p>在Material中，可以找到<strong>Blend Mode</strong>和<strong>Shading Mode</strong>这两项，这两项十分重要</p>
<h4 id="🍭Blend-Mode："><a href="#🍭Blend-Mode：" class="headerlink" title="🍭Blend Mode："></a>🍭Blend Mode：</h4><ul>
<li><strong>Opaque 不透明</strong><ul>
<li>多数不透明材质的基本设置</li>
</ul>
</li>
<li><strong>masked 遮罩</strong><ul>
<li>显示有mask遮罩的材质</li>
<li>背面默认不显示，需要开启two sided</li>
</ul>
</li>
<li><strong>Translucent 半透明</strong><ul>
<li>通常使用在半透明材质，玻璃等有折射的材质</li>
<li>同时控制opacity与refraction来调整效果</li>
<li>Translucent一般情况下以最简单的方式计算半透明，以节约开销</li>
<li>如果想提升半透明材质的效果，需要来到Translucency的选项下，勾选Screen SPace Reflection，并把Lighting Mode改成Surface ForwardShading；这两个选项能让我们获得最高质量的半透明材质。开启这两个选项后，着色器需要更长的时间编译。</li>
</ul>
</li>
<li><strong>additive 叠加</strong></li>
<li><strong>Modulate 调制</strong></li>
<li><strong>AlphaComposite（Premultiplied Alpha） alpha复合（预乘Alpha）</strong></li>
</ul>
<p><strong>Translucent：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/blendMode_Translucent.png" alt="blendMode_Translucent"></p>
<h4 id="🍭Shading-Mode："><a href="#🍭Shading-Mode：" class="headerlink" title="🍭Shading Mode："></a>🍭Shading Mode：</h4><ul>
<li><strong>Default Lit</strong><ul>
<li>通常的光照设置，材质受光照影响</li>
</ul>
</li>
<li><strong>Unlit</strong><ul>
<li>材质不受光照影响；这种模式下允许表面产生自发光</li>
</ul>
</li>
<li><strong>subsurface</strong><ul>
<li>次表面散射，如皮肤和蜡烛</li>
</ul>
</li>
<li><strong>clear coat</strong></li>
<li><strong>two sided foliage</strong></li>
<li><strong>hair</strong></li>
<li><strong>cloth</strong></li>
<li><strong>eye</strong></li>
</ul>
<h5 id="🍌subsurface-scattering"><a href="#🍌subsurface-scattering" class="headerlink" title="🍌subsurface scattering"></a>🍌subsurface scattering</h5><ul>
<li>将Material的shading mode设置为subsurface</li>
<li>主要使用两个矢量（base color和subsurface color）和两个标量（opacity和roughness）</li>
</ul>
<p>示例：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurfaceMat.png" alt="subsurfaceMat"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurface.png" alt="subsurface"></p>
<h3 id="🚩创建一个简单材质："><a href="#🚩创建一个简单材质：" class="headerlink" title="🚩创建一个简单材质："></a>🚩创建一个简单材质：</h3><ul>
<li>当我们给mesh更换材质，或应用新材质时，需要在静态网格编辑器（Static Mesh Editor）中打开mesh，并且在右侧Detail面板下更换指定新材质</li>
<li>UE支持多材质对象。一个mesh可以有多个elements并指定材质</li>
<li>最好遵从材质命名规则，如Material最好以<strong>M_name</strong>这样以M为前缀来开头</li>
<li>T for texture sample，选择我们需要的贴图</li>
<li>基础材质创建使用的大多数是：base col， roughness， normal</li>
</ul>
<h3 id="🚩继续简单材质："><a href="#🚩继续简单材质：" class="headerlink" title="🚩继续简单材质："></a>🚩继续简单材质：</h3><ul>
<li><p>如果希望在贴图中预览并使用到UE的content，则需要再texture的选项里打开<strong>show Engine Content</strong></p>
<ul>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/showUEcontent.png" alt="showUEcontent"></li>
</ul>
</li>
<li><p><strong>反转黑白可以使用（1-x）One Minus</strong></p>
</li>
<li><p><strong>混合：Multiply（M）</strong></p>
</li>
<li><p><strong>相加：Add（A</strong>）</p>
</li>
<li><p>使用constant与贴图Multiply，以达到控制灰度的效果，或使贴图与相应选区进行混合</p>
</li>
<li><p><strong>常用噪波：perlin noise</strong></p>
</li>
<li><p><strong>线性插值：Lerp</strong></p>
<ul>
<li>利用alpha通道混合a，b两个图层</li>
</ul>
</li>
<li><p><strong>常用扁平法线：flatnormal</strong></p>
</li>
<li><p><strong>平铺纹理：Texture Coordinate</strong></p>
</li>
</ul>
<h3 id="🚩使用DataSmith从其他DCC软件导入材质到UE："><a href="#🚩使用DataSmith从其他DCC软件导入材质到UE：" class="headerlink" title="🚩使用DataSmith从其他DCC软件导入材质到UE："></a>🚩使用DataSmith从其他DCC软件导入材质到UE：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vraytoUE_datasmith.png" alt="vraytoUE_datasmith"><br>简单解释就是其他的软件制作好的材质会被以一种datasmith提供的方式转换到ue中，但是有些情况下是无法正确转换的。需要额外自行修正，并且灯光也不会被预先烘培。</p>
<hr>
<h2 id="二：创建PBR材质（基础）"><a href="#二：创建PBR材质（基础）" class="headerlink" title="二：创建PBR材质（基础）"></a>二：创建PBR材质（基础）</h2><h3 id="🚩主材质实例："><a href="#🚩主材质实例：" class="headerlink" title="🚩主材质实例："></a>🚩主材质实例：</h3><ul>
<li>实例化材质可以为我们的主材质创建副本，然后用来代替主材在项目中使用</li>
<li>实例化材质的优点：<br>  1.节约时间，可以通过公开主材质的某些参数，进一步调整实例材质而无需重新编译着色器。<br>  2.对主材质进行的改动也会更新到所有的材质实例。<br>  3.仅需要根据材质特性创建主材质，然后实例化材质应用到所有的类似材质上。</li>
</ul>
<h3 id="🚩公开材质参数："><a href="#🚩公开材质参数：" class="headerlink" title="🚩公开材质参数："></a>🚩公开材质参数：</h3><ul>
<li>右键相应节点，convert to parameter并重命名</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/convertParam.png" alt="convertParam"></li>
</ul>
<h3 id="🚩switch："><a href="#🚩switch：" class="headerlink" title="🚩switch："></a>🚩switch：</h3><ul>
<li><strong>Static Switch Parameter</strong>，静态开关参数</li>
<li>使我们开启或禁用某些功能<br><strong>示例：</strong><br>当True的时候，开启base color与纯色相乘，为False时则关闭相乘，仅显示base color<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/swichPara.png" alt="swichPara"></li>
</ul>
<h3 id="🚩实例材质的优先级以及参数最大最小值："><a href="#🚩实例材质的优先级以及参数最大最小值：" class="headerlink" title="🚩实例材质的优先级以及参数最大最小值："></a>🚩实例材质的优先级以及参数最大最小值：</h3><p><strong>当制作材质的时候，可以修改材质参数的优先级方便使用</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupandpior.png" alt="groupandpior"><br><strong>我们可以通过修改Group和sort Piriority来实现</strong></p>
<ul>
<li>只需要选中group中的“None”，将None改为我们需要的组名</li>
<li>sort Piriority为0的组会优先出现再我们的分组中，依次是1，2，3的组</li>
<li>分组需要按需求比如tex，utility，uv之类的功能不同的节点可以分开设置，并自行定义优先级</li>
</ul>
<p><strong>示例：</strong> 此时所有的参数就被归档在我们定义好的组中。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupPreview.png" alt="groupPreview"></p>
<p><strong>✏️可以给参数滑块设置最大最小值，使可以调节的范围不超过我们设定的值</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/minMax.png" alt="minMax"></p>
<h3 id="🚩动态材质："><a href="#🚩动态材质：" class="headerlink" title="🚩动态材质："></a>🚩动态材质：</h3><p><strong>材质一般在UE中分为两种：</strong></p>
<ol>
<li>静态材质</li>
<li>动态材质<ul>
<li>动态材质让我们在运行的时候实时调整</li>
</ul>
</li>
</ol>
<p><strong>Actor：</strong></p>
<ul>
<li>Actor与普通的mesh相比，它可以附加蓝图</li>
<li>我们需要在Event Graph中创建我们的功能</li>
<li>创建dynamic material，并在source Material中指定材质源</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball.png" alt="bpshaderball"></li>
<li>之后再set texture parameter value ，使用我们指定的参数Diffuse</li>
<li>再创建set scalar Parameter value， 控制Metallic</li>
<li>最后需要set vector parameter value，设置Color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball2.png" alt="bpshaderball2"></li>
<li>因为我们或许希望color不会在创建出的时候即刻执行，我们希望用户再点击屏幕对象的时候改变这个参数，所以此时还需要“事件调度器（Event Dispatchers）”来完成它</li>
<li>此时需要先创建变量，再set color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriable.png" alt="bpvriable"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriableType.png" alt="bpvriableType"></li>
<li>最后设置event Dispatchers，选择event。最后compile，此时编辑好了actor的材质。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpeventDisp2.png" alt="bpeventDisp2"></li>
</ul>
<h3 id="🚩编辑level-Blueprint："><a href="#🚩编辑level-Blueprint：" class="headerlink" title="🚩编辑level Blueprint："></a>🚩编辑level Blueprint：</h3><ul>
<li>现在要做事情使编辑关卡的蓝图，使我们之前编辑的actor生效，效果达到：点击之前编辑的actor，并使它颜色发生改变</li>
<li>进入level BP，创建get player controller，获取用户的动态，mouse cursor，click even看他是否对actor进行操作，然后再用事件调度器触发自定义事件</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven.png" alt="lbp_clickeven"></li>
<li>接着我们要判断用户是否点击到了正确的对象 ，然后再触发自定义事件，完成颜色替换的指令</li>
<li>get hit result under cursor for object，然后确认object type，使用make Array，确认我们希望用户能够点击哪类对象。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven2.png" alt="lbp_clickeven2"></li>
<li>接着left mouse button获取鼠标的动态，看右键是否点击到了正确的目标。</li>
<li>get class，class is child of，得到父类下正确的对象。如果结果是我们需要的对象，则返回True。</li>
<li>cast to ，通过这个引用我们可以访问之前用于改变颜色的自定义事件。</li>
<li>最后获取change color even，获取到我们之前定义的事件，并且设置随机颜色。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven3.png" alt="lbp_clickeven3"></li>
<li>compile，play。这样我们自定义的actor就会随着鼠标点击随机改变颜色。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven4.png" alt="lbp_clickeven4"></li>
</ul>
<h3 id="🚩材质参数集合，创建全局参数集（Parameter-Collection）："><a href="#🚩材质参数集合，创建全局参数集（Parameter-Collection）：" class="headerlink" title="🚩材质参数集合，创建全局参数集（Parameter Collection）："></a>🚩材质参数集合，创建全局参数集（Parameter Collection）：</h3><ul>
<li>有时候因为场景变化的需求，比如下雨天材质整体变得湿润，或者受到风力影响而相关材质摇曳的程度增强，或者自发光强度因为场景变化需要整体变强。</li>
<li>如果一个一个调整则很花费时间。此时就要用到材质参数集，达到批量修改整体参数的目的。</li>
<li>我们可以右键在content中创建Meterial Parameter Collection，再分别创建自己需要的全局标量和向量。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting.png" alt="mpc_setting"></li>
<li>在Master Mat中，建立collection parameter，选择之前创建的参数集，与需要修改的参数相乘。</li>
<li>如有float4的参数出现，则需要使用component Mask转换成float3，以免出现数据类型的不匹配</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting2.png" alt="mpc_setting2"></li>
<li><strong>全局参数集相当于给所有设置全局变量的参数一个总控制，每个单独的材质也可以在自己的材质球下独立调节，但是总集控制所有材质的全局参数，如果在总集禁用，那么独立的材质的那个参数也会被禁用。</strong></li>
</ul>
<h3 id="🚩材质参数集合，第二部分："><a href="#🚩材质参数集合，第二部分：" class="headerlink" title="🚩材质参数集合，第二部分："></a>🚩材质参数集合，第二部分：</h3><ul>
<li>现在想要实现：允许用户点击后，更改其中的一个全局参数</li>
<li>需要在level BluePrint里进行编辑，与Actor部分相似，前半部分判断鼠标点击以及获取用户行为的蓝图操作是一样的（在我的基础篇笔记上篇）</li>
<li>之后，判断点击对象，确保在视窗内选中正确对象然后 create reference带入蓝图</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc__bpsetting.png" alt="mpc__bpsetting"></li>
<li>选择正确的目标进行判断，并设置好rendom vector。</li>
<li>compiled，此时play就会看见随着鼠标点击，全局对象也可以随机改变颜色了。</li>
</ul>
<h3 id="🚩材质函数："><a href="#🚩材质函数：" class="headerlink" title="🚩材质函数："></a>🚩材质函数：</h3><ul>
<li>材质函数就是材质图表中可以反复使用的自定义代码片段</li>
<li>它的好处是可以把复杂的材质图表转化成拥有单个输入输出的单个材质节点</li>
<li>更改代码中的函数，所有实例也会同步修改</li>
</ul>
<h4 id="✏️此时的案例要实现的是uv-tiling。"><a href="#✏️此时的案例要实现的是uv-tiling。" class="headerlink" title="✏️此时的案例要实现的是uv tiling。"></a>✏️此时的案例要实现的是uv tiling。</h4><ul>
<li>在content中创建Material Function，点击进去。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01.png" alt="m_func01"></li>
<li>如上图，我们首先设置uv 平铺，其次设置旋转，再判断使用不使用rotation</li>
<li>编辑好后需要单击面板，开启左侧列表中的“Expose to Library”，才能确保我们后续能正常搜索到它。</li>
<li>接下来回到我们需要使用tiling的材质</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01_tiling.png" alt="m_func01_tiling"></li>
<li>搜索我们之前创建的Function，并根据我们之前设置的变量来分别连接参数</li>
<li>此时这个材质就有UV Tiling的选项。</li>
</ul>
<p><strong>数据迁移：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func_Migrate.png" alt="m_func_Migrate"></p>
<ul>
<li>此方式能够将做好的材质函数迁移到其他文件使用</li>
<li>当然也可以通过这种方式迁移别的需要的资产</li>
</ul>
<h4 id="✏️另一种材质函数的方式：CustomNode"><a href="#✏️另一种材质函数的方式：CustomNode" class="headerlink" title="✏️另一种材质函数的方式：CustomNode"></a>✏️另一种材质函数的方式：CustomNode</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customNode.png" alt="m_customNode"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN_name.png" alt="m_customN_name"></p>
<ul>
<li>这种方式通过hlsl语言来创建材质函数，得到自制的材质节点</li>
<li>设置的input name需要与code的名字匹配</li>
<li>定义hlsl并不像内置的材质表达式，且无法被优化</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN.png" alt="m_customN"></li>
</ul>
<hr>
<h2 id="三：实例创建不同的材质演示："><a href="#三：实例创建不同的材质演示：" class="headerlink" title="三：实例创建不同的材质演示："></a>三：实例创建不同的材质演示：</h2><h3 id="🚩clear-coat制作类似车漆质感："><a href="#🚩clear-coat制作类似车漆质感：" class="headerlink" title="🚩clear coat制作类似车漆质感："></a>🚩clear coat制作类似车漆质感：</h3><ul>
<li>将shading mode设置为clear coat后，Material会又clear coat和clear coat Roughness这两个选项</li>
<li>它的显示方式与普通的材质较为相似，如果希望有光滑的表面，并且希望透明图层下的表面有凹凸效果，就可以选择clear coat来模拟</li>
<li>如果要启用clear coat的第二层normal，则需要去setting中开启（默认是关闭的）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoat_enableSecNormal.png" alt="clearcoat_enableSecNormal"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/btNormal.png" alt="btNormal"></li>
<li>我们可以lerp两个scaler控制roughness，并用类似的方式控制设置表面的normal以及clear coat光滑表面下的bottom normal</li>
<li><strong>示例：</strong></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat.png" alt="clearcoatmat"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat_view.png" alt="clearcoatmat_view"></li>
</ul>
<h3 id="🚩Two-Sided-Foliage-双面植被："><a href="#🚩Two-Sided-Foliage-双面植被：" class="headerlink" title="🚩Two-Sided Foliage 双面植被："></a>🚩Two-Sided Foliage 双面植被：</h3><ul>
<li>masked这种模式需要与shading mode下双面材质（two sided foliage）设置配合使用。（如果是default lit的模式下，则没有subsurface通道）</li>
<li>这种着色方式实际上并不是半透明的，但他能很好的与蒙版混合模式搭配使用，并且借助subsurface color以更低的开销模拟半透明效果。</li>
<li>其他的材质通道设置与普通材质没有很大区别,要注意的是使用opacity mask并且需要双面显示的话，一定要勾上two sided这个选项。</li>
<li>借助wo Sided Texturing这个function可以分开控制双面材质正反两面的参数以及效果，最终的结果就是调节了subsurface以模拟光透过叶片的效果</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFunction.png" alt="twoSidedFunction"></li>
<li><strong>示例：</strong></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFoliage.png" alt="twoSidedFoliage"></li>
</ul>
<h3 id="🚩布料着色："><a href="#🚩布料着色：" class="headerlink" title="🚩布料着色："></a>🚩布料着色：</h3><blockquote>
<p><strong>小tip</strong>：如果有时候近处被裁切影响放大观察，则可以去Output Log的cmd中输入：r.SetNearClipPlane 1,将相机近景裁切更改为1</p>
</blockquote>
<ul>
<li>通常我们可以使用subsurface或者fresnel来实现布料的模拟。但是UE提供的 shading mode下就有 cloth这个选项，该着色模式使模拟布料的时候可以用于不同角度查看它的毛绒质感</li>
<li>我们创建布料材质的时候，shading mode需要选择cloth，blend mode保持opaque；此时Material中就会有Fuzz color 和cloth这两个通道。cloth通道可以借助mask指定该材质哪些部分是布料。如果是窗帘这样需要双面的材质，则也需要勾选two sided。</li>
<li>可以通过两个texture sample将布料纹理和布料图案分开设置，同理也可以将roughness和normal用一样的方式分开设置。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li>
<li>blend angle corrected normal，这个内置函数可以混合两张法线贴图</li>
<li><strong>FuzzyShading</strong>，此函数可以使用于fuzz color，它支持我们控制菲涅尔</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li>
<li>我们通过调节这些参数的组合得到不同的效果</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_display.png" alt="m_cloth_display"></li>
</ul>
<h3 id="🚩染色玻璃："><a href="#🚩染色玻璃：" class="headerlink" title="🚩染色玻璃："></a>🚩染色玻璃：</h3><p><strong>方案步骤：</strong></p>
<ol>
<li>使用顶点色，来打造有色玻璃的效果，并且玻璃的着色颜色仅显示在最厚的部分</li>
<li>使用UE中的内置函数，给玻璃表面添加磨砂或者模糊效果</li>
</ol>
<h4 id="🐢第一部分：创建基础玻璃"><a href="#🐢第一部分：创建基础玻璃" class="headerlink" title="🐢第一部分：创建基础玻璃"></a>🐢<strong>第一部分：创建基础玻璃</strong></h4><ul>
<li>创建material，使用blendMode为 Translucent，shading mode保持Default Lit。</li>
<li>随后去到Translucency的选项下，lighting Mode选择使用Surface ForwardShading或者Surface TranslucencyVolume，开启质量较高的着色选项。开启后可以发现material可以使用metallic，roughness等通道了。</li>
<li>设置一个简单的折射控制，使用fresnel作为Lerp，alpha来设置边缘到中心的折射参数。玻璃的IOR差不多设置在1.2-1.52之间。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_refraction.png" alt="m_glass_refraction"></li>
</ul>
<h4 id="🐢第二部分：加上玻璃边缘的磨砂绿色质感"><a href="#🐢第二部分：加上玻璃边缘的磨砂绿色质感" class="headerlink" title="🐢第二部分：加上玻璃边缘的磨砂绿色质感"></a>🐢<strong>第二部分：加上玻璃边缘的磨砂绿色质感</strong></h4><ul>
<li>这一部分使用Modes中的paint来绘制顶点色实现</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexCol.png" alt="m_glass_vertexCol"></li>
<li>我们仅仅需要影响桌子的边缘，再将绘制好的顶点信息导入材质，以确定哪些区域被采用并进行上色。绘制完成后记得保存此vertex color到内容浏览器中。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend.png" alt="m_glass_vertexColBlend"></li>
<li>添加使用vertex color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend2.png" alt="m_glass_vertexColBlend2"></li>
</ul>
<h4 id="🐢第三部分：使用菲涅尔改进色调真实度"><a href="#🐢第三部分：使用菲涅尔改进色调真实度" class="headerlink" title="🐢第三部分：使用菲涅尔改进色调真实度"></a>🐢<strong>第三部分：使用菲涅尔改进色调真实度</strong></h4><ul>
<li>使用Fresnel_Function，使玻璃内部和外部可以分开调节</li>
<li>使用Pixel NormalWS（像素法线世界空间）作为normal vector</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_Fresnel_Function2.png" alt="m_glass_Fresnel_Function2"></li>
<li>使用substract，设置玻璃的边缘透明度</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_edgeOpacity.png" alt="m_glass_edgeOpacity"></li>
<li>在视图窗口也可以使用Visual effect中的Planar Reflection来提升反射效果，得到更准确的反射（适用于平面，但不太适合其他有机形状）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_table.png" alt="m_glass_table"></li>
</ul>
<h4 id="🐢第四部分：设置一些磨砂效果"><a href="#🐢第四部分：设置一些磨砂效果" class="headerlink" title="🐢第四部分：设置一些磨砂效果"></a>🐢<strong>第四部分：设置一些磨砂效果</strong></h4><ul>
<li>spiralBlur-SceneTexture，我们需要用这个自带函数来控制材质的自发光颜色，并需要与Opacity的边缘控制也关联</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur.png" alt="m_glass_spirlblur"></li>
<li>现在我们需要反转之前绘制的vertex color再与spiralBlur相乘，来连接自发光颜色</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur_emmisive.png" alt="m_glass_spirlblur_emmisive"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_frosted.png" alt="m_glass_frosted"></li>
<li>切记多调整参数来得到满意的效果</li>
</ul>
<h3 id="🚩置换贴图，模拟毛毯地毯一类："><a href="#🚩置换贴图，模拟毛毯地毯一类：" class="headerlink" title="🚩置换贴图，模拟毛毯地毯一类："></a>🚩置换贴图，模拟毛毯地毯一类：</h3><blockquote>
<p><strong>发布支持DX11显卡时，引入了一项全新的硬件功能：real-time Dynamic Tessellation Geometry。使我们能够使用置换纹理贴图在显卡上增加对象的多边形面数，由此显著提升了对象的物理细节而无需真正对此细节进行建模。</strong></p>
</blockquote>
<ul>
<li>创建materail的时候，需要先开启细分。去Tessellation的选项下，D3D11Tesselation中选择Flat Tesselation。还要勾选Crack Free Displacement，保留Adaptive Tessellation。</li>
<li>此时Material中有新增了两个通道：<ul>
<li>World Displacement（用于连接displacement Map）</li>
<li>Tessellation Multiplier（控制有多少polygon总数添加到对象，数量越大，置换效果越详细，但一般不建议开的很高）</li>
</ul>
</li>
<li>一般情况下，displacement map使用普通灰度图即可。</li>
<li>如果在displacement的数值很高的情况下，导致边缘会产生与主体分离的效果，可以使用绘制vertex color来绘制边缘的部分，让边缘的部分不受tessellation的影响来解决这一问题。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220917204344.png" alt="paintEdges"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_displacement.png" alt="m_displacement"></li>
<li>使用置换贴图必须先确保基础模型的网格数不会太低。</li>
<li>置换贴图也会对性能产生影响，所以要谨慎使用。</li>
</ul>
<h3 id="🚩顶点动画，创建窗帘随风吹动的效果："><a href="#🚩顶点动画，创建窗帘随风吹动的效果：" class="headerlink" title="🚩顶点动画，创建窗帘随风吹动的效果："></a>🚩顶点动画，创建窗帘随风吹动的效果：</h3><ul>
<li>了解“世界场景位置偏移”（World Position offset）</li>
<li>使用基本的material的设置创建布料材质作为基础，并使用World Position offset来创建窗帘的顶点动画</li>
<li>使用panner来加入动画，使用vertex color绘制需要动画的部分，并加入材质控制</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph1.png" alt="m_vertexAni_graph1"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph2.png" alt="m_vertexAni_graph2"></li>
<li>需要将这个模型对象设置为movable来获得正确的光照和阴影显示</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni.png" alt="m_vertexAni"></li>
</ul>
<hr>
<p>终于刷完了！受益匪浅！</p>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-材质</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇图片测试</title>
    <url>/2025/02/07/%E6%B5%8B%E8%AF%95%E4%BA%8C/</url>
    <content><![CDATA[<blockquote>
<p>🍺这是一个测试，看看图片在云上是否还能正确保存<br>(这是来自2025年的检查。。。太久没上了看看是否上传内容有任何错误)</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20250208153740.png" alt="20250208153740"></p>
]]></content>
  </entry>
  <entry>
    <title>SD贴纸翻折效果复现</title>
    <url>/2023/04/23/sd_stickerRoll/</url>
    <content><![CDATA[<h1 id="SD贴纸翻折效果复现"><a href="#SD贴纸翻折效果复现" class="headerlink" title="SD贴纸翻折效果复现"></a><center>SD贴纸翻折效果复现</center></h1><h3 id="实现贴纸或者叶片一类的效果"><a href="#实现贴纸或者叶片一类的效果" class="headerlink" title="实现贴纸或者叶片一类的效果"></a><center>实现贴纸或者叶片一类的效果</center></h3><ul>
<li>先看视频链接：

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=994290041&bvid=BV1Bs4y1D7AZ&cid=1075703165&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

</li>
</ul>
<h2 id="图片示意"><a href="#图片示意" class="headerlink" title="图片示意"></a>图片示意</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/sdTOP12_1.png" alt="sdTOP12_1"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_02.png" alt="st_02"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_03.png" alt="st_03"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/st_04.png" alt="st_04"></p>
<h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2023423-195718.png" alt="2023423-195718"></p>
<ul>
<li>参考哔哩哔哩大佬的方案：<strong>程序化螺丝钉</strong></li>
<li>主要是通过旋转角度配合位移矩阵，再配合value processsor对offset的数值进行同步处理，然后将遮罩的部分反转，将offset变换后再挪回去<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423200345.png" alt="20230423200345"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423200412.png" alt="20230423200412"></li>
<li>翻折的部分实际上是x到-x的变换，过渡是一个白到黑的gradient mask做出视觉上的凸起。</li>
<li>总体的过程只是一个视觉上的trick，还是挺奇妙的。</li>
<li>参数也很简单，就是翻折角度（起始点）；以及剥落的距离（offset）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423201208.png" alt="20230423201208"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20230423201225.png" alt="20230423201225"></li>
</ul>
<h2 id="之后对于此类效果的改进计划："><a href="#之后对于此类效果的改进计划：" class="headerlink" title="之后对于此类效果的改进计划："></a>之后对于此类效果的改进计划：</h2><ul>
<li>之后会完成对于position的改进，由滑杆的处理方式变为position定位点。</li>
<li>其次准备实现卷曲效果，像是树叶枯萎后卷起来的样子的程序化处理</li>
</ul>
]]></content>
      <categories>
        <category>-Substance Designer</category>
      </categories>
      <tags>
        <tag>-Substance Designer</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4_虚幻引擎材质节点以及蓝图的学习</title>
    <url>/2022/10/14/ue_WTF_is_Material_all/</url>
    <content><![CDATA[<h1 id="UE4-虚幻引擎材质节点以及蓝图的学习"><a href="#UE4-虚幻引擎材质节点以及蓝图的学习" class="headerlink" title="UE4_虚幻引擎材质节点以及蓝图的学习"></a>UE4_虚幻引擎材质节点以及蓝图的学习</h1><blockquote>
<p>🍉本笔记是我的UE材质节点学习笔记，随手写一下，我是菜鸡的水平，如果很厉害的大佬就可以跳过了哈！如有错误请及时指正！<br>🤩学习主要来自WTF is Material的章节，也就是来自Mathew Wadstein的tutorials~~~ 请有兴趣就去关注原作者！<br>🍅还有一些杂七杂八的从各种地方学的我应该会一同写在一起了，大部分也去ue的document查了一圈，拿了一些示例。我正在学习ue的路上，这个系列应该会持续更，有兴趣的想要一起学习的也可以关注我的更新！</p>
</blockquote>
<hr>
<h2 id="✏️材质节点键盘快捷键不全的大全："><a href="#✏️材质节点键盘快捷键不全的大全：" class="headerlink" title="✏️材质节点键盘快捷键不全的大全："></a>✏️材质节点键盘快捷键不全的大全：</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>Node Name</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>constant</td>
<td>一维向量</td>
</tr>
<tr>
<td>2</td>
<td>constant2Vector</td>
<td>二维向量</td>
</tr>
<tr>
<td>3</td>
<td>constant3Vector</td>
<td>三维向量</td>
</tr>
<tr>
<td>4</td>
<td>constant4Vector</td>
<td>四维向量</td>
</tr>
<tr>
<td>A</td>
<td>Add</td>
<td>加法</td>
</tr>
<tr>
<td>M</td>
<td>multiply</td>
<td>混合，乘法</td>
</tr>
<tr>
<td>D</td>
<td>divide</td>
<td>除法</td>
</tr>
<tr>
<td>T</td>
<td>TextureSample</td>
<td>纹理贴图</td>
</tr>
<tr>
<td>P</td>
<td>Panner</td>
<td>坐标平移</td>
</tr>
<tr>
<td>U</td>
<td>TextureCoordinate</td>
<td>纹理坐标</td>
</tr>
<tr>
<td>L</td>
<td>Lerp</td>
<td>插值函数</td>
</tr>
<tr>
<td>I</td>
<td>if</td>
<td>参数判断</td>
</tr>
<tr>
<td>C</td>
<td>comment</td>
<td>备注说明</td>
</tr>
<tr>
<td>B</td>
<td>BumpOffset</td>
<td>视差贴图</td>
</tr>
<tr>
<td>N</td>
<td>Normalize</td>
<td>归一化函数</td>
</tr>
<tr>
<td>E</td>
<td>power</td>
<td>幂</td>
</tr>
<tr>
<td>O</td>
<td>one-minus</td>
<td>反向，反向颜色</td>
</tr>
</tbody></table>
<hr>
<h2 id="✏️官方操作快捷键："><a href="#✏️官方操作快捷键：" class="headerlink" title="✏️官方操作快捷键："></a>✏️官方操作快捷键：</h2><ul>
<li>图来自网络<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/hotKey_ue.png" alt="hotKey_ue"></li>
</ul>
<hr>
<h2 id="✏️Actor-Position-WS（vectors）"><a href="#✏️Actor-Position-WS（vectors）" class="headerlink" title="✏️Actor Position WS（vectors）"></a>✏️Actor Position WS（vectors）</h2><h3 id="🍏【ActorPosition】："><a href="#🍏【ActorPosition】：" class="headerlink" title="🍏【ActorPosition】："></a>🍏【ActorPosition】：</h3><blockquote>
<p>对象坐标值，输出的是vector3，指这个actor在世界空间中的位置（已经赋予此材质的对象）。它的整体变化是以actor的坐标为基准。</p>
</blockquote>
<ul>
<li>下图是<strong>actorPosition</strong>的示例，图来自于YakSue的CSDN博客，<a href="https://yaksue.blog.csdn.net/article/details/110431700?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110431700-blog-104868601.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110431700-blog-104868601.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1">链接在此</a>。（如侵权请联系删除）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/actorPosition.gif" alt="actorPosition"></li>
</ul>
<h3 id="🍏【Object-Position】："><a href="#🍏【Object-Position】：" class="headerlink" title="🍏【Object Position】："></a>🍏【Object Position】：</h3><blockquote>
<p>与他比较相似的是 Object Position，输出对象bound的世界场景空间<strong>中心</strong>位置。它的变化则是以整体中心为基准。</p>
</blockquote>
<ul>
<li>下图是<strong>Object Position</strong>的示例，图来自于YakSue的CSDN博客。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/objectPosition.gif" alt="objectPosition"></li>
</ul>
<h3 id="🍏【Absolute-World-Position】："><a href="#🍏【Absolute-World-Position】：" class="headerlink" title="🍏【Absolute World Position】："></a>🍏【Absolute World Position】：</h3><blockquote>
<p>Absolute World Position，表示在全局空间中的位置。</p>
</blockquote>
<ul>
<li>下图是<strong>Absolute World Position</strong>的示例，图来自于YakSue的CSDN博客。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/AbsoluteWorldPosition.gif" alt="AbsoluteWorldPosition"></li>
</ul>
<hr>
<h2 id="✏️Add（math）"><a href="#✏️Add（math）" class="headerlink" title="✏️Add（math）"></a>✏️Add（math）</h2><blockquote>
<p>加法，常用于颜色亮暗的调节，或者使用于offset。 </p>
</blockquote>
<ul>
<li>他所做的事情和数学一样，就是获取两个input并把他们values相加。如果使用多个通道传递，则每个通道分别相加。- 两个input的如果是多通道，那么通道必须数量相同；但是如给其中一个是单值常量则例外，单值浮点会与多通道每个通道相加并输出。</li>
</ul>
<hr>
<h2 id="✏️AppendVector（math）"><a href="#✏️AppendVector（math）" class="headerlink" title="✏️AppendVector（math）"></a>✏️AppendVector（math）</h2><blockquote>
<p>二维加法，将一个值加入（插入）到另一个值后端。允许你组合通道，比如你有一个二维向量，你可以通过append加入第三个向量。</p>
</blockquote>
<ul>
<li>要注意它和add是完全不同的，它并不是数值上的相加。</li>
</ul>
<hr>
<h2 id="✏️Abs（math）"><a href="#✏️Abs（math）" class="headerlink" title="✏️Abs（math）"></a>✏️Abs（math）</h2><blockquote>
<p>absolute value，绝对值；它没有参数，但是涵盖一个很简单的函数。这个函数是取input的绝对值。这意味着它通过去掉负号把负数变成正数，而正数和零保持不变</p>
</blockquote>
<ul>
<li>这个函数意味着它的output是没有负数的，大多数情况下使用于不想取到负值的情况下，将output的区间钳制在正数区间。</li>
<li>一般配合点积使用，确定两个向量之间的角度关系，计算它是平行，垂直，还是介于两者之间。通常，当您得到两个向量的点积时，该值在1.0（对于两个平行向量）与-1.0（对于两个完全相反的向量）之间进行插值，中间点0表示这两个向量是垂直的。当您取这个点积的绝对值时，正值保持不变，而负值通过去掉负号变成正数。因此，结果在0（对于垂直向量）和1.0（对于平行向量，无论向量指向相同还是相反的方向）之间进行插值。这只是告诉您这两个向量距离正交有多远。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/abs.jpg" alt="abs"></li>
</ul>
<hr>
<h2 id="✏️BlackBody（utility）"><a href="#✏️BlackBody（utility）" class="headerlink" title="✏️BlackBody（utility）"></a>✏️BlackBody（utility）</h2><blockquote>
<p>黑体，用来在材质中模拟黑体辐射，运用开尔文温度，产生颜色和轻度来驱动basecolor和emissive，获得物理上准确的结果</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/BlackBody.jpg" alt="BlackBody"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%BC%80%E5%B0%94%E6%96%87%E9%A2%9C%E8%89%B2.png" alt="开尔文颜色"></p>
<hr>
<h2 id="✏️BumpOffset（function）"><a href="#✏️BumpOffset（function）" class="headerlink" title="✏️BumpOffset（function）"></a>✏️BumpOffset（function）</h2><blockquote>
<p>高度视差，就是所谓的视差贴图。凹凸贴图偏移表达式可以使材质产生深度错觉，而不需要额外的几何体。凹凸贴图偏移材质使用灰阶高度贴图来提供深度信息。</p>
</blockquote>
<ul>
<li>它有三个input：<ul>
<li>coordinate</li>
<li>height（一般情况下这个通道是必须的，需要一张灰度图，越黑代表距离越远，越白距离越近。）</li>
<li>heightRatioInput（这个建议较小的数值，否则扭曲和拉伸会较为严重）</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/BumpOffset.png" alt="BumpOffset"></p>
<hr>
<h2 id="✏️Camera-Position-WS（vectors）"><a href="#✏️Camera-Position-WS（vectors）" class="headerlink" title="✏️Camera Position WS（vectors）"></a>✏️Camera Position WS（vectors）</h2><blockquote>
<p>相机坐标值，会输出一个三通道向量值，该值表示摄像机在世界场景空间中的位置.</p>
</blockquote>
<ul>
<li>看如下案例，相机位置如果高于物体位置，呈现白色；如果低于物体位置，呈现黑色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cameraPosition.png" alt="cameraPosition"></li>
</ul>
<hr>
<h2 id="✏️Clamp（math）"><a href="#✏️Clamp（math）" class="headerlink" title="✏️Clamp（math）"></a>✏️Clamp（math）</h2><blockquote>
<p>范围限定；接受一个或多个值，并将它们约束到由最小值和最大值定义的指定范围内。如果最小值为0.0，最大值为0.5，则意味着结果值永远不会小于0.0，且永远不会大于0.5。</p>
</blockquote>
<ul>
<li>有三个input<ul>
<li>clamp mode（可以设定只有 max或只有 min）</li>
<li>Min Default</li>
<li>Max Default</li>
</ul>
</li>
<li>它保证数值不会大于你自定义的max，也不会小于你自定义的min。</li>
</ul>
<hr>
<h2 id="✏️Component-Mask（math）"><a href="#✏️Component-Mask（math）" class="headerlink" title="✏️Component Mask（math）"></a>✏️Component Mask（math）</h2><blockquote>
<p>相当于参数提取，它允许你从输入中挑选某个通道子集（R、G、B和&#x2F;或A）并输出。</p>
</blockquote>
<ul>
<li>下图示例： 如果ComponentMask的输入是(0.2,0.4,1.0)和G通道，输出将是(0.4)。如果是颜色向量，最终效果就是一个40%的明亮灰度值。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ComponentMaskExample.jpg" alt="ComponentMaskExample"></li>
</ul>
<hr>
<h2 id="✏️Constant-Bias-Scale（math）"><a href="#✏️Constant-Bias-Scale（math）" class="headerlink" title="✏️Constant Bias Scale（math）"></a>✏️Constant Bias Scale（math）</h2><blockquote>
<p>允许你按比例调整参数，它有两个参数，运算规则是：先加bias的数值，后与scale数值相乘。</p>
</blockquote>
<hr>
<h2 id="✏️Constant类型（constant）"><a href="#✏️Constant类型（constant）" class="headerlink" title="✏️Constant类型（constant）"></a>✏️Constant类型（constant）</h2><blockquote>
<p>constant实际上有一堆，分别是constant，constant2vector，constant3vector，constant4vector，他们都输出常量，只是通道数量不一样。他们按通道的个数分别是输出RGBA或者XYZW。</p>
</blockquote>
<hr>
<h2 id="✏️Cross-Product（math）"><a href="#✏️Cross-Product（math）" class="headerlink" title="✏️Cross Product（math）"></a>✏️Cross Product（math）</h2><blockquote>
<p>叉积，计算两个三通道向量值输入的交叉乘积，并输出产生的三通道向量值。假定空间中有两个向量，则交叉乘积是一个同时垂直于两个输入的向量。计算方式与数学上面的叉积没有区别。</p>
</blockquote>
<ul>
<li>CrossProduct常用于计算垂直于另外两个方向的方向。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cross-product.jpg" alt="cross-product"></li>
</ul>
<hr>
<h2 id="✏️Custom-Rotator（texturing）"><a href="#✏️Custom-Rotator（texturing）" class="headerlink" title="✏️Custom Rotator（texturing）"></a>✏️Custom Rotator（texturing）</h2><blockquote>
<p>自定义旋转，它会提供一个center，然后你可以实际运用这个center去定义不同的点，来进行旋转。</p>
</blockquote>
<ul>
<li>它有三个input<ul>
<li>UVs </li>
<li>Rotation Center（这实际就是设置中心的地方）</li>
<li>Roataton Angle（0-1的区间，360度）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="✏️Depth-Fade（texturing）"><a href="#✏️Depth-Fade（texturing）" class="headerlink" title="✏️Depth Fade（texturing）"></a>✏️Depth Fade（texturing）</h2><blockquote>
<p>深度消退，用来隐藏半透明对象与不透明对象相交时出现的不美观接缝，起到柔化边缘相交处的接缝的作用。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/depthFade.png" alt="depthFade"></p>
<ul>
<li>注意选择合适的fade distance。</li>
<li>depth fade在制作地形，植被时候可以用来改善相交处的接缝。</li>
</ul>
<hr>
<h2 id="✏️Depth-of-Field-Funtion（Utility）"><a href="#✏️Depth-of-Field-Funtion（Utility）" class="headerlink" title="✏️Depth of Field Funtion（Utility）"></a>✏️Depth of Field Funtion（Utility）</h2><blockquote>
<p>景深运算，根据景深设置你所要取的区间。</p>
</blockquote>
<ul>
<li>0代表in focus；1代表out of focus</li>
<li>可以使用它作为on 和 off；比如距离近的时候使用高分辨率的贴图之类的，使用dof function来判断是不是in focus。</li>
</ul>
<hr>
<h2 id="✏️Desaturation（color）"><a href="#✏️Desaturation（color）" class="headerlink" title="✏️Desaturation（color）"></a>✏️Desaturation（color）</h2><blockquote>
<p>去饱和度，对input进行饱和度去除，即根据特定百分比将其输入的颜色转换为灰色阴影</p>
</blockquote>
<ul>
<li>它有两个input<ul>
<li>Luminance Factors（指定每个通道对去饱和度颜色的影响量。此属性确保在去饱和度之后，绿色比红色亮，而红色比蓝色亮。）</li>
<li>Fraction （指定要应用于输入的去饱和度数量。此百分比的范围是0.0（完全原始颜色，不去饱和度）到1.0（完全去饱和度）。）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="✏️Diamond-Gradient（miscellaneous）"><a href="#✏️Diamond-Gradient（miscellaneous）" class="headerlink" title="✏️Diamond Gradient（miscellaneous）"></a>✏️Diamond Gradient（miscellaneous）</h2><blockquote>
<p>钻石型渐变图案。可以通过调整fall off 得到不同程度的衰减效果。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/diamondGradient.png" alt="diamondGradient"></p>
<hr>
<h2 id="✏️Distance（math）"><a href="#✏️Distance（math）" class="headerlink" title="✏️Distance（math）"></a>✏️Distance（math）</h2><blockquote>
<p>距离计算，计算两个点&#x2F;颜色&#x2F;位置&#x2F;矢量之间的欧氏距离，并输出结果值。此表达式可作用于单分量、双分量、三分量和四分量矢量，但此表达式的两个输入必须具有相同数目的通道。</p>
</blockquote>
<ul>
<li>可以理解为：Result &#x3D; length (A - B)<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/DistanceExample.jpg" alt="DistanceExample"></li>
</ul>
<hr>
<h2 id="✏️Divide（math）"><a href="#✏️Divide（math）" class="headerlink" title="✏️Divide（math）"></a>✏️Divide（math）</h2><blockquote>
<p>除法，取两个输入，将第一个输入除以第二个输入，并输出值。</p>
</blockquote>
<ul>
<li>两个输入必须有相同数量的值，但其中一个值是单个浮点值时例外。在这种情况下，将多通道输入的每个通道除以单个浮点值，并将结果存储在输出值的单独通道中。</li>
<li>如果使用多个通道传递值，每个通道将单独相除。</li>
<li>如果除数在任何通道内都介于0和0.00001之间，则将其提升至0.00001。如果除数在任何通道内都介于0和-0.00001之间，则将其降低至-0.00001。这避免了出现除以零的错误可能性。但是，这也意味着通道的输出值可能非常大。</li>
</ul>
<hr>
<h2 id="✏️Dot-Product（math）"><a href="#✏️Dot-Product（math）" class="headerlink" title="✏️Dot Product（math）"></a>✏️Dot Product（math）</h2><blockquote>
<p>点积，点积可以描述为一个向量投影到另一个向量上的长度，也可以描述为两个向量之间的余弦乘以它们的幅值。许多技术使用这种算法来计算衰减。DotProduct要求两个向量输入具有相同数量的通道。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/dot-product.jpg" alt="dot-product"></p>
<hr>
<h2 id="✏️Feature-Level-Switch（math）"><a href="#✏️Feature-Level-Switch（math）" class="headerlink" title="✏️Feature Level Switch（math）"></a>✏️Feature Level Switch（math）</h2><blockquote>
<p>特征等级切换，此节点允许你你使用相同的材质，但是可以基于不同的shader level去显示不同的东西，多用于设置材质用于不同设备时。</p>
</blockquote>
<ul>
<li>举个例子来看，如下图，我们的preview Rendering Level是不同的；这个材质节点的作用就是当你有这样一些feature level的时候，它的inputs提供的选项允许你去自行设置先要输出的内容，如果它没有特殊被设置，那就会自行使用default。</li>
<li>他必须使用一个default，否则无法工作。</li>
<li>你可以通过此设置更轻量的东西去到移动端设备。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FeatureLevelSwitch.png" alt="FeatureLevelSwitch"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FeatureLevelSwitch_02.png" alt="FeatureLevelSwitch_02"></li>
</ul>
<hr>
<h2 id="✏️Floor-and-Ceil（math）"><a href="#✏️Floor-and-Ceil（math）" class="headerlink" title="✏️Floor and Ceil（math）"></a>✏️Floor and Ceil（math）</h2><blockquote>
<p><strong>Floor</strong>，舍去小数部分，<strong>向下取整</strong>。比如0.2向下舍入取整就是0.0；(0.2,1.6)向下舍入到(0.0, 1.0)。 </p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/floor.jpg" alt="floor"></p>
<blockquote>
<p><strong>Ceil</strong>，舍去小数部分，<strong>向上取整</strong>。比如0.2向上舍入取整就是1.0；(0.2,1.6)向上舍入到(1.0,2.0)。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ceil.jpg" alt="ceil"></p>
<ul>
<li>这两个节点可以理解为做相同的事情，但是结果相反，就像min和max一样。</li>
<li>他们的名字也可以看出floor是向下，ceil则是向上。</li>
</ul>
<hr>
<h2 id="✏️FMod（math）"><a href="#✏️FMod（math）" class="headerlink" title="✏️FMod（math）"></a>✏️FMod（math）</h2><blockquote>
<p>除不尽的取取余数。也就是返回两个input的除法运算的浮点余数，第一个input可以是任何数，第二个input通常不为0（被除数不为0）</p>
</blockquote>
<ul>
<li>它的常见的用例是制作一种材质，使其亮度上升到最大值，然后在下一帧中立即下降到最小值，然后再次开始向最大值攀升。</li>
<li>如下图示例，FMod采用0到1的UV级数，并将其转换为绿色通道中X轴上每0.2个UV单元一次的重复循环。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FmodExample.jpg" alt="FmodExample"></li>
</ul>
<hr>
<h2 id="✏️Frac（math）"><a href="#✏️Frac（math）" class="headerlink" title="✏️Frac（math）"></a>✏️Frac（math）</h2><blockquote>
<p>fractional，取小数；输入input，此节点返回input的小数部分。输出值将从0到1不等。</p>
</blockquote>
<ul>
<li>举例来说：(0.2)的小数部分是(0.2)。(-0.2)的小数部分是(0.8)。(0.0,1.6,1.0)的小数部分是(0.0,0.6,0.0)。</li>
<li>如下图示例，Frac节点将时间转换为一系列重复的0 - 1级数序列，导致颜色（通过Lerp）从绿色变为红色，然后返回绿色，无限重复。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/frac.jpg" alt="frac"></li>
</ul>
<hr>
<h2 id="✏️Fresnel（utility）"><a href="#✏️Fresnel（utility）" class="headerlink" title="✏️Fresnel（utility）"></a>✏️Fresnel（utility）</h2><blockquote>
<p>菲涅尔，根据表面法线与摄像机方向的标量积来计算衰减。当表面法线正对着摄像机时，输出值为0。当表面法线垂直于摄像机时，输出值为1。结果限制在[0,1]范围内，以确保不会在中央产生任何负颜色。</p>
</blockquote>
<ul>
<li>它有两个属性：<ul>
<li><strong>Exponent</strong>（指定输出值的衰减速度。值越大，意味着衰减越紧或越快。）</li>
<li><strong>Base Reflect Fraction</strong>（指定从正对表面的方向查看表面时，镜面反射的小数。值为1将有效地禁用菲涅耳效果。）</li>
</ul>
</li>
<li>它有三个inputs：<ul>
<li><strong>ExponentIn</strong> （指定输出值的衰减速度。如果使用此输入，那么值将始终取代”指数”（Exponent）属性值。）</li>
<li><strong>Base Reflect Fraction</strong>（如果使用此输入，那么值将始终取代”指数”（Exponent）属性值。）</li>
<li><strong>Normal</strong>（该值代表表面在全局空间中的法线。要查看应用于菲涅耳对象表面的法线贴图的结果，请将该法线贴图连接到材质的”法线”（Normal）输入，然后连接一个PixelNormalWS 表达式到Fresnel上的此输入。如果未指定任何法线，那么将使用网格的切线法线。）</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/FresnelExample.jpg" alt="FresnelExample"></p>
<hr>
<h2 id="✏️Generated-Band（miscellaneous）"><a href="#✏️Generated-Band（miscellaneous）" class="headerlink" title="✏️Generated Band（miscellaneous）"></a>✏️Generated Band（miscellaneous）</h2><blockquote>
<p> 条形图案；允许我们生成一个条状的图案，可以调整宽度，锐度（可以为负），偏移，方向（横向纵向）等等。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedBand.png" alt="GeneratedBand"></p>
<hr>
<h2 id="✏️Generated-Offest-Bands（miscellaneous）"><a href="#✏️Generated-Offest-Bands（miscellaneous）" class="headerlink" title="✏️Generated Offest Bands（miscellaneous）"></a>✏️Generated Offest Bands（miscellaneous）</h2><blockquote>
<p>局部重复条形图案，参数使用与Generated Band几乎无差别，但有一个叫做band的额外参数；这使我们得到一对band（实际上在band这个参数为1,其他参数保持默认的时候，我们得到的是两对白色的band），而不是单个band。</p>
</blockquote>
<ul>
<li>此时compare参数可以调整band之间的间距，为0时两两之间互相成对的band的间距最远，为1时最近。</li>
<li>详细看图对比。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedOffsetBand.png" alt="GeneratedOffsetBand"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GeneratedOffsetBand%E5%AF%B9%E6%AF%94GeneratedBand.png" alt="GeneratedOffsetBand对比GeneratedBand"></li>
</ul>
<hr>
<h2 id="✏️GIReplace（utility）"><a href="#✏️GIReplace（utility）" class="headerlink" title="✏️GIReplace（utility）"></a>✏️GIReplace（utility）</h2><blockquote>
<p>全局光照替换；这个节点可以为材质提供在全局照明下产生不同间接反射效果的方式。它允许指定一个定值来取代间接反射颜色。</p>
</blockquote>
<ul>
<li>它有三个inputs：<ul>
<li>Default</li>
<li>StaticIndirect</li>
<li>DynamicIndirect</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/GIreplace.png" alt="GIreplace"></p>
<hr>
<h2 id="✏️If（math）"><a href="#✏️If（math）" class="headerlink" title="✏️If（math）"></a>✏️If（math）</h2><blockquote>
<p>判断；比较两个输入，然后根据比较的结果传递其他三个输入值中的一个。两个比较的输入都必须是单一浮点值。</p>
</blockquote>
<ul>
<li>如下图示例，if接受一个高度图，并根据高度是低于还是高于0.2的值来输出红色或绿色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/IfExample.jpg" alt="IfExample"></li>
</ul>
<hr>
<h2 id="✏️Interface-Previewing-Property（材质details）"><a href="#✏️Interface-Previewing-Property（材质details）" class="headerlink" title="✏️Interface Previewing Property（材质details）"></a>✏️Interface Previewing Property（材质details）</h2><blockquote>
<p>修改预览网络，可以自定义材质节点编辑器中的预览mesh。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/InterfacePreviewingProperty_01.png" alt="InterfacePreviewingProperty_01"></p>
<hr>
<h2 id="✏️Lightmess-Property（材质details）"><a href="#✏️Lightmess-Property（材质details）" class="headerlink" title="✏️Lightmess Property（材质details）"></a>✏️Lightmess Property（材质details）</h2><blockquote>
<p>Lightmess，你可以理解为它是static light system。它创建具有复杂光交互作用的光照图，例如区域阴影和漫反射。它用于预计算<strong>具有固定和静态运动性的光源的照明贡献部分。</strong></p>
</blockquote>
<ul>
<li>你可以使用 cast shadow as masked或不使用它；它们的效果不同。</li>
<li>如下图所示，左边是不勾选cast shadow as masked，阴影为绿色；右边是勾选此属性，半透明物体会使用遮罩，阴影为黑色，使它得到清晰的阴影以及轮廓；<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessProperty.png" alt="LightmessProperty"></li>
<li><strong>diffuse boost</strong>，材质漫反射<strong>对静态光照影响量</strong>的增加和提升，更高的数值会更清晰明亮。（<strong>记住是static lighting的情况</strong>，而不是realtime，所有的光照都经过bake。）</li>
<li><strong>Export Resolution Scale</strong>，导出该材质属性时的分辨率乘数。<strong>在需要详细信息时应增大此数值</strong>（计算时间也会增加）。</li>
</ul>
<hr>
<h2 id="✏️Lightmess-Replace（utility）"><a href="#✏️Lightmess-Replace（utility）" class="headerlink" title="✏️Lightmess Replace（utility）"></a>✏️Lightmess Replace（utility）</h2><blockquote>
<p>光照系统替换, 有两个inputs，来确定使用realtime（接收要传递以用于正常渲染的值）和使用lightmass（接收在导出材质到光照系统时要传递的值）时的输出效果。它可以避免使用导出版本无法正确处理的材质表达式，例如WorldPosition。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessReplace.png" alt="LightmessReplace"></p>
<ul>
<li>下图示例设置lightmass的情况<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LightmessReplace_lightmass.png" alt="LightmessReplace_lightmass"></li>
</ul>
<hr>
<h2 id="✏️Linear-Gradient（Gradient）"><a href="#✏️Linear-Gradient（Gradient）" class="headerlink" title="✏️Linear Gradient（Gradient）"></a>✏️Linear Gradient（Gradient）</h2><blockquote>
<p>线性渐变；函数使用 UV 通道 0 在 U 或 V 方向上产生线性渐变，其中，方向取决于所使用的输出。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LinearGradient.png" alt="LinearGradient"></p>
<hr>
<h2 id="✏️Linear-Interpolate（utility）"><a href="#✏️Linear-Interpolate（utility）" class="headerlink" title="✏️Linear Interpolate（utility）"></a>✏️Linear Interpolate（utility）</h2><blockquote>
<p><strong>就是Lerp</strong>，线性插值；用作蒙版的第三个输入值，在两个输入值之间进行混合；蒙版Alpha（相当于a与b之间的mask）的强度确定从两个输入值获取颜色的比例。</p>
</blockquote>
<ul>
<li>如果Alpha为0.0色，那么将使用第一个输入。如果Alpha为1.0，那么将使用第二个输入。如果Alpha介于0.0与1.0之间，那么输出是两个输入之间的混合。</li>
<li>请记住，混合按通道进行。因此，如果Alpha为RGB颜色，那么Alpha的红色通道值定义A与B的红色通道之间的混合，而与Alpha的绿色通道 无关，该通道定义A与B的绿色通道之间的混合。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/LerpExample.jpg" alt="LerpExample"></li>
</ul>
<hr>
<h2 id="✏️Min-and-Max（math）"><a href="#✏️Min-and-Max（math）" class="headerlink" title="✏️Min and Max（math）"></a>✏️Min and Max（math）</h2><blockquote>
<p>Max ，最大值；有两个输入，输出其中较大的一个。结果类似于Photoshop中的 变亮 图层混合模式。<br>Min ， 最小值；有两个输入，输出其中较小的一个。结果类似于Photoshop中的 变暗 图层混合模式。</p>
</blockquote>
<hr>
<h2 id="✏️Mobile-Property（材质属性界面，details）"><a href="#✏️Mobile-Property（材质属性界面，details）" class="headerlink" title="✏️Mobile Property（材质属性界面，details）"></a>✏️Mobile Property（材质属性界面，details）</h2><blockquote>
<p>移动平台；多用于节约性能以便于移动端使用</p>
</blockquote>
<ul>
<li><strong>Use Full Precision</strong> ，强制此材质在像素着色器中使用全（highp）精度。它的处理速度比默认设置（mediump）慢，但可用于解决与精度相关的渲染错误。此设置对不支持高精度的旧版移动设备无效。</li>
<li><strong>Use Lightmap Directionality</strong>，此属性将使用光照图方向性和逐像素法线。如果禁用此属性，光照图中的光照将是平面的，但开销更低。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/MobileProperty.png" alt="MobileProperty"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/MobileProperty_02.png" alt="MobileProperty_02"></li>
<li>（左侧Fully Rough off，Use Lightmap Directionality on。右侧效果Fully Rough on，Use Lightmap Directionality off）</li>
</ul>
<hr>
<h2 id="✏️Multiply（math）"><a href="#✏️Multiply（math）" class="headerlink" title="✏️Multiply（math）"></a>✏️Multiply（math）</h2><blockquote>
<p>乘法；数学计算的相乘。作为叠加来使用结果类似于Photoshop中的 正片叠底 图层混合模式的结果。</p>
</blockquote>
<ul>
<li>两个输入必须有相同数量的值，但其中一个值是单个浮点值时例外。在这种情况下，将多通道输入的每个通道乘以单个浮点值，并将结果存储在输出值的单独通道中。</li>
<li>E4中的材质不限于[0,1]。如果颜色&#x2F;值大于1，Multiply会使颜色变亮。</li>
<li>Multiply常用于使颜色&#x2F;纹理变亮或变暗，或用于操作纹理UV。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mult-01.jpg" alt="mult-01"></li>
</ul>
<hr>
<h2 id="✏️Noise（math）"><a href="#✏️Noise（math）" class="headerlink" title="✏️Noise（math）"></a>✏️Noise（math）</h2><blockquote>
<p>噪点，噪波； 它有很多可以设置的参数。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/NoiseExample.jpg" alt="NoiseExample"></p>
<ul>
<li>【<strong>它的参数</strong>】：<ul>
<li><strong>Scale</strong>（更改噪点单元的整体大小。数字越小，噪点越大。）</li>
<li><strong>Quality</strong>（外观&#x2F;性能设置。值越小，速度越快，但效果越差；值越大，速度越慢，但效果更好。）</li>
<li><strong>function</strong>（噪波类型）<ul>
<li>Simplex</li>
<li>Gradient</li>
<li>Fast Gradient</li>
<li>Value</li>
<li>Voronoi</li>
</ul>
</li>
<li><strong>Turbulence</strong>（启用”干扰”（Turbulence）后，每个噪点倍频只会在结果中增加绝对值。改变视觉特征，并且会塑造出类似于清晰的山脊形状）</li>
<li><strong>Levels</strong>（不同范围要合并的不同噪点级数量乘以级别数量的计算成本。）</li>
<li><strong>Output Min</strong></li>
<li><strong>Output Max</strong></li>
<li><strong>Level Scale</strong></li>
<li><strong>Tiling</strong></li>
<li><strong>Repeat Size</strong></li>
</ul>
</li>
<li>【<strong>它的input</strong>】：<ul>
<li><strong>Position</strong>（允许通过 3D 矢量来调整纹理大小）</li>
<li><strong>FilterWidth</strong>（实际上，控制应用于噪点纹理的模糊量）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="✏️Normalize（math）"><a href="#✏️Normalize（math）" class="headerlink" title="✏️Normalize（math）"></a>✏️Normalize（math）</h2><blockquote>
<p>归一化；归一化向量（也称”单位向量”）的整体长度为1.0。这意味着输入的每个分量都除以向量的总大小（长度）。</p>
</blockquote>
<ul>
<li>通过Normalize传递(0,2,0)或(0,0.2,0)都将输出(0,1,0)。通过Normalize传递(0,1,-1)将输出(0, 0.707, -0.707)。全零向量是唯一的例外，它不会改变。</li>
<li>计算如下：先计算出长度d，再用每一个分量与长度d相除（x&#x2F;d,y&#x2F;d,z&#x2F;d），得到相应的归一化向量。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/normalize.png" alt="normalize"></li>
</ul>
<hr>
<h2 id="✏️Object-Orientation（coordinates）"><a href="#✏️Object-Orientation（coordinates）" class="headerlink" title="✏️Object Orientation（coordinates）"></a>✏️Object Orientation（coordinates）</h2><blockquote>
<p>输出object的世界场景向上向量(up)。换言之，对象的局部正z轴正指向此方向。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/object-orientation.jpg" alt="object-orientation"></p>
<hr>
<h2 id="✏️Object-Position-WS（coordinates）"><a href="#✏️Object-Position-WS（coordinates）" class="headerlink" title="✏️Object Position WS（coordinates）"></a>✏️Object Position WS（coordinates）</h2><blockquote>
<p>输出对象边界的世界场景空间中心位置。它的变化则是以整体中心为基准。</p>
</blockquote>
<ul>
<li>这对于为植物创建球形照明很有用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/object-position-ws.jpg" alt="object-position-ws"></li>
</ul>
<hr>
<h2 id="✏️Object-Radius（coordinates）"><a href="#✏️Object-Radius（coordinates）" class="headerlink" title="✏️Object Radius（coordinates）"></a>✏️Object Radius（coordinates）</h2><blockquote>
<p>输出给定对象以 Unreal 单位计的半径值。系统会对比例缩放加以考虑，并且对于每个对象，结果可能是唯一的。</p>
</blockquote>
<ul>
<li>比如可以根据radius调整贴图的tile来适配场景，而不会因为它等比增加或减少而导致贴图错误。</li>
</ul>
<hr>
<h2 id="✏️One-Minus（math）"><a href="#✏️One-Minus（math）" class="headerlink" title="✏️One-Minus（math）"></a>✏️One-Minus（math）</h2><blockquote>
<p>反向，反色；接受输入值”X”并输出”1 - X”。</p>
</blockquote>
<p>-当输入的颜色在[0,1]范围内时，OneMinus的效果与我们通常所说的”反色”是一样的，也就是说，OneMinus返回的是添加到输入时会产生白色的互补色。</p>
<hr>
<h2 id="✏️Packed-Textures"><a href="#✏️Packed-Textures" class="headerlink" title="✏️Packed Textures"></a>✏️Packed Textures</h2><blockquote>
<p>打包，合并贴图；可以将metallic和roughness等灰度图合并到一起，分别放在rgb的相应通道中使用，以得到更好的性能（相比于多张分开的贴图）。</p>
</blockquote>
<hr>
<h2 id="✏️Panner（coordinates）"><a href="#✏️Panner（coordinates）" class="headerlink" title="✏️Panner（coordinates）"></a>✏️Panner（coordinates）</h2><blockquote>
<p>平移，输出可用于创建平移（或移动）纹理的 UV 纹理坐标。</p>
</blockquote>
<ul>
<li>示例：调整speed使其变化<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/PannerExample.jpg" alt="PannerExample"></li>
</ul>
<hr>
<h2 id="✏️Parameter-Collection（材质参数集合）"><a href="#✏️Parameter-Collection（材质参数集合）" class="headerlink" title="✏️Parameter Collection（材质参数集合）"></a>✏️Parameter Collection（材质参数集合）</h2><blockquote>
<p>材质参数集合，是虚幻内部的一个item，属于一种资产。<br>它允许你在里面放置参数，并且可以跨越多种材质来使用它，可以一次性将这个全局性数据导入多个材质，并且允许你同时控制调整这个参数。</p>
</blockquote>
<ul>
<li>它还有助于设置关卡中的效果，例如雪量、破坏程度、湿度等。如果不使用材质参数集合，你需要在关卡的不同材质实例中单独设置许多材质参数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/create-mpc.jpg" alt="create-mpc"></li>
<li>设置好后，可以去材质节点版面调用它。</li>
<li>它的使用方法官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/using-material-parameter-collections-in-unreal-engine/">链接在此</a></li>
</ul>
<hr>
<h2 id="✏️Parameters（convert-to-Parameters）"><a href="#✏️Parameters（convert-to-Parameters）" class="headerlink" title="✏️Parameters（convert to Parameters）"></a>✏️Parameters（convert to Parameters）</h2><blockquote>
<p>转为参数；它更多是指特定节点上的切换，允许他们在实例（instance）材质被使用。<br>基本上通俗的理解就是：转化原材质的参数，在复制后的代理材质也会拥有原材质一样的功能，可以被修改和实时调整，而不需要取重新打开材质版面修改再重新编译材质。</p>
</blockquote>
<ul>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/convertParameters.png" alt="convertParameters"></li>
</ul>
<hr>
<h2 id="✏️Physical-Material（物理材质）"><a href="#✏️Physical-Material（物理材质）" class="headerlink" title="✏️Physical Material（物理材质）"></a>✏️Physical Material（物理材质）</h2><blockquote>
<p>物理材质，用于定义物理对象在与世界场景动态交互时的响应。<br>物理材质非常容易使用。创建一个物理材质将提供一组默认值，这与应用于所有物理对象的默认物理材质相同。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/create_PhysicalMaterial.png" alt="create_PhysicalMaterial"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/parameters_PhysicalMaterial.png" alt="parameters_PhysicalMaterial"></p>
<ul>
<li>以上示例是创建物理材质以及双击编辑材质。使用物理材质的教学官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/physical-materials-user-guide-for-unreal-engine/">链接在此</a></li>
<li>它的物理材质属性在官方可以找到，<a href="https://docs.unrealengine.com/5.0/zh-CN/physical-materials-reference-for-unreal-engine/">链接在此</a></li>
</ul>
<hr>
<h2 id="✏️Pixel-Depth（Depth）"><a href="#✏️Pixel-Depth（Depth）" class="headerlink" title="✏️Pixel Depth（Depth）"></a>✏️Pixel Depth（Depth）</h2><blockquote>
<p>像素深度，输出当前所渲染像素的深度，即该像素与摄像机之间的距离。</p>
</blockquote>
<ul>
<li>此表达式支持正数，不支持负数。这是因为在现代硬件上，渲染器依赖于保守深度优化来维持良好的性能。这就带来了额外的一点好处：如果深度可以 远离 摄像机，硬件深度抑制（hardware depth rejection）可以通过顶点着色器输出重复使用。否则，如果允许像素深度偏移 移向 摄像机，就可能导致对象戳穿一切，这样无论像素是否使用像素深度偏移进行遮挡，像素着色器都会处理这些像素。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/PixelDepth.png" alt="PixelDepth"></p>
<ul>
<li>在此示例中，已将材质网络应用于地板。请注意当地板后退 2048 个以上单位时，线性插值在两种颜色之间是如何进行混合的。使用了 Power（幂）表达式来加强这两种颜色之间的对比，并产生更有意义的视觉效果。</li>
</ul>
<hr>
<h2 id="✏️Pixel-Normal-WS（Coordinates）"><a href="#✏️Pixel-Normal-WS（Coordinates）" class="headerlink" title="✏️Pixel Normal WS（Coordinates）"></a>✏️Pixel Normal WS（Coordinates）</h2><blockquote>
<p>根据当前法线输出向量数据，该数据表示像素所面对的方向。它在世界空间中，逐像素给出对应结果。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/pixel-normal-ws.jpg" alt="pixel-normal-ws"></p>
<ul>
<li>在此示例中，PixelNormalWS被输入到底色（Base Color）中。请注意，法线贴图用于给出逐像素结果。</li>
</ul>
<hr>
<h2 id="✏️Post-Processing-Material-Property（后期材质）"><a href="#✏️Post-Processing-Material-Property（后期材质）" class="headerlink" title="✏️Post Processing Material Property（后期材质）"></a>✏️Post Processing Material Property（后期材质）</h2><blockquote>
<p>后期材质，后期处理材质使你能够设置与后期处理一起使用的材质，以创建破坏的视觉屏幕效果、区域类型效果或 只能通过后置处理材质才能实现的游戏整体外观。</p>
</blockquote>
<ul>
<li>在ue document中有详细介绍，<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/PostProcessMaterials/">链接在此</a></li>
<li>以及一些效果示例，<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview/">链接在此</a></li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/postProcess.png" alt="postProcess"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/postProcess_02.png" alt="postProcess_02"></p>
<ul>
<li>将材质设置为post process时，它的属性栏就会被激活。材质只能使用 自发光颜色（Emissive Color） 输出新颜色。此外，你还可以定义在后期处理过程中应在何处应用此通道， 如果有多个通道，则应按什么顺序处理（优先级）</li>
</ul>
<hr>
<h2 id="✏️Power（math）"><a href="#✏️Power（math）" class="headerlink" title="✏️Power（math）"></a>✏️Power（math）</h2><blockquote>
<p>幂，N次方；它接收两个输入：基值(Base)和指数(Exp)。它将基值提高到指数的幂，并输出结果。换句话说，它返回 Base 乘以自身 Exp 次。</p>
</blockquote>
<ul>
<li>示例：当底数为0.5且指数为2.0时，幂为0.25。</li>
</ul>
<hr>
<h2 id="✏️Property"><a href="#✏️Property" class="headerlink" title="✏️Property"></a>✏️Property</h2><blockquote>
<p>材质属性；材质版面details可以具体调整材质的各种属性。</p>
</blockquote>
<ul>
<li>它有很详细的官方文档，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a></li>
<li>官方文档中，它的每一个属性以及下拉菜单都有详细介绍。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/material-properties-all.jpg" alt="material-properties-all"></li>
</ul>
<hr>
<h2 id="✏️quality-switch（utility）"><a href="#✏️quality-switch（utility）" class="headerlink" title="✏️quality switch（utility）"></a>✏️quality switch（utility）</h2><blockquote>
<p>质量开关；通过调整质量设置，来切换引擎质量的显示，来配合硬件的性能，适配对应相应的画质表现。允许设置low，mid，high。<br>允许根据引擎在不同质量级别之间的切换使用不同的网络，例如在较低端的设备上使用较低的质量。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/qualitySwitch.png" alt="qualitySwitch"></p>
<hr>
<h2 id="✏️Radial-Gradient-Exponential（Gradient）"><a href="#✏️Radial-Gradient-Exponential（Gradient）" class="headerlink" title="✏️Radial Gradient Exponential（Gradient）"></a>✏️Radial Gradient Exponential（Gradient）</h2><blockquote>
<p>指数径向渐变；函数使用 UV 通道 0 来产生径向渐变，同时允许用户调整半径和中心点偏移。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RadialGradientExponential_02.png" alt="RadialGradientExponential_02"></p>
<hr>
<h2 id="✏️Rotate-About-Axis（utility）"><a href="#✏️Rotate-About-Axis（utility）" class="headerlink" title="✏️Rotate About Axis（utility）"></a>✏️Rotate About Axis（utility）</h2><blockquote>
<p>绕轴旋转，给定旋转轴、该轴上的某个点以及旋转角度的情况下，旋转三通道矢量输入。此表达式适合于使用”全局位置偏移”（WorldPositionOffset）产生简单剪切的动画。</p>
</blockquote>
<ul>
<li>示例：预览平面将显示为绕着它的垂直轴旋转。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/RotateAboutAxisExample.jpg" alt="RotateAboutAxisExample"></li>
</ul>
<hr>
<h2 id="✏️Rotator（coordinate）"><a href="#✏️Rotator（coordinate）" class="headerlink" title="✏️Rotator（coordinate）"></a>✏️Rotator（coordinate）</h2><blockquote>
<p>旋转，以双通道向量值形式输出 UV 纹理坐标，该向量值可用来创建旋转纹理。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/rotatorExample.png" alt="rotatorExample"></p>
<hr>
<h2 id="✏️screen-Position（coordinate）"><a href="#✏️screen-Position（coordinate）" class="headerlink" title="✏️screen Position（coordinate）"></a>✏️screen Position（coordinate）</h2><blockquote>
<p>屏幕位置，输出当前所渲染像素的屏幕空间位置。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/screen-position.jpg" alt="screen-position"></p>
<hr>
<h2 id="✏️sin和cosine（math）"><a href="#✏️sin和cosine（math）" class="headerlink" title="✏️sin和cosine（math）"></a>✏️sin和cosine（math）</h2><blockquote>
<p>常见使用用途是输出某种有规律的waves。<br><strong>sine，正弦</strong>。表示输入范围和[-1, 1]的输出范围上反复输出正弦波的值。它与Cosine表达式的输出之间的区别是输出波形被四分之一的周期所抵消，这意味着”Cos(X)”等于”Sin(X + 0.25)”。<br>sine最常用于通过将一个 时间（Time） 表达式与其输入连接来输出连续的振荡波形，但它也可以用于在世界场景空间或屏幕空间或任何其他需要连续、平滑循环的应用中创建波纹。波形的可视化表示如下图所示，缩放到[0, 1]输出范围：</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SineWave.jpg" alt="SineWave">、<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SineExample.jpg" alt="SineExample"></p>
<blockquote>
<p><strong>cosine, 余弦</strong>；表示在[0, 1]的输入范围和[-1, 1]的输出范围上反复输出余弦波的值。<br>cosine最常用于通过将一个 时间 表达式与其输入连接来输出连续的振荡波形，但它也可以用于在世界场景空间或屏幕空间或任何其他需要连续、平滑循环的应用中创建波纹。波形的可视化表示如下图所示，缩放到[0, 1]输出范围：</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/CosineWave.jpg" alt="CosineWave"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/CosineExample.jpg" alt="CosineExample"></p>
<hr>
<h2 id="✏️sphere-mask（utility）"><a href="#✏️sphere-mask（utility）" class="headerlink" title="✏️sphere mask（utility）"></a>✏️sphere mask（utility）</h2><blockquote>
<p>球体蒙版；根据距离计算来输出蒙版值。<br>如果某一个输出是某个点的位置，而另一输入是具有某半径的球体的中心，那么蒙版值将是0（位于球体外部）和1（位于球体内部），并存在一定的过渡区域。此表达式可作用于单分量、双分量、三分量和四分量矢量。</p>
</blockquote>
<ul>
<li>示例：当摄像机距离预览对象超过256个单位时，该对象将平滑地渐变为黑色。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/SphereMaskExample.jpg" alt="SphereMaskExample"></li>
</ul>
<hr>
<h2 id="✏️square-Root（math）"><a href="#✏️square-Root（math）" class="headerlink" title="✏️square Root（math）"></a>✏️square Root（math）</h2><blockquote>
<p>平方根；。如果应用于向量，则每个分量将分别处理。输出的也是一个数学结果。</p>
</blockquote>
<ul>
<li>对于0到1范围内的纹理，这会降低图像的对比度。例如，在下面的校准纹理中，深色值会变得更亮，白色值会向灰色转变。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/square-root.jpg" alt="square-root"></li>
</ul>
<hr>
<h2 id="✏️substract（math）"><a href="#✏️substract（math）" class="headerlink" title="✏️substract（math）"></a>✏️substract（math）</h2><blockquote>
<p>减法；接受两个输入，将第一个输入减去第二个输入，然后输出差值。</p>
</blockquote>
<ul>
<li>两个输入必须有相同数量的值，但其中一个值是单个常量值时例外。在这种情况下，将多通道输入的每个通道减去常量值，并将结果存储在输出值的单独通道中。</li>
<li><strong>示例</strong>：0.5与0.2相减得0.3；(0.2,-0.4,0.6)与(0.1,0.1,1.0)相减得(0.1,-0.5,-0.4)；(0.2,0.4,1.0)与0.2相减得(0.0,0.2,0.8)。</li>
<li>Subtract可以用来加深颜色和偏移UV。</li>
</ul>
<hr>
<h2 id="✏️swizzle（miscellaneous）"><a href="#✏️swizzle（miscellaneous）" class="headerlink" title="✏️swizzle（miscellaneous）"></a>✏️swizzle（miscellaneous）</h2><blockquote>
<p>通道扰乱，主要作用是flip原来的x和y，比如xyz会变成yxz。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/swizzle.png" alt="swizzle"></p>
<hr>
<h2 id="✏️Time（constant）"><a href="#✏️Time（constant）" class="headerlink" title="✏️Time（constant）"></a>✏️Time（constant）</h2><blockquote>
<p>时间；用来向材质（例如，Panner（平移）、Cosine（余弦） 或其他时间相关操作）添加经历时间。代表时间流逝，但是会不断更新。</p>
</blockquote>
<ul>
<li>它有两个参数：<ul>
<li>Ignore Pause（如果为 true，那么时间将一直推进，即使游戏暂停也是这样。）</li>
<li>Period （如果为 true，那么这将是时间回绕前经过的时间量。针对移动材质，这将以全精度在 CPU 上执行周期计算，而在 GPU 上，将以半精度运行（处理长度超过一分钟的周期时，可能会产生问题））</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/TimeExample.jpg" alt="TimeExample"></p>
<ul>
<li>上图中说明的网络将创建一个随时间推移而变化的材质，从而连贯地展现白色与黑色之间的正弦曲线过渡。如果启用了时间段，那么将时间段设置为 0 会有效地停止过渡，而设置为 1 相当于时间段为 false。设置接近于 0 的数值将使材质更迅速地变化。</li>
</ul>
<hr>
<h2 id="✏️Translucency-Property"><a href="#✏️Translucency-Property" class="headerlink" title="✏️Translucency Property"></a>✏️Translucency Property</h2><blockquote>
<p>半透明属性；<br>最终颜色 &#x3D; 源颜色 不透明度 + 目标颜色 (1 - 不透明度)。此混合模式与动态光照 不 兼容。</p>
</blockquote>
<ul>
<li>需要确保 screnn space reflcetions 为true，开启后支持半透明材质的屏幕空间反射。</li>
<li>并且根据场景需求选择Translucency lighting mode，这可以控制半透明（Translucency）在该材质中使用的光照模式。下拉菜单越往下开销越大。</li>
<li>材质属性详细查看document，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a></li>
</ul>
<hr>
<h2 id="✏️Translucency-self-shadowing-Property"><a href="#✏️Translucency-self-shadowing-Property" class="headerlink" title="✏️Translucency self shadowing Property"></a>✏️Translucency self shadowing Property</h2><blockquote>
<p>半透明自投影；<strong>半透明自身阴影是一种获得体积光照半透明对象（例如烟柱或蒸汽柱）的好方法</strong>。自投影分为两个主要部分：自身阴影密度（Self Shadow Density）和第二自身阴影密度（Second Self Shadow Density）。这两个部分的存在为变化提供了可能。你可以单独定义各个部分的密度，并使用它们之间的差异在整个自身阴影中获得你需要的模式。</p>
</blockquote>
<ul>
<li>在translucent mode下使用，需要有一个base color</li>
<li>材质属性详细查看document，<a href="https://docs.unrealengine.com/5.0/zh-CN/unreal-engine-material-properties/">链接在此</a><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/translucency-self-shadowing.jpg" alt="translucency-self-shadowing"></li>
</ul>
<hr>
<h2 id="✏️Tesselation-Property"><a href="#✏️Tesselation-Property" class="headerlink" title="✏️Tesselation Property"></a>✏️Tesselation Property</h2><blockquote>
<p>曲面细分；增加了额外的几何，用于添加更多物理细节。</p>
</blockquote>
<ul>
<li>Flat Tessellation，曲面细分的简单形式。此模式会在不平滑网格体的前提下添加更多三角形。</li>
<li>PN Triangles，使用基于样条的简单曲面细分，这种曲面细分虽然开销更高，但细节表现效果更佳。</li>
<li>官方文档<a href="https://docs.unrealengine.com/4.26/zh-CN/RenderingAndGraphics/Materials/MaterialProperties/">链接在此</a></li>
</ul>
<hr>
<h2 id="✏️Texture-Coordinate（coordinate）"><a href="#✏️Texture-Coordinate（coordinate）" class="headerlink" title="✏️Texture Coordinate（coordinate）"></a>✏️Texture Coordinate（coordinate）</h2><blockquote>
<p>纹理坐标；双通道，输出uv纹理坐标，改变uv平铺。</p>
</blockquote>
<ul>
<li>如需访问网格体的第二个 UV 通道，请创建一个 TextureCoordinate（纹理坐标）节点，将其”坐标索引”（CoordinateIndex）设置为 1（0 表示第一个通道，1 表示第二个通道，等等），并将其连接到 TextureSample（纹理取样）节点的 UV 输入。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/texture-coordinates.jpg" alt="texture-coordinates"></li>
</ul>
<hr>
<h2 id="✏️Texture-sample（texture）"><a href="#✏️Texture-sample（texture）" class="headerlink" title="✏️Texture sample（texture）"></a>✏️Texture sample（texture）</h2><blockquote>
<p>纹理贴图，输出input的纹理颜色，一般就是2d贴图为主</p>
</blockquote>
<ul>
<li><strong>UVs</strong>，接收UV纹理坐标，以用于纹理。如果没有任何值输入到UV，那么将使用材质所应用到的网格体的纹理坐标</li>
<li>**DDX(UVs)**，接收UV输入的DDX以用于各向异性过滤。默认情况下，硬件自动执行此过滤，并且速度更快。但是在某些情况下，可能需要使用DDX材质表达式显式地设置此项目，以避免延迟贴花的2x2像素块瑕疵之类的瑕疵。仅当 Mip值模式（MipValueMode） &#x3D; 导数（Derivative） 时才可用。</li>
<li>**DDY(UVs)**，接收UV输入的DDY以用于各向异性过滤，这与DDX（UV）接收UV输入的DDX相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/TextureSampleExample.jpg" alt="TextureSampleExample"></li>
</ul>
<hr>
<h2 id="✏️value-step（gradient）"><a href="#✏️value-step（gradient）" class="headerlink" title="✏️value step（gradient）"></a>✏️value step（gradient）</h2><blockquote>
<p>值阶；接收现有的纹理通道或渐变，并根据用户的输入来输出纯黑白色图像。结果是一个蒙版，它代表与输入值相等的渐变部分。</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/valueStep.png" alt="valueStep"></p>
<hr>
<h2 id="✏️vector-to-radial-value（miscellaneous）"><a href="#✏️vector-to-radial-value（miscellaneous）" class="headerlink" title="✏️vector to radial value（miscellaneous）"></a>✏️vector to radial value（miscellaneous）</h2><blockquote>
<p>矢量到径向值；将”矢量 2”矢量转换为角度，或者将 UV 坐标数据转换为径向坐标。对于矢量，角度将在一个通道中输出，而矢量长度在另一通道中输出。</p>
</blockquote>
<ul>
<li>Radial Coordinates（返回输入的径向坐标，对于矢量，角度将在一个通道中输出，而距离在另一通道中输出。）</li>
<li>Vector Converted to Angle（返回输入矢量的角度，返回径向梯度）</li>
<li>Linear Distance（返回输入矢量的线性长度，对于 UV，输出距离的径向梯度。）<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vectorToRadialValue.png" alt="vectorToRadialValue"></li>
</ul>
<hr>
<h2 id="✏️vertex-Normal-WS（coordinate）"><a href="#✏️vertex-Normal-WS（coordinate）" class="headerlink" title="✏️vertex Normal WS（coordinate）"></a>✏️vertex Normal WS（coordinate）</h2><blockquote>
<p>世界场景空间顶点法线；它只能用于在顶点着色器中执行的材质输入，例如WorldPositionOffset。<br>该表达式对于设置网格体增大或缩小很有用</p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vertexNormalWS.png" alt="vertexNormalWS"></p>
<ul>
<li>如上示例，小球每个顶点的法线会在各自法线方向上移动，会随着正弦运动按比例放大和缩小。</li>
</ul>
<hr>
<h2 id="✏️view-size（coordinate）"><a href="#✏️view-size（coordinate）" class="headerlink" title="✏️view size（coordinate）"></a>✏️view size（coordinate）</h2><blockquote>
<p>视图大小；表达式输出一个 2D 向量，以给出当前视图的大小（以像素为单位）。<strong>这对于使材质根据当前屏幕分辨率产生各种变化来说非常有用。</strong></p>
</blockquote>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/viewsize.png" alt="viewsize"></p>
<ul>
<li>如示例，按照视图比例，来变换颜色。</li>
</ul>
<hr>
<h2 id="✏️world-position（coordinate）"><a href="#✏️world-position（coordinate）" class="headerlink" title="✏️world position（coordinate）"></a>✏️world position（coordinate）</h2><blockquote>
<p>全局位置，输出当前像素在全局空间中的位置。</p>
</blockquote>
<ul>
<li>常见用法是确定从摄像机到像素的径向距离，而不是像 PixelDepth（像素深度）那样确定正交距离。WorldPosition（全局位置）也可用作纹理坐标，并让不相关的网格在它们彼此邻近时进行纹理坐标匹配。以下是使用 WorldPosition.xy 对纹理进行二维贴图的基本示例：</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/world-position-planar.jpg" alt="world-position-planar"></li>
</ul>
<hr>
<p>wtf is material 全篇到这里就结束了，这一遍看的很粗略，不过收益很多！还会持续学习！</p>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-材质</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4以及相关工具学习列表合辑</title>
    <url>/2022/09/09/unreal/</url>
    <content><![CDATA[<p>这篇是我的UE学习记录了，也算是我的UE学习置顶占位。2022是我学习UE的第一年，来记录一下<br>然后写的不一定是教程笔记哈，有些别的好的我也会随意写写放上来。<br>详细如下，都有各个的部分的站内链接<br>每篇写好了就会更新！<br>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</p>
<hr>
<h1 id="🚩UE材质基础"><a href="#🚩UE材质基础" class="headerlink" title="🚩UE材质基础"></a>🚩UE材质基础</h1><h2 id="UE4官方材质课-基础篇"><a href="#UE4官方材质课-基础篇" class="headerlink" title="UE4官方材质课_基础篇"></a>UE4官方材质课_基础篇</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/uefoundation_cover.png" alt="uefoundation_cover"><br><strong>站内link：</strong></p>
<a href="/2022/09/13/ue_MatClass_foundation/" title="UE4官方材质课_基础篇">UE4官方材质课_基础篇</a>

<hr>
<h1 id="🚩WTF-is-Material？学习"><a href="#🚩WTF-is-Material？学习" class="headerlink" title="🚩WTF is Material？学习"></a>🚩WTF is Material？学习</h1><h2 id="UE4-虚幻引擎材质节点以及蓝图的学习"><a href="#UE4-虚幻引擎材质节点以及蓝图的学习" class="headerlink" title="UE4_虚幻引擎材质节点以及蓝图的学习"></a>UE4_虚幻引擎材质节点以及蓝图的学习</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/wtfISMat.png" alt="wtfISMat"><br><strong>站内link：</strong></p>
<a href="/2022/10/14/ue_WTF_is_Material_all/" title="UE4_虚幻引擎材质节点以及蓝图的学习">UE4_虚幻引擎材质节点以及蓝图的学习</a>

<hr>
<h1 id="🚩UE灯光技巧："><a href="#🚩UE灯光技巧：" class="headerlink" title="🚩UE灯光技巧："></a>🚩UE灯光技巧：</h1><h2 id="一：UE灯光流程以及方案（Light-a-project-in-UE）"><a href="#一：UE灯光流程以及方案（Light-a-project-in-UE）" class="headerlink" title="一：UE灯光流程以及方案（Light a project in UE）"></a>一：UE灯光流程以及方案（Light a project in UE）</h2><p><strong>站内link：</strong></p>
<a href="/2022/09/18/ue_Light_a_Project_in_UE/" title="Light_a_Project_in_UE">Light_a_Project_in_UE</a>]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇测试</title>
    <url>/2022/09/07/%E6%B5%8B%E8%AF%95%E4%B8%80/</url>
    <content><![CDATA[<p>这是一个测试，看看第一篇是否顺利保存并打开！<br>这里只是一个简陋的文本所以跳过就行</p>
]]></content>
  </entry>
</search>
